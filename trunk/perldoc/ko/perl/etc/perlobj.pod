=head1 NAME
X<object> X<OOP>

=begin original

perlobj - Perl objects

=end original

perlobj - Perl 의 오브젝트

=head1 DESCRIPTION

=begin original

First you need to understand what references are in Perl.
See L<perlref> for that.  Second, if you still find the following
reference work too complicated, a tutorial on object-oriented programming
in Perl can be found in L<perltoot> and L<perltooc>.

=end original

우선 처음으로 Perl에서의 리퍼런스가 무엇인지를 이해하고 있어야합니다.
이에 대해서는 L<perlref> 를 참조해 주세요.
두번째로는, 이제부터 설명하는 리퍼런스의 동작이 너무 복잡하다고 생각하신다면,
Perl 에서의 오브젝트지향 프로그래밍의 튜토리얼이 
L<perltoot> 와 L<perltooc> 에 있으니 참고하세요.

=begin original

If you're still with us, then
here are three very simple definitions that you should find reassuring.

=end original

여기까지로 아직 읽어나갈 기운이 있다면, 당신을 안심시키기 위한 것입니다.
세개의 꽤 단순한 정의가 있습니다.

=over 4

=item 1.

=begin original

An object is simply a reference that happens to know which class it
belongs to.

=end original

오브젝트란, 단순히 자신이 어느 클래스에 속해있는 가를 알고 있는 리퍼런스입니다.

=item 2.

=begin original

A class is simply a package that happens to provide methods to deal
with object references.

=end original

클래스란, 단순히 오브젝트의 리퍼런스를 취급하는 메소드를 제공하는 패키지입니다.

=item 3.

=begin original

A method is simply a subroutine that expects an object reference (or
a package name, for class methods) as the first argument.

=end original

메소드란, 단순히 첫번째 인수에 오브젝트의 리퍼런스(혹은 클래스의 메소드에 대한
패키지명)을 얻을 수 있는 서브루틴입니다.

=back

=begin original

We'll cover these points now in more depth.

=end original

이런 것들에 대해서 더 깊게 파고 들어 가겠습니다.

=head2 An Object is Simply a Reference
X<object> X<bless> X<constructor> X<new>

(오브젝트는 단순한 레퍼런스)

=begin original

Unlike say C++, Perl doesn't provide any special syntax for
constructors.  A constructor is merely a subroutine that returns a
reference to something "blessed" into a class, generally the
class that the subroutine is defined in.  Here is a typical
constructor:

=end original

C++ 과는 달리 Perl은 컨스트럭터에 대해 특별한 구문을 준비하지 않습니다.
컨스트럭터는 단순히, 클래스에 "bless" 한 무엇인가의 리퍼런스를
반환하는 서브루틴으로, 일반적으로는 서브틴이 정의되어 있는 클래스입니다.
아래는 전형적인 컨스트럭터를 나타냅니다.

    package Critter;
    sub new { bless {} }

=begin original

That word C<new> isn't special.  You could have written
a construct this way, too:

=end original

C<new> 라고 하는 단어는 특별한 것이 아닙니다.
컨스트럭터를 아래와 같이 쓰는 것도 가능합니다.

    package Critter;
    sub spawn { bless {} }

=begin original

This might even be preferable, because the C++ programmers won't
be tricked into thinking that C<new> works in Perl as it does in C++.
It doesn't.  We recommend that you name your constructors whatever
makes sense in the context of the problem you're solving.  For example,
constructors in the Tk extension to Perl are named after the widgets
they create.

=end original

실제로는, 이건 C++ 프로그래머가 C++ 처럼 Perl 의 C<new> 가 동작한다고
생각해서 함정에 빠질 일이 없다 는 점에서 선택할 만한 것입니다.
해결하고 픈 문제에 관한 컨텍스트에서 알기쉬운 컨스트럭터로 하는 것을
추천합니다. 예를 들면, Perl 의 Tk 익스텐션의 컨스트럭터에서는
작성하는 위젯에서 이름을 얻고 있습니다.

=begin original

One thing that's different about Perl constructors compared with those in
C++ is that in Perl, they have to allocate their own memory.  (The other
things is that they don't automatically call overridden base-class
constructors.)  The C<{}> allocates an anonymous hash containing no
key/value pairs, and returns it  The bless() takes that reference and
tells the object it references that it's now a Critter, and returns
the reference.  This is for convenience, because the referenced object
itself knows that it has been blessed, and the reference to it could
have been returned directly, like this:

=end original

Perl 의 컨스트럭터에 관해서 C++ 과 다른 것은,
C++ 에서는 자신이 메모리를 할당할 필요가 있다는 것입니다.
C<{}> 는 빈 이름없는 해쉬를 할당합니.
bless() 는 인수에 리퍼런스를 얻고, 그 오브젝트에 오브젝트가
Critter 의 리퍼런스인 것을 알리고, 리퍼런스를 반환합니다.
참조된 오브젝트는 그 자신이 bless 되어 있는 것을 아고 있고,
리퍼런스는 아래의 예처럼 직접 반환할 수 있습니다.

    sub new {
	my $self = {};
	bless $self;
	return $self;
    }

=begin original

You often see such a thing in more complicated constructors
that wish to call methods in the class as part of the construction:

=end original

실제로는, 구축의 일부로써 클래스의 메소드를 호출하는 것처럼 더욱
복잡한 컨스트럭터를 잘 보이도록 하는 것이겠죠.

    sub new {
	my $self = {};
	bless $self;
	$self->initialize();
	return $self;
    }

=begin original

If you care about inheritance (and you should; see
L<perlmodlib/"Modules: Creation, Use, and Abuse">),
then you want to use the two-arg form of bless
so that your constructors may be inherited:

=end original

상속에 대해서 신경쓰고 있으면(혹 그러고 계시다면,
L<perlmodlib/"Modules: Creation, Use, and Abuse">를 참조해주세요)
계승될지도 모르는 컨스트럭터에서 인수 두개를 얻는 형식의 bless 를
사용하고 싶다면 :

    sub new {
	my $class = shift;
	my $self = {};
	bless $self, $class;
	$self->initialize();
	return $self;
    }

=begin original

Or if you expect people to call not just C<< CLASS->new() >> but also
C<< $obj->new() >>, then use something like the following.  (Note that using
this to call new() on an instance does not automatically perform any
copying.  If you want a shallow or deep copy of an object, you'll have to
specifically allow for that.)  The initialize() method used will be of
whatever $class we blessed the object into:

=end original

혹은, 유저가 C<< CLASS->new() >> 가 아닌 C<< $obj->new() >> 를 사용하는 것을
기대하고 있다면, 아래와 같은 형식을 사용합니다.
initialize() 라 하는 메소드는 $class를 자신들이 오브젝트에 bless 하고 있는 
지 어떤 지에 상관없이 사용됩니다.

(TBT)

    sub new {
	my $this = shift;
	my $class = ref($this) || $this;
	my $self = {};
	bless $self, $class;
	$self->initialize();
	return $self;
    }

=begin original

Within the class package, the methods will typically deal with the
reference as an ordinary reference.  Outside the class package,
the reference is generally treated as an opaque value that may
be accessed only through the class's methods.

=end original

클래스 패키지 안에서는, 메소드는 리퍼런스를 보통의 리퍼런스로써 취급됩니다.
클래스 패키지의 바깥쪽에서는 리퍼런스는 일반적으로 클래스 메소드를
통해서만 접근하는 것이 가능한 불투명한 값(opaque value)인 것처럼
취급됩니다.

=begin original

Although a constructor can in theory re-bless a referenced object
currently belonging to another class, this is almost certainly going
to get you into trouble.  The new class is responsible for all
cleanup later.  The previous blessing is forgotten, as an object
may belong to only one class at a time.  (Although of course it's
free to inherit methods from many classes.)  If you find yourself
having to do this, the parent class is probably misbehaving, though.

=end original

컨스트럭터는 현재 참조된 오브젝트를 별도의 클래스에 소속시키기 위해
다시 bless 할지도 모릅니다.
하지만, 새로운 클래스는 나중에 없어지는 원인이 됩니다.
오브젝트는 한번에 하나의 클래스에만 속할 수 없는 것처럼 
이전의 bless는 잊혀져버립니다(많은 클래스에서 메소드를 상속하는 것이
자유롭게 된다고 해도, 마찬가지입니다)
만약 다시 bless 하지않으면 안되는 것이라면, 부모 클래스는 잘못된
행동을 하고 있는 것입니다.

=begin original

A clarification:  Perl objects are blessed.  References are not.  Objects
know which package they belong to.  References do not.  The bless()
function uses the reference to find the object.  Consider
the following example:

=end original

해설 : Perl 의 오브젝트는 bless 되어 있습니다.
리퍼런스는 그렇지 않습니다.
오브젝트는 자신이 속해 있는 패키지가 무엇인지를 알고 있지만,
리퍼런스는 모릅니다.
함수 bless() 는 리퍼런스를 오브젝트로 간주하기 위해 사용됩니다.
아래의 예를 봐 주세요.

    $a = {};
    $b = $a;
    bless $a, BLAH;
    print "\$b is a ", ref($b), "\n";

=begin original

This reports $b as being a BLAH, so obviously bless()
operated on the object and not on the reference.

=end original

이것은 "$b as being a BLAH" 라고 표시됩니다. 
이것은 명확하게 bless() 는 리퍼런스에 대해서 가 아닌
오브젝트에 작용하는 것을 말합니다.

=head2 A Class is Simply a Package
X<class> X<package> X<@ISA> X<inheritance>

(클래스는 단순히 패키지)

=begin original

Unlike say C++, Perl doesn't provide any special syntax for class
definitions.  You use a package as a class by putting method
definitions into the class.

=end original

C++ 과는 달리, Perl 은 클래스정의에 대한 특별한 구문을 쓰지 않습니다.
패키지를, 메소드정의를 무리하게 집어넣은 클래스로써 사용합니다.

=begin original

There is a special array within each package called @ISA, which says
where else to look for a method if you can't find it in the current
package.  This is how Perl implements inheritance.  Each element of the
@ISA array is just the name of another package that happens to be a
class package.  The classes are searched (depth first) for missing
methods in the order that they occur in @ISA.  The classes accessible
through @ISA are known as base classes of the current class.

=end original

각 패키지에서 메소드를 찾지 못했을 때에 메소드를 찾으러 가는 
별도의 패키를 지시하는 @ISA 라고 불리는 특별한 배열이 있습니다.
이것이 Perl 이 상속을 할 수 있는 방법입니다.
배열 @ISA 의 각 요소는, 클래스 패키지인 별도의 패키지의 이름입니다.
클래스는,  @ISA에 있는 순번으로 메소드의 검색을 수행합니다.
@ISA 를 통해 접근하는 것이 가능한 클래스는 현재 클래스의
기본클래스로 알려지게 됩니다.

=begin original

All classes implicitly inherit from class C<UNIVERSAL> as their
last base class.  Several commonly used methods are automatically
supplied in the UNIVERSAL class; see L<"Default UNIVERSAL methods"> for
more details.
X<UNIVERSAL> X<base class> X<class, base>

=end original

모든 클래스는 암묵적으로 베이스클래스로써 C<UNIVERSAL>이라고 하는
클래스를 계승하고 있습니다.
UNIVERSAL 클래스에서 자동적으로 제공되는 일반적으로 사용되는 메소드가
몇 개가 있습니다.
자세한 내용은 L<"Default UNIVERSAL methods"> 을 참조해주세요.
X<UNIVERSAL> X<base class> X<class, base>

=begin original

If a missing method is found in a base class, it is cached
in the current class for efficiency.  Changing @ISA or defining new
subroutines invalidates the cache and causes Perl to do the lookup again.

=end original

베이스클래스에서 찾고 있는 메소드가 발견되면, 효율을 위해서
그 메소드는 현재클래스에서 캐싱됩니다.
@ISA 의 변경이나 새로운 서브루틴의 정의는 캐쉬를 무효화하고, Perl 에
다시금 메소드를 찾게합니다.

=begin original

If neither the current class, its named base classes, nor the UNIVERSAL
class contains the requested method, these three places are searched
all over again, this time looking for a method named AUTOLOAD().  If an
AUTOLOAD is found, this method is called on behalf of the missing method,
setting the package global $AUTOLOAD to be the fully qualified name of
the method that was intended to be called.
X<AUTOLOAD>

=end original

현재 클래스, 이름붙은 기본 클래스, UNIVERSAL 클래스를 검색해서,
이것 들중에 어느 것이 요구된 메소드를 가지고 있지 않으면,
AUTOLOAD() 라고 하는 이름의 메소드를 검색합니다.
AUTOLOAD 가 발견되면, 이 메소드는 놓쳐버린 메소드 도중에서
호출되어, 패키지 글로벌의 $AUTOLOAD 를 메소드의 완전수식이름이 되도록
설정합니다.
X<AUTOLOAD>

=begin original

If none of that works, Perl finally gives up and complains.

=end original

여기까지 전부 실패했다면, Perl 은 소리높여 에러 메시지를 냅니다.

=begin original

If you want to stop the AUTOLOAD inheritance say simply
X<AUTOLOAD>

=end original

AUTOLOAD 의 상속을 멈추고 싶은 경우는 간단하게 : 
X<AUTOLOAD>

	sub AUTOLOAD;

=begin original

and the call will die using the name of the sub being called.

=end original

and the call will die using the name of the sub being called.
(TBT)

=begin original

Perl classes do method inheritance only.  Data inheritance is left up
to the class itself.  By and large, this is not a problem in Perl,
because most classes model the attributes of their object using an
anonymous hash, which serves as its own little namespace to be carved up
by the various classes that might want to do something with the object.
The only problem with this is that you can't sure that you aren't using
a piece of the hash that isn't already used.  A reasonable workaround
is to prepend your fieldname in the hash with the package name.
X<inheritance, method> X<inheritance, data>

=end original

Perl의 클래스는 메소드의 상속만을 수행합니다.
데이터의 상속은 클래스 스스로 맡겨집니다.
이 것은 Perl의 문제가 아닙니다.
왜냐면, 대부분의 클래스는 이름없는 해쉬를 사용해서, 클래스의 오브젝트의
속성을 모델화하고 있습니다.
이 이름없는 해쉬는 그 오브젝트에 대해 무멋인가를 수행하는 것 처럼
여러 클래스마다 고유의 이름공간을 작게 나누는 역할을 맡습니다.
이것에 관해 문제는 사용한 해쉬의 조ㄱ이 이미 사용된 것이 아닌 것에
확신이 가질 수 없다는 것입니다.
이것에 관해 현실적인 대응책은 해쉬의 필드이름에 패키지이름을 사용하는
것입니다.
X<inheritance, method> X<inheritance, data>

    sub bump {
	my $self = shift;
	$self->{ __PACKAGE__ . ".count"}++;
    } 

=head2 A Method is Simply a Subroutine
X<method>

(메소드는 단순히 서브루틴)

=begin original

Unlike say C++, Perl doesn't provide any special syntax for method
definition.  (It does provide a little syntax for method invocation
though.  More on that later.)  A method expects its first argument
to be the object (reference) or package (string) it is being invoked
on.  There are two ways of calling methods, which we'll call class
methods and instance methods.  

=end original

C++ 과는 달리, Perl 은 메소드 정의에 대한 특별한 구문이 없습니다.
(하지만, 나중에 기술하는 것처럼 메소드의 기동을 위해서 조금은
구문을 제공하고 있습니다)
메소드는 첫번째 인수로써, 메소드를 기동한 오브젝트(리퍼런스),
혹은 패키지(문자열)을 기대하고 있습니다.
메소드의 호ㄹ방법에는 두종류가 있는데, 각각 클래스 메소드,
인스턴스 메소드라고 부릅니다.

=begin original

A class method expects a class name as the first argument.  It
provides functionality for the class as a whole, not for any
individual object belonging to the class.  Constructors are often
class methods, but see L<perltoot> and L<perltooc> for alternatives.
Many class methods simply ignore their first argument, because they
already know what package they're in and don't care what package
they were invoked via.  (These aren't necessarily the same, because
class methods follow the inheritance tree just like ordinary instance
methods.)  Another typical use for class methods is to look up an
object by name:

=end original

클래스메소드는 첫번째 인수로써 클래스 이름을 기대합니다.
클래스메소드는 클래스 전체에 대한 기능을 제공하는 것이고, 클래스에
속한 각각의 오브젝트에 대한 것이 아닙니다.
컨스트럭터는 보통은 클래스메소드이지만,
대안에 대해서는 L<perltoot>와 L<perltooc>를 참조해주세요.
많은 클래스메소드는 단순히 첫번째인수를 무시합니다.
이것은 이미 자신이 놓여있는 패키지의 이름을 알고 있고,
패키지가 어떤 경로로 기동되었는 가를 신경쓸 필요가 없기 때문입니다.
(일반 인스턴스 메소드처럼 클래스메소드는 상속에 따르기 때문에,
이것들이 동일할 필요는 없습니다) 클래스메소드의 검사를 위한 것입니다.

    sub find {
	my ($class, $name) = @_;
	$objtable{$name};
    }

=begin original

An instance method expects an object reference as its first argument.
Typically it shifts the first argument into a "self" or "this" variable,
and then uses that as an ordinary reference.

=end original

인스턴스메소드는 첫번째 인수로 오브젝트의 리퍼런스를 기대합니다.
전형적으로 첫번째 인수는 "self" 든가 "this"라든가 하는 변수에 shift 되고,
그 다음은 일반적인 러퍼런스처럼 취급합니다.

    sub display {
	my $self = shift;
	my @keys = @_ ? @_ : sort keys %$self;
	foreach $key (@keys) {
	    print "\t$key => $self->{$key}\n";
	}
    }

=head2 Method Invocation
X<invocation> X<method> X<arrow> X<< -> >>

(메소드의 호출)

=begin original

For various historical and other reasons, Perl offers two equivalent
ways to write a method call.  The simpler and more common way is to use
the arrow notation:

=end original

역사적, 혹은 그 외의 여러 이유에 의해, Perl 은 메소드 호출을
쓰기위한 두개의 같은 방법을 제공하고 있습니다.
보다 단순하고 보다 일반적인 방법은 화살표 표기법을 사용하는 것입니다.

    my $fred = Critter->find("Fred");
    $fred->display("Height", "Weight");

=begin original

You should already be familiar with the use of the C<< -> >> operator with
references.  In fact, since C<$fred> above is a reference to an object,
you could think of the method call as just another form of
dereferencing.

=end original

You should already be familiar with the use of the C<< -> >> operator with
references.  In fact, since C<$fred> above is a reference to an object,
you could think of the method call as just another form of
dereferencing.
(TBT)

=begin original

Whatever is on the left side of the arrow, whether a reference or a
class name, is passed to the method subroutine as its first argument.
So the above code is mostly equivalent to:

=end original

Whatever is on the left side of the arrow, whether a reference or a
class name, is passed to the method subroutine as its first argument.
So the above code is mostly equivalent to:
(TBT)

    my $fred = Critter::find("Critter", "Fred");
    Critter::display($fred, "Height", "Weight");

=begin original

How does Perl know which package the subroutine is in?  By looking at
the left side of the arrow, which must be either a package name or a
reference to an object, i.e. something that has been blessed to a
package.  Either way, that's the package where Perl starts looking.  If
that package has no subroutine with that name, Perl starts looking for
it in any base classes of that package, and so on.

=end original

How does Perl know which package the subroutine is in?  By looking at
the left side of the arrow, which must be either a package name or a
reference to an object, i.e. something that has been blessed to a
package.  Either way, that's the package where Perl starts looking.  If
that package has no subroutine with that name, Perl starts looking for
it in any base classes of that package, and so on.
(TBT)

=begin original

If you need to, you I<can> force Perl to start looking in some other package:

=end original

もし必要なら、Perl に他のパッケージを見るように強制することも I<可能です>。

    my $barney = MyCritter->Critter::find("Barney");
    $barney->Critter::display("Height", "Weight");

=begin original

Here C<MyCritter> is presumably a subclass of C<Critter> that defines
its own versions of find() and display().  We haven't specified what
those methods do, but that doesn't matter above since we've forced Perl
to start looking for the subroutines in C<Critter>.

=end original

Here C<MyCritter> is presumably a subclass of C<Critter> that defines
its own versions of find() and display().  We haven't specified what
those methods do, but that doesn't matter above since we've forced Perl
to start looking for the subroutines in C<Critter>.
(TBT)

=begin original

As a special case of the above, you may use the C<SUPER> pseudo-class to
tell Perl to start looking for the method in the packages named in the
current class's C<@ISA> list.  
X<SUPER>

=end original

As a special case of the above, you may use the C<SUPER> pseudo-class to
tell Perl to start looking for the method in the packages named in the
current class's C<@ISA> list.  
X<SUPER>
(TBT)

    package MyCritter;
    use base 'Critter';    # sets @MyCritter::ISA = ('Critter');

    sub display { 
        my ($self, @args) = @_;
        $self->SUPER::display("Name", @args);
    }

=begin original

It is important to note that C<SUPER> refers to the superclass(es) of the
I<current package> and not to the superclass(es) of the object. Also, the
C<SUPER> pseudo-class can only currently be used as a modifier to a method
name, but not in any of the other ways that class names are normally used,
eg:
X<SUPER>

=end original

It is important to note that C<SUPER> refers to the superclass(es) of the
I<current package> and not to the superclass(es) of the object. Also, the
C<SUPER> pseudo-class can only currently be used as a modifier to a method
name, but not in any of the other ways that class names are normally used,
eg:
X<SUPER>
(TBT)

    something->SUPER::method(...);	# OK
    SUPER::method(...);			# WRONG
    SUPER->method(...);			# WRONG

=begin original

Instead of a class name or an object reference, you can also use any
expression that returns either of those on the left side of the arrow.
So the following statement is valid:

=end original

Instead of a class name or an object reference, you can also use any
expression that returns either of those on the left side of the arrow.
So the following statement is valid:
(TBT)

    Critter->find("Fred")->display("Height", "Weight");

=begin original

and so is the following:

=end original

そして以下のようにします:

    my $fred = (reverse "rettirC")->find(reverse "derF");

=begin original

The right side of the arrow typically is the method name, but a simple 
scalar variable containing either the method name or a subroutine 
reference can also be used.

=end original

The right side of the arrow typically is the method name, but a simple 
scalar variable containing either the method name or a subroutine 
reference can also be used.
(TBT)

=head2 Indirect Object Syntax
X<indirect object syntax> X<invocation, indirect> X<indirect>

(間接オブジェクト構文)

=begin original

The other way to invoke a method is by using the so-called "indirect
object" notation.  This syntax was available in Perl 4 long before
objects were introduced, and is still used with filehandles like this:

=end original

The other way to invoke a method is by using the so-called "indirect
object" notation.  This syntax was available in Perl 4 long before
objects were introduced, and is still used with filehandles like this:
(TBT)

   print STDERR "help!!!\n";

=begin original

The same syntax can be used to call either object or class methods.

=end original

これと同じ構文を、クラスメソッドやインスタンスメソッドを呼び出すときに
使うことができます。

   my $fred = find Critter "Fred";
   display $fred "Height", "Weight";

=begin original

Notice that there is no comma between the object or class name and the
parameters.  This is how Perl can tell you want an indirect method call
instead of an ordinary subroutine call.

=end original

Notice that there is no comma between the object or class name and the
parameters.  This is how Perl can tell you want an indirect method call
instead of an ordinary subroutine call.
(TBT)

=begin original

But what if there are no arguments?  In that case, Perl must guess what
you want.  Even worse, it must make that guess I<at compile time>.
Usually Perl gets it right, but when it doesn't you get a function
call compiled as a method, or vice versa.  This can introduce subtle bugs
that are hard to detect.

=end original

しかし、引数がなかったら?
この場合、Perl は求められているものを推測しなければなりません。
さらに悪いことに、この推測は B<コンパイル時> に行わなければなりません。
Perl は通常正しい答を得るのですが、そうでなかった場合、あなたはメソッドとして
関数呼び出しがコンパイルされたものを受け取ります。
これは検出が非常に困難なバグとなり得るものです。

=begin original

For example, a call to a method C<new> in indirect notation -- as C++
programmers are wont to make -- can be miscompiled into a subroutine
call if there's already a C<new> function in scope.  You'd end up
calling the current package's C<new> as a subroutine, rather than the
desired class's method.  The compiler tries to cheat by remembering
bareword C<require>s, but the grief when it messes up just isn't worth the
years of debugging it will take you to track down such subtle bugs.

=end original

例を挙げると、(C++ プログラマーがそうしたくなるような)C<new> という
メソッドの間接表記での呼び出しは、カレントのスコープですでに C<new> 関数が
あった場合には間違ったサブルーチン呼び出しにコンパイルされてしまいます。
結果として、望んでいたクラスメソッドではなく、カレントパッケージの
C<new> がサブルーチンとして呼び出されることになるのです。
コンパイラはこの問題を裸の単語の C<require> を覚えておくことによって
避けようと試みますが、それが失敗してしまった場合にはデバッグするのが
とても面倒な結果となってしまうことになるでしょう。

=begin original

There is another problem with this syntax: the indirect object is
limited to a name, a scalar variable, or a block, because it would have
to do too much lookahead otherwise, just like any other postfix
dereference in the language.  (These are the same quirky rules as are
used for the filehandle slot in functions like C<print> and C<printf>.)
This can lead to horribly confusing precedence problems, as in these
next two lines:

=end original

この文法にも問題があります: 間接オブジェクトは名前、スカラ変数、
ブロックに限定されます; なぜなら、他の言語における
postfix dereference と同様に、多すぎる先読みをする必要があるからです
(これらは C<print> や C<printf> のような関数におけるファイルハンドルスロットと
同様な奇妙なルールです)。
これは次に挙げる例のように、混乱した優先順位問題を
導くことになります。

    move $obj->{FIELD};                 # probably wrong!
    move $ary[$i];                      # probably wrong!

=begin original

Those actually parse as the very surprising:

=end original

これらはなんと以下のように解釈されるのです:

    $obj->move->{FIELD};                # Well, lookee here
    $ary->move([$i]);                   # Didn't expect this one, eh?

=begin original

Rather than what you might have expected:

=end original

あなたが期待したのはこうでしょう:

    $obj->{FIELD}->move();              # You should be so lucky.
    $ary[$i]->move;                     # Yeah, sure.

=begin original

To get the correct behavior with indirect object syntax, you would have
to use a block around the indirect object:

=end original

To get the correct behavior with indirect object syntax, you would have
to use a block around the indirect object:
(TBT)

    move {$obj->{FIELD}};
    move {$ary[$i]};

=begin original

Even then, you still have the same potential problem if there happens to
be a function named C<move> in the current package.  B<The C<< -> >>
notation suffers from neither of these disturbing ambiguities, so we
recommend you use it exclusively.>  However, you may still end up having
to read code using the indirect object notation, so it's important to be
familiar with it.

=end original

Even then, you still have the same potential problem if there happens to
be a function named C<move> in the current package.  B<The C<< -> >>
notation suffers from neither of these disturbing ambiguities, so we
recommend you use it exclusively.>  However, you may still end up having
to read code using the indirect object notation, so it's important to be
familiar with it.
(TBT)

=head2 Default UNIVERSAL methods
X<UNIVERSAL>

(デフォルトの UNIVERSAL メソッド)

=begin original

The C<UNIVERSAL> package automatically contains the following methods that
are inherited by all other classes:

=end original

C<UNIVERSAL> パッケージには、他の全てのクラスが自動的に継承する
以下のようなメソッドがあります。

=over 4

=item isa(CLASS)
X<isa>

=begin original

C<isa> returns I<true> if its object is blessed into a subclass of C<CLASS>

=end original

C<isa> は、オブジェクトが C<CLASS> のサブクラスに bless されていれば
I<true> を返します。

=begin original

You can also call C<UNIVERSAL::isa> as a subroutine with two arguments.  Of
course, this will do the wrong thing if someone has overridden C<isa> in a
class, so don't do it.

=end original

You can also call C<UNIVERSAL::isa> as a subroutine with two arguments.  Of
course, this will do the wrong thing if someone has overridden C<isa> in a
class, so don't do it.
(TBT)

=begin original

If you need to determine whether you've received a valid invocant, use the
C<blessed> function from L<Scalar::Util>:
X<invocant> X<blessed>

=end original

If you need to determine whether you've received a valid invocant, use the
C<blessed> function from L<Scalar::Util>:
X<invocant> X<blessed>
(TBT)

    if (blessed($ref) && $ref->isa( 'Some::Class')) {
        # ...
    }

=begin original

C<blessed> returns the name of the package the argument has been
blessed into, or C<undef>.

=end original

C<blessed> は、引数が bless されているパッケージ名か、あるいはC<undef> を
返します。

=item can(METHOD)
X<can>

=begin original

C<can> checks to see if its object has a method called C<METHOD>,
if it does then a reference to the sub is returned, if it does not then
I<undef> is returned.

=end original

C<can> はオブジェクトが C<METHOD> というメソッドを持っているかどうかを検査し、
持っていればそのサブルーチンに対するリファレンスを返し、持っていなければ
I<undef> を返します。

=begin original

C<UNIVERSAL::can> can also be called as a subroutine with two arguments.  It'll
always return I<undef> if its first argument isn't an object or a class name.
The same caveats for calling C<UNIVERSAL::isa> directly apply here, too.

=end original

C<UNIVERSAL::can> can also be called as a subroutine with two arguments.  It'll
always return I<undef> if its first argument isn't an object or a class name.
The same caveats for calling C<UNIVERSAL::isa> directly apply here, too.
(TBT)

=item VERSION( [NEED] )
X<VERSION>

=begin original

C<VERSION> returns the version number of the class (package).  If the
NEED argument is given then it will check that the current version (as
defined by the $VERSION variable in the given package) not less than
NEED; it will die if this is not the case.  This method is normally
called as a class method.  This method is called automatically by the
C<VERSION> form of C<use>.

=end original

C<VERSION> はクラス(パッケージ)のバージョン番号を返します。
引数 NEED が与えられている場合、カレントバージョン(指定されたパッケージ
変数 $VERSION で定義されます)が NEED よりも小さくないことを検査します。
もし小さければ die します。
このメソッドは通常クラスメソッドとして呼び出されます。
また、このメソッドは C<use> の C<VERSION> 形式によって自動的に呼び出されます。

    use A 1.2 qw(some imported subs);
    # implies:
    A->VERSION(1.2);

=back

=begin original

B<NOTE:> C<can> directly uses Perl's internal code for method lookup, and
C<isa> uses a very similar method and cache-ing strategy. This may cause
strange effects if the Perl code dynamically changes @ISA in any package.

=end original

B<注意:> C<can> は Perl の内部コードをメソッドの検索のために使用し、
C<isa>はそれと良く似た手法と、キャッシングを行います。
これにより、@ISA をパッケージの中で動的に変更したりすると、奇妙な影響を
引き起こす可能性があります。

=begin original

You may add other methods to the UNIVERSAL class via Perl or XS code.
You do not need to C<use UNIVERSAL> to make these methods
available to your program (and you should not do so).

=end original

Perl プログラムや XS プログラムを通じて、UNIVERSAL クラスに他のメソッドを
追加することもできます。
追加したメソッドを自作のプログラムで使えるようにするために
C<use UNIVERSAL> を行う必要はありません
(そしてそうするべきではありません)。

=head2 Destructors
X<destructor> X<DESTROY>

(デストラクタ)

=begin original

When the last reference to an object goes away, the object is
automatically destroyed.  (This may even be after you exit, if you've
stored references in global variables.)  If you want to capture control
just before the object is freed, you may define a DESTROY method in
your class.  It will automatically be called at the appropriate moment,
and you can do any extra cleanup you need to do.  Perl passes a reference
to the object under destruction as the first (and only) argument.  Beware
that the reference is a read-only value, and cannot be modified by
manipulating C<$_[0]> within the destructor.  The object itself (i.e.
the thingy the reference points to, namely C<${$_[0]}>, C<@{$_[0]}>, 
C<%{$_[0]}> etc.) is not similarly constrained.

=end original

あるオブジェクトに対する最後のリファレンスが消滅したとき、そのオブジェクトは
自動的に破棄されます(これはあなたがリファレンスを大域変数に格納していて、
プログラムを終了するときでもそうです)。
もしオブジェクトが解放される直前に制御を横取りしたいのであれば、クラスの
中で DESTROY メソッドを定義することができます。
このメソッドは適切な時期に自動的に呼び出され、あなたが必要とする
クリーンアップを行うことができます。
デストラクトされるオブジェクトに対する第一引数(かつ唯一の引数)として
リファレンスを渡します。
このリファレンスは読み込み専用の値であり、デストラクタの中で
C<$_[0]> を操作することによって変更することはできません。
オブジェクトそれ自身(C<${$_[0]}>, C<@{$_[0]}>, C<%{$_[0]}> のような名前の
ついたものに対するリファレンス)は同様に強制されません。

=begin original

Since DESTROY methods can be called at unpredictable times, it is
important that you localise any global variables that the method may
update.  In particular, localise C<$@> if you use C<eval {}> and
localise C<$?> if you use C<system> or backticks.

=end original

Since DESTROY methods can be called at unpredictable times, it is
important that you localise any global variables that the method may
update.  In particular, localise C<$@> if you use C<eval {}> and
localise C<$?> if you use C<system> or backticks.
(TBT)

=begin original

If you arrange to re-bless the reference before the destructor returns,
perl will again call the DESTROY method for the re-blessed object after
the current one returns.  This can be used for clean delegation of
object destruction, or for ensuring that destructors in the base classes
of your choosing get called.  Explicitly calling DESTROY is also possible,
but is usually never needed.

=end original

デストラクタから抜ける前にリファレンスを再 bless するようにアレンジすると、
perl はカレントのデストラクターから呼び出した後で再 bless されたオブジェクトの
ための DESTROY メソッドを再度呼び出します。
これはオブジェクトの委譲を始末するのに使ったり、あなたが呼び出すことを
選択したベースクラスのデストラクターを保証するのに使うことができます。
陽に DESTROY を呼び出すことも可能ですが、通常はそうする必要はありません。

=begin original

Do not confuse the previous discussion with how objects I<CONTAINED> in the current
one are destroyed.  Such objects will be freed and destroyed automatically
when the current object is freed, provided no other references to them exist
elsewhere.

=end original

カレントで破棄されるオブジェクトに属するオブジェクトに関して
混乱しないようにしてください。
そのようなオブジェクトはカレントオブジェクトが解放されるときに自動的に
解放・破棄が行われ、他のなにものに対するリファレンスがないようにします。

=head2 Summary

(まとめ)

=begin original

That's about all there is to it.  Now you need just to go off and buy a
book about object-oriented design methodology, and bang your forehead
with it for the next six months or so.

=end original

これで、ここでなすべきことは全て終わりました。
今、あなたは部屋を出てオブジェクト指向方法論に関する書籍を購入して、
そして六ヶ月かそこらの間悩む必要があるでしょう。

=head2 Two-Phased Garbage Collection
X<garbage collection> X<GC> X<circular reference>
X<reference, circular> X<DESTROY> X<destructor>

(2 フェーズガベージコレクション)

=begin original

For most purposes, Perl uses a fast and simple, reference-based
garbage collection system.  That means there's an extra
dereference going on at some level, so if you haven't built
your Perl executable using your C compiler's C<-O> flag, performance
will suffer.  If you I<have> built Perl with C<cc -O>, then this
probably won't matter.

=end original

ほとんどの目的のために、Perl は単純かつ高速なリファレンスベースの
ガベージコレクションシステムを使用します。
このため、幾つかの段階において余計なデリファレンスが起こり、使用している Perl を
ビルドするときに C<-O> フラグをコンパイラに使っていなければ、性能が劣化します。
Perl をビルドするときに C<cc -O> を使っていれば、このデリファレンスは問題とは
ならないでしょう。

=begin original

A more serious concern is that unreachable memory with a non-zero
reference count will not normally get freed.  Therefore, this is a bad
idea:

=end original

より深刻な問題は、ゼロでないリファレンスカウントを持っている
アクセスできないメモリー(unreachable memory)が通常は
解放されないということです。
したがって、以下のようにすることは悪いアイデアです。

    {
	my $a;
	$a = \$a;
    }

=begin original

Even thought $a I<should> go away, it can't.  When building recursive data
structures, you'll have to break the self-reference yourself explicitly
if you don't care to leak.  For example, here's a self-referential
node such as one might use in a sophisticated tree structure:

=end original

$a が無くなるように思えるのですが、できないのです。
再帰的データ構造を構築したとき、メモリリークを気にしないためには自分自身で、
明示的に、自己参照を壊さなければなりません。
たとえば、木構造を扱うときに使うような自己参照構造体として以下のようなものを
考えてみます。

    sub new_node {
	my $class = shift;
	my $node  = {};
	$node->{LEFT} = $node->{RIGHT} = $node;
	$node->{DATA} = [ @_ ];
	return bless $node => $class;
    }

=begin original

If you create nodes like that, they (currently) won't go away unless you
break their self reference yourself.  (In other words, this is not to be
construed as a feature, and you shouldn't depend on it.)

=end original

このようなノードを生成するとき、あなた自身が自分で自己参照を壊さない
限りノードはなくなりません(言い換えれば、これは仕様として
解釈されるものではなく、これに依存すべきではないということです)。

=begin original

Almost.

=end original

もう一息。

=begin original

When an interpreter thread finally shuts down (usually when your program
exits), then a rather costly but complete mark-and-sweep style of garbage
collection is performed, and everything allocated by that thread gets
destroyed.  This is essential to support Perl as an embedded or a
multithreadable language.  For example, this program demonstrates Perl's
two-phased garbage collection:

=end original

インタプリタのスレッドが最終的にシャットダウンするとき(通常は
プログラムを終了するとき)、コストが掛かりますが、完全な
mark-and-sweep 形式のガベージコレクションが実行されます。
そして、(シャットダウンされる)スレッドによって割り当てられたすべての
ものは破棄されます。
これはPerlを組み込みに使えるようにしたり、マルチスレッドに対応できる言語と
するために重要なことです。
たとえば以下のプログラムは Perl の 2 フェーズガベージコレクションを
デモンストレーションします。

    #!/usr/bin/perl
    package Subtle;

    sub new {
	my $test;
	$test = \$test;
	warn "CREATING " . \$test;
	return bless \$test;
    }

    sub DESTROY {
	my $self = shift;
	warn "DESTROYING $self";
    }

    package main;

    warn "starting program";
    {
	my $a = Subtle->new;
	my $b = Subtle->new;
	$$a = 0;  # break selfref
	warn "leaving block";
    }

    warn "just exited block";
    warn "time to die...";
    exit;

=begin original

When run as F</foo/test>, the following output is produced:

=end original

F</foo/test> として実行したとき、以下のような出力をします。

    starting program at /foo/test line 18.
    CREATING SCALAR(0x8e5b8) at /foo/test line 7.
    CREATING SCALAR(0x8e57c) at /foo/test line 7.
    leaving block at /foo/test line 23.
    DESTROYING Subtle=SCALAR(0x8e5b8) at /foo/test line 13.
    just exited block at /foo/test line 26.
    time to die... at /foo/test line 27.
    DESTROYING Subtle=SCALAR(0x8e57c) during global destruction.

=begin original

Notice that "global destruction" bit there?  That's the thread
garbage collector reaching the unreachable.

=end original

"global destruction" がどこにあるかわかりますか? これは、スレッド
ガベージコレクタがアクセスできないオブジェクトに到達したということです。

=begin original

Objects are always destructed, even when regular refs aren't.  Objects
are destructed in a separate pass before ordinary refs just to 
prevent object destructors from using refs that have been themselves
destructed.  Plain refs are only garbage-collected if the destruct level
is greater than 0.  You can test the higher levels of global destruction
by setting the PERL_DESTRUCT_LEVEL environment variable, presuming
C<-DDEBUGGING> was enabled during perl build time.
See L<perlhack/PERL_DESTRUCT_LEVEL> for more information.

=end original

オブジェクトは常に破棄されます。
一般のリファレンス(regulaer refs)が破棄されなかった場合でもそうですし、
一般のリファレンスが分割されたパスで破棄された場合でさえ、
通常のリファレンス(ordinary refs)がオブジェクトデストラクターが自分自身を
破棄してしまったリファレンスを使うのを防ごうとする前に破棄されます。
plain なリファレンスは、そのデストラクトレベルが 0 以上であるときには
ガベージコレクションのみ行なわれます。
Perl をビルドするときに C<-DDEBUGGING> が有効になっていれば、
PERL_DESTRUCT_LEVEL という環境変数に対する設定をすることによって、
グローバルデストラクションのレベルを検査することができます。
さらなる情報については L<perlhack/PERL_DESTRUCT_LEVEL> を参照してください。

=begin original

A more complete garbage collection strategy will be implemented
at a future date.

=end original

より完璧なガーベッジコレクションの戦略は将来実装されるでしょう。

=begin original

In the meantime, the best solution is to create a non-recursive container
class that holds a pointer to the self-referential data structure.
Define a DESTROY method for the containing object's class that manually
breaks the circularities in the self-referential structure.

=end original

方法として最善なものは、自己再帰的なデータ構造に対するポインタを
保持するような非再帰的なコンテナークラスを作成することです。
そういったオブジェクトのクラスでの DESTORY メソッドの定義は
自己参照構造中の循環を手作業で断ち切るようなものになります。

=head1 SEE ALSO

=begin original

A kinder, gentler tutorial on object-oriented programming in Perl can
be found in L<perltoot>, L<perlboot> and L<perltooc>.  You should
also check out L<perlbot> for other object tricks, traps, and tips, as
well as L<perlmodlib> for some style guides on constructing both
modules and classes.

=end original

Perl におけるオブジェクト指向プログラムに関するより親切で丁寧な
チュートリアルは L<perltoot>, L<perlboot>, L<perltooc> にあります。
また、その他のオブジェクトの罠や小技については L<perlbot> を、
モジュールとクラスの作成に関するスタイルガイドについては L<perlmodlib> を
参照してください。

=begin meta

Created: KIMURA Koichi
Updated: Kentaro Shirakata <argrath@ub32.org>

=end meta

