
=encoding utf-8

=head1 NAME

=begin original

perlstyle - Perl style guide

=end original

perlstyle - Perl 스타일 가이드

=head1 DESCRIPTION

=begin original

Each programmer will, of course, have his or her own preferences in
regards to formatting, but there are some general guidelines that will
make your programs easier to read, understand, and maintain.

=end original

프로그래머는 물론 사람마다 좋아하는 포맷이 있을 겁니다.
그러나 몇 가지의 가이드라인에 따르는 것에 의해 프로그램의 가독성이나 
보수성을 높일 수 있습니다.

=begin original

The most important thing is to run your programs under the B<-w>
flag at all times.  You may turn it off explicitly for particular
portions of code via the C<no warnings> pragma or the C<$^W> variable
if you must.  You should also always run under C<use strict> or know the
reason why not.  The C<use sigtrap> and even C<use diagnostics> pragmas
may also prove useful.

=end original

더욱 중요한 것은 항상 프로그램을 B<-w> 플래그를 붙여서 움직이는 것입니다.
필요하다면 C<no warnings> 프라그마나 C<$^W> 변수를 사용해서 코의 
일부만으로 경고를 명시적으로 끌 수 있습니다.
또, 항상 C<use strict> 를 사용해야 합니다.
만약  C<use strict> 를 사용하지 않으면 그 이유를 충분히 이해해두어야 합니다.
C<use sigtrap> 이나 C<use diagnostics> 프라그마도 편리합니다.

=begin original

Regarding aesthetics of code lay out, about the only thing Larry
cares strongly about is that the closing curly bracket of
a multi-line BLOCK should line up with the keyword that started the construct.
Beyond that, he has other preferences that aren't so strong:

=end original

코드레이아웃의 미관에 관해서는 Larry 가 강하게 주의를 기울이는 단 하나,
여러줄의 BLOCK을 닫는 중괄호는 그 구조를 개시한 키워드와 같은 위치에 
없어서는 안된다는 것 뿐입니다.
그것은 별도로 하고, 그렇게 강하지 않은 그의 취향은 아래와 같습니다.

=over 4

=item *

=begin original

4-column indent.

=end original

4 칼럼의 인덴트.

=item *

=begin original

Opening curly on same line as keyword, if possible, otherwise line up.

=end original

가능하다면, 시작 중괄호와 키워드를 같은 줄에.
그렇지 않으면 시작을 같은 줄에.

=item *

=begin original

Space before the opening curly of a multi-line BLOCK.

=end original

여러줄의 BLOCK 의 시작 중괄호 앞에 스페이스.

=item *

=begin original

One-line BLOCK may be put on one line, including curlies.

=end original

1 줄의 BLOCK 은 중괄호도 포함해서 1줄로.

=item *

=begin original

No space before the semicolon.

=end original

세미콜론의 앞에 공백앞음.

=item *

=begin original

Semicolon omitted in "short" one-line BLOCK.

=end original

"짧은" 1줄의 블록에서는 세미콜론을 생략.

=item *

=begin original

Space around most operators.

=end original

대부분의 연산자의 앞뒤에 스페이스.

=item *

=begin original

Space around a "complex" subscript (inside brackets).

=end original

"복잡한" 대입(브라켓 안)의 앞뒤에는 스페이스.

=item *

=begin original

Blank lines between chunks that do different things.

=end original

다른 일을 하는 청크의 사이에는 빈 줄.

=item *

=begin original

Uncuddled elses.

=end original

else 를 붙이지 않는다.

=item *

=begin original

No space between function name and its opening parenthesis.

=end original

함수이름과 시작 괄호의 사이에는 스페이스 없음.

=item *

=begin original

Space after each comma.

=end original

콤마의 뒤에는 스페이스.

=item *

=begin original

Long lines broken after an operator (except C<and> and C<or>).

=end original

긴 줄은 연산자의 뒤에서 줄바꿈한다(C<and> 와 C<or> 를 빼고).

=item *

=begin original

Space after last parenthesis matching on current line.

=end original

줄의 마지막의 괄호의 뒤에 스페이스.

=item *

=begin original

Line up corresponding items vertically.

=end original

대응하는 요소의 시작위치를 세운다.

=item *

=begin original

Omit redundant punctuation as long as clarity doesn't suffer.

=end original

장황한 표현은 이해하기 어렵지 않는 한 생략.

=back

=begin original

Larry has his reasons for each of these things, but he doesn't claim that
everyone else's mind works the same as his does.

=end original

Larry 에게는 이것들 각각을 선호하는 이유가 있습니다만, 그 이외의 사람이 
이것과 완전 같을 필요는 없다고 말합니다.

=begin original

Here are some other more substantive style issues to think about:

=end original

다른 보다 중요한 스타일의 문제가 있습니다:

=over 4

=item *

=begin original

Just because you I<CAN> do something a particular way doesn't mean that
you I<SHOULD> do it that way.  Perl is designed to give you several
ways to do anything, so consider picking the most readable one.  For
instance

=end original

뭔가를 어떤 방법으로 I<할수있다>고 해서 그렇게 I<해야하는> 것은 아닙니다.
Perl 은 하나의 일을 여러가지 방법으로 할 수 있도록 설계되어 있기 때문에,
보다 자세히 예를 들면.

    open(FOO,$foo) || die "Can't open $foo: $!";

=begin original

is better than

=end original

이라는 것은 아래처럼 해도 됩니다.

    die "Can't open $foo: $!" unless open(FOO,$foo);

=begin original

because the second way hides the main point of the statement in a
modifier.  On the other hand

=end original

왜냐면 2번째줄에서는 이 구문의 주요부분이 수식자에 숨어버리기 때문입니다.
거꾸로,

    print "Starting analysis\n" if $verbose;

=begin original

is better than

=end original

라는 것은 아래보다 좋습니다:

    $verbose && print "Starting analysis\n";

=begin original

because the main point isn't whether the user typed B<-v> or not.

=end original

이 구문의 주요부분은 유저가 B<-v> 를 타이핑했느냐 어쨌느냐가 아니기 때문입니다.

=begin original

Similarly, just because an operator lets you assume default arguments
doesn't mean that you have to make use of the defaults.  The defaults
are there for lazy systems programmers writing one-shot programs.  If
you want your program to be readable, consider supplying the argument.

=end original

이처럼 어떤 연산자가 기본 인수를 상정하고 있다고 해서, 그 기본값을 
사용하지 않는 것은 아닙니.
이 기본값이 있는 것은 게으른 시스템 프로그래머가 한방의 프로그램을 
쓰기 위해 있습니다.
프로그램을 읽기 쉽게하기에는 인수를 생략하지 않도록 합시다.

=begin original

Along the same lines, just because you I<CAN> omit parentheses in many
places doesn't mean that you ought to:

=end original

이처럼 많은 장소에서 괄호를 생략 I<할 수 있습니다>만, 아래처럼 
너무 생략하는 것은 의미하는 바를 모르게 됩니다.

    return print reverse sort num values %array;
    return print(reverse(sort num (values(%array))));

=begin original

When in doubt, parenthesize.  At the very least it will let some poor
schmuck bounce on the % key in B<vi>.

=end original

의심스러울 때는 괄호를 써 주세요.
적어도, 잘못된 부분은 B<vi> 의 % 키로 하이라이트할 수 있습니다.

=begin original

Even if you aren't in doubt, consider the mental welfare of the person
who has to maintain the code after you, and who will probably put
parentheses in the wrong place.

=end original

의심이 들지 않을 때도 나중에 그 코드를 유지보수하는 사람의 생활을 생각해주세요.
잘못된 부분에 괄호를 넣어버릴지도 모릅니다.

=item *

=begin original

Don't go through silly contortions to exit a loop at the top or the
bottom, when Perl provides the C<last> operator so you can exit in
the middle.  Just "outdent" it a little to make it more visible:

=end original

ループの先頭や末尾で抜け出すのに、ばかげたコードをかかないでください。
Perl には C<last> 演算子があるので、途中で抜け出すことができます。
ちょっとだけ読みやすくするには "アウトデント" します:

    LINE:
	for (;;) {
	    statements;
	  last LINE if $foo;
	    next LINE if /^#/;
	    statements;
	}

=item *

=begin original

Don't be afraid to use loop labels--they're there to enhance
readability as well as to allow multilevel loop breaks.  See the
previous example.

=end original

ループのラベルは積極的に使いましょう -- 可読性をあげるのと共に、多段階の
ループ抜け出しもできるようになります。
先ほどの例を見てください。

=item *

=begin original

Avoid using C<grep()> (or C<map()>) or `backticks` in a void context, that is,
when you just throw away their return values.  Those functions all
have return values, so use them.  Otherwise use a C<foreach()> loop or
the C<system()> function instead.

=end original

C<grep()> (や C<map()>)、また `逆クォート` を無効コンテキスト、つまり
返り値を無視する文で使用しないでください。
これらの関数はすべて返り値を持っていますから、それを使用してください。
いらないのであれば、C<foreach()> ループや C<system()> 関数を
使用してください。

=item *

=begin original

For portability, when using features that may not be implemented on
every machine, test the construct in an eval to see if it fails.  If
you know what version or patchlevel a particular feature was
implemented, you can test C<$]> (C<$PERL_VERSION> in C<English>) to see if it
will be there.  The C<Config> module will also let you interrogate values
determined by the B<Configure> program when Perl was installed.

=end original

ポータビリティのために、すべてのマシンで実装されていないかもしれない機能を
使用する際は、それを eval で囲って、失敗するかどうかチェックしてください。
ある機能が、どのバージョンやパッチレベルで実装されているか知っている
場合には、C<$]> (C<English> モジュールでは、C<$PERL_VERSION>) を
チェックすることもできます。
C<Config> モジュールを使えば、Perl インストール時の C<Configure> プログラムに
よって決定された値を調べることができます。

=item *

=begin original

Choose mnemonic identifiers.  If you can't remember what mnemonic means,
you've got a problem.

=end original

ニーモニックな識別子を選んでください。
そのニーモニックが何を意味するか思い出せなければ、問題です。

=item *

=begin original

While short identifiers like C<$gotit> are probably ok, use underscores to
separate words in longer identifiers.  It is generally easier to read
C<$var_names_like_this> than C<$VarNamesLikeThis>, especially for
non-native speakers of English. It's also a simple rule that works
consistently with C<VAR_NAMES_LIKE_THIS>.

=end original

C<$gotit> のような短い識別子なら ok ですが、 in longer identifiers 単語を
区切るにはアンダースコアを使用してください。
一般的には、とくに英語のネイティブスピーカーでない人にとっては、C<$var_names_like_this> の方が C<$VarNamesLikeThis> より読みやすいです。
このルールは C<VAR_NAMES_LIKE_THIS> についても同様に当てはまります。
(TBT)

=begin original

Package names are sometimes an exception to this rule.  Perl informally
reserves lowercase module names for "pragma" modules like C<integer> and
C<strict>.  Other modules should begin with a capital letter and use mixed
case, but probably without underscores due to limitations in primitive
file systems' representations of module names as files that must fit into a
few sparse bytes.

=end original

パッケージ名は、このルールの例外になることがあります。
Perl は小文字のモジュール名を、C<integer> や C<strict> のような"プラグマ"
モジュールのために予約しています。
その他のモジュールは大文字からはじめて、小文字を混ぜて使用すべきですが、
アンダースコアは使用しません。
プリミティブなファイルシステムでは、モジュール名をファイルとして
表現する際に、バイト数の制限があるためです。

=item *

=begin original

You may find it helpful to use letter case to indicate the scope
or nature of a variable. For example:

=end original

変数のスコープや性質を表現するのに、大文字小文字を使うと便利でしょう。
たとえば:

=begin original

    $ALL_CAPS_HERE   constants only (beware clashes with perl vars!)
    $Some_Caps_Here  package-wide global/static
    $no_caps_here    function scope my() or local() variables

=end original

    $ALL_CAPS_HERE   定数のみ (perl 変数との衝突に注意!)
    $Some_Caps_Here  パッケージワイドなグローバル/スタティック変数
    $no_caps_here    関数スコープの my(),local()変数

=begin original

Function and method names seem to work best as all lowercase.
E.g., C<$obj-E<gt>as_string()>.

=end original

関数とメソッドの名前はすべて小文字だとベストです。
例えば、C<$obj-E<gt>as_string()>。

=begin original

You can use a leading underscore to indicate that a variable or
function should not be used outside the package that defined it.

=end original

先頭にアンダースコアをつけることによって、変数や関数を定義したパッケージ外で
使用すべきでないことを命じすることができます。

=item *

=begin original

If you have a really hairy regular expression, use the C</x> modifier and
put in some whitespace to make it look a little less like line noise.
Don't use slash as a delimiter when your regexp has slashes or backslashes.

=end original

ほんとにごちゃごちゃな正規表現を使う場合には、C</x> 修飾子を使用して
スペースをいれ、ごみみたいにならないようにしてください。
正規表現内にスラッシュやバックスラッシュがあるときには、デリミタに
スラッシュを使わないように。

=item *

=begin original

Use the new C<and> and C<or> operators to avoid having to parenthesize
list operators so much, and to reduce the incidence of punctuation
operators like C<&&> and C<||>.  Call your subroutines as if they were
functions or list operators to avoid excessive ampersands and parentheses.

=end original

新しい C<and> と C<or> 演算子を使用し、リスト演算子のカッコがたくさんに
なったり、C<&&> や C<||> が大量発生するのを避けてください。
サブルーチンは、関数やリスト演算子であるかのように扱い、アンパサンドや
カッコが大量発生するのを避けてください。

=item *

=begin original

Use here documents instead of repeated C<print()> statements.

=end original

C<print()> 文を繰り返さず、ヒアドキュメントを使用してください。

=item *

=begin original

Line up corresponding things vertically, especially if it'd be too long
to fit on one line anyway.

=end original

対応するものの開始位置はそろえてください、とくに、1行におさまらないものに
関して。

    $IDX = $ST_MTIME;
    $IDX = $ST_ATIME 	   if $opt_u;
    $IDX = $ST_CTIME 	   if $opt_c;
    $IDX = $ST_SIZE  	   if $opt_s;

    mkdir $tmpdir, 0700	or die "can't mkdir $tmpdir: $!";
    chdir($tmpdir)      or die "can't chdir $tmpdir: $!";
    mkdir 'tmp',   0777	or die "can't mkdir $tmpdir/tmp: $!";

=item *

=begin original

Always check the return codes of system calls.  Good error messages should
go to C<STDERR>, include which program caused the problem, what the failed
system call and arguments were, and (VERY IMPORTANT) should contain the
standard system error message for what went wrong.  Here's a simple but
sufficient example:

=end original

システムコールの返りコードはつねにチェックしてください。
良いエラーメッセージは C<STDERR> に書き出され、問題を発生させた
プログラム名や、失敗したシステムコールと引数、そして(とても重要)標準
システムエラーメッセージを含むべきです。
以下はシンプルですが、十分な例です:

    opendir(D, $dir)	 or die "can't opendir $dir: $!";

=item *

=begin original

Line up your transliterations when it makes sense:

=end original

見やすくなる場合には、tr の開始位置をそろえてください。

    tr [abc]
       [xyz];

=item *

=begin original

Think about reusability.  Why waste brainpower on a one-shot when you
might want to do something like it again?  Consider generalizing your
code.  Consider writing a module or object class.  Consider making your
code run cleanly with C<use strict> and C<use warnings> (or B<-w>) in
effect.  Consider giving away your code.  Consider changing your whole
world view.  Consider... oh, never mind.

=end original

再利用性を考慮しましょう。
同じことをあとでやるかもしれないときに、脳の力を一発のプログラムで
無駄にする必要はありますか?
コードの一般化を考慮し、モジュールやオブジェクトクラスを書くことを
考慮しましょう。
コードが C<use strict> と C<use warnings> (あるいは B<-w>) が有効でも
きちんと動くか考慮しましょう。
コードを捨て去ることも考慮しましょう。
世界の見方を変えることを考慮しましょう。
他にも……ああ、もういいや。

=item *

=begin original

Try to document your code and use Pod formatting in a consistent way. Here
are commonly expected conventions:

=end original

Try to document your code and use Pod formatting in a consistent way. Here
are commonly expected conventions:
(TBT)

=over 4

=item *

=begin original

use C<CE<lt>E<gt>> for function, variable and module names (and more
generally anything that can be considered part of code, like filehandles
or specific values). Note that function names are considered more readable
with parentheses after their name, that is C<function()>.

=end original

use C<CE<lt>E<gt>> for function, variable and module names (and more
generally anything that can be considered part of code, like filehandles
or specific values). Note that function names are considered more readable
with parentheses after their name, that is C<function()>.
(TBT)

=item *

=begin original

use C<BE<lt>E<gt>> for commands names like B<cat> or B<grep>.

=end original

use C<BE<lt>E<gt>> for commands names like B<cat> or B<grep>.
(TBT)

=item *

=begin original

use C<FE<lt>E<gt>> or C<CE<lt>E<gt>> for file names. C<FE<lt>E<gt>> should
be the only Pod code for file names, but as most Pod formatters render it
as italic, Unix and Windows paths with their slashes and backslashes may
be less readable, and better rendered with C<CE<lt>E<gt>>.

=end original

use C<FE<lt>E<gt>> or C<CE<lt>E<gt>> for file names. C<FE<lt>E<gt>> should
be the only Pod code for file names, but as most Pod formatters render it
as italic, Unix and Windows paths with their slashes and backslashes may
be less readable, and better rendered with C<CE<lt>E<gt>>.
(TBT)

=back

=item *

=begin original

Be consistent.

=end original

つねに一貫性を。

=item *

=begin original

Be nice.

=end original

つねに素敵に。

=back

