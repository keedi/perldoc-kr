
=encoding UTF-8

=head1 NAME
X<operator>

=begin original

perlop - Perl operators and precedence

=end original

perlop - Perl“ÀÇ “¿¬“»ê“ÀÚ“¿Í “¿ì“¼±“¼ø“À§

=head1 DESCRIPTION

=head2 Operator Precedence and Associativity
X<operator, precedence> X<precedence> X<associativity>

(“¿¬“»ê“ÀÚ“ÀÇ “¿ì“¼±“¼ø“À§“¿Í “°á“ÇÕ“¼º)

=begin original

Operator precedence and associativity work in Perl more or less like
they do in mathematics.

=end original

Perl “¿¡“¼­“ÀÇ “¿¬“»ê“ÀÚ“ÀÇ “¿ì“¼±“¼ø“À§“¿Í “°á“ÇÕ“¼º“Àº “Àû“ÀÝ“Àº “ºÎ“ºÐ“¿¡“¼­ “¼ö“ÇÐ“°ú “ºñ“½Á“ÇÕ“´Ï“´Ù.

=begin original

I<Operator precedence> means some operators are evaluated before
others.  For example, in C<2 + 4 * 5>, the multiplication has higher
precedence so C<4 * 5> is evaluated first yielding C<2 + 20 ==
22> and not C<6 * 5 == 30>.

=end original

I<“¿¬“»ê“ÀÚ“¿Í “¿ì“¼±“¼ø“À§> “¶ó“´Â “°Í“Àº “´Ù“¸¥ “¿¬“»ê“ÀÚ“º¸“´Ù 
“¸Õ“Àú “Æò“°¡“¹Þ“´Â “¿¬“»ê“ÀÚ“°¡ “ÀÖ“´Ù“´Â “°Í“ÀÔ“´Ï“´Ù.
“¿¹“¸¦“µé“¸é, C<2 + 4 * 5>“ÀÇ “°æ“¿ì “°ö“¼À“ÀÌ “³ô“Àº “¿ì“¼±“¼ø“À§“¸¦ “°¡“Áö“°í“ÀÖ“±â “¶§“¹®“¿¡
C<4 * 5>“ÀÌ “¸Õ“Àú “Æò“°¡“¹Þ“°í “°á“°ú“´Â C<6 * 5 == 30> “ÀÌ “¾Æ“´Ñ
C<2 + 20 == 22> “ÀÌ “µË“´Ï“´Ù.

=begin original

I<Operator associativity> defines what happens if a sequence of the
same operators is used one after another: whether the evaluator will
evaluate the left operations first or the right.  For example, in C<8
- 4 - 2>, subtraction is left associative so Perl evaluates the
expression left to right.  C<8 - 4> is evaluated first making the
expression C<4 - 2 == 2> and not C<8 - 2 == 6>.

=end original

I<“¿¬“»ê“ÀÚ“ÀÇ “°á“ÇÕ“¼º> “Àº “°°“Àº “¿¬“»ê“ÀÚ“°¡ “¿¬“¼Ó“ÇØ“¼­ “³ª“Å¸“³¯ “°æ“¿ì“¿¡ 
“¹«“¾ù“ÀÌ “ÀÏ“¾î“³¯“Áö“¸¦ “Á¤“ÀÇ“ÇÕ“´Ï“´Ù. 
: “¿¬“»ê“±â“°¡ “ÁÂ“Ãø“À» “¸Õ“Àú “Æò“°¡“ÇÒ “°Í“ÀÎ“°¡ “¿ì“Ãø“À» “¸Õ“Àú “Æò“°¡“ÇÒ “°Í“ÀÎ“°¡ “ÇÏ“´Â “°Í“ÀÔ“´Ï“´Ù.
“¿¹“¸¦“µé“¸é, C<8 - 4 - 2>“ÀÇ “°æ“¿ì “»©“±â“´Â “¿Þ“ÂÊ“°á“ÇÕ“ÀÌ“±â“¿¡ 
“ÆÞ“Àº “°è“»ê“½Ä“À» “¿Þ“ÂÊ“¿¡“¼­ “¿À“¸¥“ÂÊ“À¸“·Î “Æò“°¡“ÇÕ“´Ï“´Ù.
C<8 - 4>“ÀÌ “¸Õ“Àú “Æò“°¡“µÇ“±â“¶§“¹®“¿¡ C<8 - 2 = 6>“ÀÌ “¾Æ“´Ñ
C<4 - 2 == 2> “ÀÌ “µË“´Ï“´Ù.

=begin original

Perl operators have the following associativity and precedence,
listed from highest precedence to lowest.  Operators borrowed from
C keep the same precedence relationship with each other, even where
C's precedence is slightly screwy.  (This makes learning Perl easier
for C folks.)  With very few exceptions, these all operate on scalar
values only, not array values.

=end original

Perl “ÀÇ “¿¬“»ê“ÀÚ“¿¡“´Â “¾Æ“·¡“¿Í“°°“Àº “°á“ÇÕ“¼º“°ú “¿ì“¼±“¼ø“À§
(“³ô“Àº “¿ì“¼±“¼ø“À§“ºÎ“ÅÍ “³·“Àº “¿ì“¼±“¼ø“À§)“°¡ “ÀÖ“½À“´Ï“´Ù.
C “·Î“ºÎ“ÅÍ “°¡“Á®“¿Â “¿¬“»ê“ÀÚ“ÀÇ “¿ì“¼±“¼ø“À§“´Â C “¿¡“¼­“ÀÇ “¿ì“¼±“¼ø“À§“°¡ “´Ù“¼Ò “ÀÌ“»ó“ÇØ“µµ, 
“±×“´ë“·Î “Â÷“¿ë“ÇÏ“°í “ÀÖ“½À“´Ï“´Ù.
(“ÀÌ“°Í“Àº C “¸¦ “»ç“¿ë“ÇØ“º¸“½Å “ºÐ“ÀÌ Perl “¿¡ “Àû“ÀÀ“ÇÏ“±â “½±“°Ô “µÇ“¾î“ÀÖ“½À“´Ï“´Ù.)
“¸î “¾È“µÇ“´Â “°Í“À» “»©“¸é “¸ð“µç “¿¬“»ê“ÀÚ“´Â “½º“Ä®“¶ó“°ª“¸¸ “°¡“Áö“°í, “¹è“¿­“°ª“À» “°¡“Áö“Áö “¾Ê“½À“´Ï“´Ù.

=begin original

    left	terms and list operators (leftward)
    left	->
    nonassoc	++ --
    right	**
    right	! ~ \ and unary + and -
    left	=~ !~
    left	* / % x
    left	+ - .
    left	<< >>
    nonassoc	named unary operators
    nonassoc	< > <= >= lt gt le ge
    nonassoc	== != <=> eq ne cmp ~~
    left	&
    left	| ^
    left	&&
    left	|| //
    nonassoc	..  ...
    right	?:
    right	= += -= *= etc.
    left	, =>
    nonassoc	list operators (rightward)
    right	not
    left	and
    left	or xor

=end original

    “¿Þ“ÂÊ“°á“ÇÕ    “Ç×“¸ñ “¸®“½º“Æ®“¿¬“»ê“ÀÚ (“¿Þ“ÂÊ“¿¡ “´ë“ÇØ“¼­) 
    “¿Þ“ÂÊ“°á“ÇÕ    ->
    “°á“ÇÕ“¾È“ÇÔ“¡¡“¡¡++ --
    “¿À“¸¥“ÂÊ“°á“ÇÕ  **
    “¿À“¸¥“ÂÊ“°á“ÇÕ  ! ~ \ “´Ü“Ç×“ÀÇ+ “´Ü“Ç×“ÀÇ-
    “¿Þ“ÂÊ“°á“ÇÕ    =~ !~
    “¿Þ“ÂÊ“°á“ÇÕ    * / % x
    “¿Þ“ÂÊ“°á“ÇÕ    + - .
    “¿Þ“ÂÊ“°á“ÇÕ    << >>
    “°á“ÇÕ“¾È“ÇÔ    “ÀÌ“¸§“ºÙ“Àº“´Ü“Ç×“¿¬“»ê“ÀÚ
    “°á“ÇÕ“¾È“ÇÔ    < > <= >= lt gt le ge
    “°á“ÇÕ“¾È“ÇÔ    == != <=> eq ne cmp ~~
    “¿Þ“ÂÊ“°á“ÇÕ    &
    “¿Þ“ÂÊ“°á“ÇÕ    | ^
    “¿Þ“ÂÊ“°á“ÇÕ    &&
    “¿Þ“ÂÊ“°á“ÇÕ    || //
    “°á“ÇÕ“¾È“ÇÔ    .. ...
    “¿À“¸¥“ÂÊ“°á“ÇÕ  ?:
    “¿À“¸¥“ÂÊ“°á“ÇÕ  = += -= *= “µî“ÀÇ “´ë“ÀÔ“¿¬“»ê“ÀÚ
    “¿Þ“ÂÊ“°á“ÇÕ    , =>
    “°á“ÇÕ“¾È“ÇÔ    “¸®“½º“Æ® “¿¬“»ê“ÀÚ (“¿À“¸¥“ÂÊ“¿¡ “´ë“ÇØ“¼­)
    “¿À“¸¥“ÂÊ“°á“ÇÕ  not
    “¿Þ“ÂÊ“°á“ÇÕ    and
    “¿Þ“ÂÊ“°á“ÇÕ    or xor

=begin original

In the following sections, these operators are covered in precedence order.

=end original

=end original

=begin original

Many operators can be overloaded for objects.  See L<overload>.

=end original

“´ë“ºÎ“ºÐ“ÀÇ “¿¬“»ê“ÀÚ“´Â “¿À“ºê“Á§“Æ®“·Î “¿À“¹ö“·Î“µå“°¡ “°¡“´É“ÇÕ“´Ï“´Ù.
L<overload> “¸¦ “Âü“Á¶“ÇÏ“¼¼“¿ä“¡£

=head2 Terms and List Operators (Leftward)
X<list operator> X<operator, list> X<term>

(“Ç×“°ú “¸®“½º“Æ® “¿¬“»ê“ÀÚ (“¿Þ“ÂÊ “¹æ“Çâ))

=begin original

A TERM has the highest precedence in Perl.  They include variables,
quote and quote-like operators, any expression in parentheses,
and any function whose arguments are parenthesized.  Actually, there
aren't really functions in this sense, just list operators and unary
operators behaving as functions because you put parentheses around
the arguments.  These are all documented in L<perlfunc>.

=end original

“¡¸“Ç×“¡¹“Àº Perl “¿¡“¼­ “°¡“Àå “¿ì“¼±“¼ø“À§“°¡ “³ô“Àº “³à“¼®“ÀÔ“´Ï“´Ù.
“¿©“±â“¿¡“´Â “º¯“¼ö, Quote“¿Í Quote“°°“Àº “¿¬“»ê“ÀÚ, “°ý“È£“·Î “°¨“½Ñ “ÀÓ“ÀÇ“ÀÇ“½Ä 
“ÀÎ“¼ö“¸¦ “°ý“È£“·Î “°¨“½Ñ “ÀÓ“ÀÇ“ÀÇ“ÇÔ“¼ö“°¡ “Æ÷“ÇÔ“µË“´Ï“´Ù.
“½Ç“Á¦“·Î“´Â “ÀÌ “ÀÇ“¹Ì“·Î “Áø“Â¥ “ÇÔ“¼ö“°¡ “¾Æ“´Ñ “¸®“½º“Æ® “¿¬“»ê“ÀÚ“¿Í “ÇÔ“¼ö“°°“ÀÌ “¿ò“Á÷“ÀÌ“´Â
“´Ü“Ç×“¿¬“»ê“ÀÚ“°¡ “ÀÎ“¼ö“¸¦ “°ý“È£“·Î “°¨“½Î“±â“¶§“¹®“¿¡ “±×“·¸“°Ô “º¸“ÀÔ“´Ï“´Ù.
“ÀÌ“°Í“¿¡ “´ë“ÇØ“¼­“´Â L<perlfunc>“¿¡ “±â“¼ú“ÇÏ“°í “ÀÖ“½À“´Ï“´Ù.

=begin original

If any list operator (print(), etc.) or any unary operator (chdir(), etc.)
is followed by a left parenthesis as the next token, the operator and
arguments within parentheses are taken to be of highest precedence,
just like a normal function call.

=end original

“¸¸“¾à, “¸®“½º“Æ®“¿¬“»ê“ÀÚ(print() “µî“µî)“³ª “´Ü“Ç×“¿¬“»ê“ÀÚ (chdir() “µî“µî) “ÀÇ
“ÀÌ“¸§“ÀÇ “µÚ“¿¡ “¿­“¸°“°ý“È£('(')“°¡ “¿À“´Â “°æ“¿ì“¿¡“´Â “±× “¿¬“»ê“ÀÚ“¿Í “°ý“È£“¾È“ÀÇ “ÀÎ“¼ö“´Â
“º¸“Åë “ÇÔ“¼ö“È£“Ãâ“°°“ÀÌ “¹«“¾ù“º¸“´Ù “³ô“Àº “¿ì“¼±“¼ø“À§ “Ã³“¸®“µË“´Ï“´Ù.

=begin original

In the absence of parentheses, the precedence of list operators such as
C<print>, C<sort>, or C<chmod> is either very high or very low depending on
whether you are looking at the left side or the right side of the operator.
For example, in

=end original

“°ý“È£“°¡ “¾ø“´Â “°æ“¿ì“¿¡“´Â, C<print>, C<sort> C<chmod> “°°“Àº “¸®“½º“Æ® “¿¬“»ê“ÀÚ“ÀÇ
“¿ì“¼±“¼ø“À§“´Â, “¿¬“»ê“ÀÚ“ÀÇ “¿Þ“ÂÊ“¿¡“¼­ “ÇÏ“¸é “´ë“´Ü“È÷ “³ô“°í, 
“¿À“¸¥“ÂÊ“¿¡“¼­ “ÇÏ“¸é “´ë“´Ü“È÷ “³·“°Ô “º¸“ÀÔ“´Ï“´Ù.
“¿¹“¸¦ “µé“¸é

    @ary = (1, 3, sort 4, 2);
    print @ary;		# prints 1324

=begin original

the commas on the right of the sort are evaluated before the sort,
but the commas on the left are evaluated after.  In other words,
list operators tend to gobble up all arguments that follow, and
then act like a simple TERM with regard to the preceding expression.
Be careful with parentheses:

=end original

“À§“¿Í “°°“Àº “°æ“¿ì sort “ÀÇ “¿À“¸¥“ÂÊ “ÄÞ“¸¶“´Â sort“º¸“´Ù“µµ “¾Õ“¿¡“¼­ “Æò“°¡“µÇ“Áö“¸¸
(“¿À“¸¥“ÂÊ“¿¡“¼­ “º¸“¸é soft“ÀÇ “¿ì“¼±“¼ø“À§“±â “³·“À½), “¿Þ“ÂÊ“ÀÇ “ÄÞ“¸¶“´Â sort“ÀÇ “µÚ“¿¡
“Æò“°¡“µË“´Ï“´Ù(“¿Þ“ÂÊ“¿¡“¼­ “º¸“¸é sort “ÂÊ“ÀÌ “¿ì“¼±“¼ø“À§“°¡ “³ô“¾Æ“Áü).
“¹Ù“²ã “¸»“ÇÏ“¸é, “¸®“½º“Æ®“¿¬“»ê“ÀÚ“´Â “ÀÚ“½Å“ÀÇ “µÚ“¿¡ “¿À“´Â “ÀÎ“¼ö“¸¦ 
“¸ð“µÎ “»ç“¿ë“ÇØ “Ã³“¸®“¸¦ “ÇÏ“Áö“¾Ê“°í,
“±× “°á“°ú“¸¦ “ÀÚ“½Å“ÀÇ “¾Õ“ÀÇ “½Ä“¿¡ “´ë“ÇÑ "“Ç×"“ÀÎ“°Í “Ã³“·³ “º¸“ÀÌ“°Ô “ÇÏ“´Â “°Í“ÀÔ“´Ï“´Ù.
“¹°“·Ð, “°ý“È£“¿¡“´Â “ÁÖ“ÀÇ“ÇØ “ÁÖ“¼¼“¿ä.

=begin original

    # These evaluate exit before doing the print:
    print($foo, exit);	# Obviously not what you want.
    print $foo, exit;	# Nor is this.

=end original

    # “´Ù“À½“Àº print “¸¦ “½Ç“Çà“ÇÏ“±â “Àü“¿¡ exit “¸¦ “Æò“°¡“ÇÕ“´Ï“´Ù.
    print($foo, exit);  # “ÀÌ“·± “Áþ“Àº “ÇÏ“°í “½Í“Áö “¾Ê“°Ú“ÁÒ?
    print $foo, exit;   # “ÀÌ“°Í“µµ “¾Æ“´Ï“°Ú“°í

=begin original

    # These do the print before evaluating exit:
    (print $foo), exit;	# This is what you want.
    print($foo), exit;	# Or this.
    print ($foo), exit;	# Or even this.

=end original

    # “´Ù“À½“Àº exit “¸¦ “Æò“°¡“ÇÏ“±â “Àü“¿¡ print“¸¦ “½Ç“Çà“ÇÕ“´Ï“´Ù.
    (print $foo), exit; # “ÀÌ“·± “°Í“À» “ÇÏ“·Á“°í “ÇÏ“¼Ì“ÁÒ?
    print($foo), exit;  # “¾Æ“´Ô “ÀÌ“°Å?“¡£
    print ($foo), exit; # “ÀÌ“°Í“µµ OK“¡£

=begin original

Also note that

=end original

“¶Ç“ÇÑ,

    print ($foo & 255) + 1, "\n";

=begin original

probably doesn't do what you expect at first glance.  The parentheses
enclose the argument list for C<print> which is evaluated (printing
the result of C<$foo & 255>).  Then one is added to the return value
of C<print> (usually 1).  The result is something like this:

=end original

“ÀÇ “µ¿“ÀÛ“À» “ÇÑ “¹ø “º¸“´Â “°Í“¸¸“À¸“·Î “ÆÇ“´Ü“ÇÏ“´Â “°Í“Àº “¾î“·Æ“°Ú“ÁÒ?
“°ý“È£“´Â C<print> “¸¦ “À§“ÇØ “Æò“°¡“µÇ“´Â “ÀÎ“¼ö“¸®“½º“Æ®“¸¦ “°¨“½Î“°í “ÀÖ“½À“´Ï“´Ù.
(C<$foo & 255> “¶ó“´Â “°á“°ú“°¡ “Ç¥“½Ã“µË“´Ï“´Ù)“¡£
“±×“¸®“°í C<print> “ÀÇ “¸®“ÅÏ“°ª(“º¸“Åë“Àº 1)“¿¡ 1“ÀÌ “´õ“ÇØ“Áý“´Ï“´Ù. 
“°á“°ú“´Â “¾Æ“·¡“¿Í “°°“½À“´Ï“´Ù.

    1 + 1, "\n";    # Obviously not what you meant.

=begin original

To do what you meant properly, you must write:

=end original

“ÀÚ“½Å“ÀÇ “¿ø“Çß“´ø “°Í“À» “Àû“Àý“È÷ “½Ç“Çà“ÇÏ“±â “À§“ÇØ“¼­“´Â “¾Æ“·¡“¿Í “°°“ÀÌ“½á“¾ß“µË“´Ï“´Ù.

    print(($foo & 255) + 1, "\n");

=begin original

See L<Named Unary Operators> for more discussion of this.

=end original

“ÀÚ“¼¼“ÇÑ “³»“¿ë“Àº L<Named Unary Operators> “À» “Âü“Á¶“ÇØ“ÁÖ“¼¼“¿ä.

=begin original

Also parsed as terms are the C<do {}> and C<eval {}> constructs, as
well as subroutine and method calls, and the anonymous
constructors C<[]> and C<{}>.

=end original

“ÀÌ “¿Ü“¿¡“´Â "“Ç×"“À¸“·Î “ÇØ“¼®“µÇ“´Â “°Í“À¸“·Î“´Â C<do {}>“³ª C<eval {}>“ÀÇ “±¸“¼º
“¼­“ºê“·ç“Æ¾“ÀÌ“³ª “¸Þ“¼Ò“µå“ÀÇ “È£“Ãâ, “ÀÌ“¸§“¾ø“´Â “±¸“Á¶“ÀÎ C<[]>“¿Í C<{}>“°¡ “ÀÖ“½À“´Ï“´Ù.

=begin original

See also L<Quote and Quote-like Operators> toward the end of this section,
as well as L</"I/O Operators">.

=end original

“µÚ“ÀÇ L<Quote and Quote-like Operators>“¿Í L<"/I/O Operators">“µµ “Âü“Á¶“ÇÏ“¼¼“¿ä.

=head2 The Arrow Operator
X<arrow> X<dereference> X<< -> >>

(“ãÅ“ìÔ“æÑ“ß©“í­)

=begin original

"C<< -> >>" is an infix dereference operator, just as it is in C
and C++.  If the right side is either a C<[...]>, C<{...}>, or a
C<(...)> subscript, then the left side must be either a hard or
symbolic reference to an array, a hash, or a subroutine respectively.
(Or technically speaking, a location capable of holding a hard
reference, if it's an array or hash reference being used for
assignment.)  See L<perlreftut> and L<perlref>.

=end original

C “¿Í C++ “°ú “¸¶“Âù“°¡“Áö“·Î, "C<< -> >>"“´Â “°¡“¿î“µ¥“¿¡ “³õ“´Â “ÇÇ“Âü“Á¶ “¿¬“»ê“ÀÚ“ÀÔ“´Ï“´Ù.
“¿À“¸¥“ÂÊ“ÀÌ C<[...]>, C<{...}>, C<(...)> “Áß “¾î“¶² “Çü“ÅÂ“ÀÇ “Ã·“ÀÚ“ÀÌ“¸é “ÁÂ“Ãø“Àº “¹è“¿­,
“ÇØ“½¬, “¼­“ºê“·ç“Æ¾“À¸“·Î “ÇÏ“µå “·¹“ÆÛ“·±“½º “¾Æ“´Ï“¸é “½É“º¼“¸¯ “·¹“ÆÛ“·±“½º (“È¤“Àº “±â“¼ú“Àû“À¸“·Î“´Â 
“¹è“¿­ “È¤“Àº “ÇÏ“µå “·¹“ÆÛ“·±“½º“°¡ “´ë“ÀÔ“°¡“´É“ÇÏ“¸é “ÇÏ“µå “·¹“ÆÛ“·±“½º“¸¦ “°¡“Áö“´Â “Àå“¼Ò) “°¡ 
“¾Æ“´Ï“¸é “¾È“µË“´Ï“´Ù.
L<perlreftut> “¿Í L<perlref> “¸¦ “Âü“Á¶“ÇÏ“¼¼“¿ä.

=begin original

Otherwise, the right side is a method name or a simple scalar
variable containing either the method name or a subroutine reference,
and the left side must be either an object (a blessed reference)
or a class name (that is, a package name).  See L<perlobj>.

=end original

“±×“·¸“Áö “¾Ê“À¸“¸é, “¿À“¸¥“ÂÊ“Àº “¸Þ“¼Ò“µå“ÀÌ“¸§“°ú “¼­“ºê“·ç“Æ¾“ÀÇ “¸®“ÆÛ“·±“½º“¸¦ 
“°¡“Áø “´Ü“¼ø “½º“Ä®“¶ó“º¯“¼ö“·Î
“¿Þ“ÂÊ“Àº “¿À“ºê“Á§“Æ® (bless “µÈ “·¹“ÆÛ“·±“½º)  “È¤“Àº “Å¬“·¡“½º “ÀÌ“¸§“ÀÌ “¾Æ“´Ï“¸é “¾È“µË“´Ï“´Ù.
L<perlobj> “¸¦ “Âü“Á¶“ÇÏ“¼¼“¿ä.

=head2 Auto-increment and Auto-decrement
X<increment> X<auto-increment> X<++> X<decrement> X<auto-decrement> X<-->

(“Áõ“°¡“¿Í “°¨“¼Ò)

=begin original

"++" and "--" work as in C.  That is, if placed before a variable,
they increment or decrement the variable by one before returning the
value, and if placed after, increment or decrement after returning the
value.

=end original

"++" “°ú "--" “´Â C“ÀÇ “°æ“¿ì“¿Í “°°“Àº “¹æ“½Ä“À¸“·Î “µ¿“ÀÛ“ÇÕ“´Ï“´Ù.
“º¯“¼ö“ÀÇ “¾Õ“¿¡ “¿Ã“¶§“¿¡“´Â “°ª“À» “¸®“ÅÏ“ÇÏ“±â “Àü“¿¡ “º¯“¼ö“¸¦ 1 “Áõ“°¡ “È¤“Àº “°¨“¼Ò“ÇÏ“°í,
“µÚ“¿¡ “¿Ã“¶§“¿¡“´Â, “°ª“À» “¸®“ÅÏ“ÇÑ “µÚ“¿¡ “º¯“¼ö“¸¦ “Áõ“°¡ “È¤“Àº “°¨“¼Ò“ÇÕ“´Ï“´Ù.

    $i = 0;  $j = 0;
    print $i++;  # prints 0
    print ++$j;  # prints 1

=begin original

Note that just as in C, Perl doesn't define B<when> the variable is
incremented or decremented. You just know it will be done sometime
before or after the value is returned. This also means that modifying
a variable twice in the same statement will lead to undefined behaviour.
Avoid statements like:

=end original

C “¿Í “¸¶“Âù“°¡“Áö“·Î, Perl“Àº B<“¾ð“Á¦> “º¯“¼ö“°¡ “Áõ“°¡ “È¤“Àº “°¨“¼Ò“µÇ“´Â “°Í“¿¡ 
“´ë“ÇØ“¼­“´Â “Á¤“ÀÇ“ÇÒ “¼ö “¾ø“½À“´Ï“´Ù.
“°ª“ÀÌ “¸®“ÅÏ“µÇ“±â “Àü/“ÈÄ“¿¡ “½Ç“Çà“µÈ“´Ù“´Â “°Í “¸¸ “¾Ë “¼ö “ÀÖ“½À“´Ï“´Ù. 
“ÀÌ“°Í“Àº “°°“Àº “°°“Àº “±¸“¹®“ÀÎ “º¯“¼ö“¸¦ 2“¹ø “¼ö“Á¤“ÇÏ“¸é, 
“½Ç“Çà “È¤“Àº “¹Ì“Á¤“ÀÇ “»ó“ÅÂ“°¡ “µÇ“´Â “°Í“À» “ÀÇ“¹Ì“ÇÕ“´Ï“´Ù.
“¾Æ“·¡“¿Í “°°“Àº “°Í“Àº “»ï“°¡“ÇØ “ÁÖ“¼¼“¿ä:

    $i = $i ++;
    print ++ $i + $i ++;

=begin original

Perl will not guarantee what the result of the above statements is.

=end original

Perl “Àº “À§“¿Í “°°“Àº “±¸“¹®“ÀÇ “°á“°ú“¸¦ “º¸“Àå“ÇÏ“Áö “¾Ê“½À“´Ï“´Ù.

=begin original

The auto-increment operator has a little extra builtin magic to it.  If
you increment a variable that is numeric, or that has ever been used in
a numeric context, you get a normal increment.  If, however, the
variable has been used in only string contexts since it was set, and
has a value that is not the empty string and matches the pattern
C</^[a-zA-Z]*[0-9]*\z/>, the increment is done as a string, preserving each
character within its range, with carry:

=end original

“Áõ“°¡“¿¬“»ê“ÀÚ“¿¡“´Â “Á¶“±Ý “ºÐ“À§“±â“°¡ “´Ù“¸¥ “±â“´É“ÀÌ “Æ÷“ÇÔ“µÇ“¾î “ÀÖ“½À“´Ï“´Ù.
“¼ý“ÀÚ“°ª“ÀÌ “µé“¾î“°£ “º¯“¼ö“³ª “¼ý“ÀÚ“°ª“ÀÇ “¹®“¸Æ“À¸“·Î “»ç“¿ë“µÈ “º¯“¼ö“¸¦ “Áõ“°¡“½Ã“Å°“´Â “°æ“¿ì“¿¡“´Â
“º¸“Åë “Áõ“°¡ “¶ó“´Â “ÀÇ“¹Ì“·Î “µ¿“ÀÛ“ÇÏ“°Ô “µË“´Ï“´Ù. 
“±×“·¯“³ª, “±× “º¯“¼ö“°¡ “Á¤“ÀÇ“µÇ“°í “°è“¼Ó “¹®“ÀÚ“¿­“ÀÇ “¹®“¸Æ“À¸“·Î“¸¸ “»ç“¿ë“µÇ“Áö “¾Ê“°í
“°ø“¹é“µµ “¾Æ“´Ñ, C</^[a-zA-Z]*[0-9]*\z/> “¿¡ “¸Å“Ä¡“µÇ“´Â “°ª“À» “°¡“Áö“°í “ÀÖ“À» “¶§“´Â 
“°¢ “¹®“ÀÚ“ÀÇ “¹ü“À§“¸¦ “º¸“È£“ÇÏ“¸é“¼­ “±Û“ÀÚ“¼ö“¸¦ “´Ã“¸®“°í, “¹®“ÀÚ“¿­“·Î“½á“ÀÇ “Áõ“°¡“¸¦ “¼ö“Çà“ÇÕ“´Ï“´Ù.
(“¸Å“Áö“ÄÃ “Áõ“°¡“¶ó“°í “ºÒ“¸³“´Ï“´Ù.)

    print ++($foo = '99');	# prints '100'
    print ++($foo = 'a0');	# prints 'a1'
    print ++($foo = 'Az');	# prints 'Ba'
    print ++($foo = 'zz');	# prints 'aaa'

=begin original

C<undef> is always treated as numeric, and in particular is changed
to C<0> before incrementing (so that a post-increment of an undef value
will return C<0> rather than C<undef>).

=end original

C<undef> “´Â “Ç×“»ó “¼ý“ÀÚ“°ª“À¸“·Î “Ãë“±Þ“µÇ“°í, “Æ¯“È÷ “Áõ“°¡“µÇ“±â“Àü“¿¡“´Â C<0>“·Î “¹Ù“²ò“´Ï“´Ù.
(“µû“¶ó“¼­, undef“ÀÇ “ÈÄ“Áõ“°¡“°ª“Àº C<undef>“°¡ “¾Æ“´Ñ C<0>“°¡ “µË“´Ï“´Ù).

=begin original

The auto-decrement operator is not magical.

=end original

“°¨“¼Ò“¿¬“»ê“ÀÚ“¿¡“´Â “¸Å“Áö“ÄÃ“ÇÑ“°Í“Àº “¾ø“½À“´Ï“´Ù. 

=head2 Exponentiation
X<**> X<exponentiation> X<power>

(“Áö“¼ö “¿¬“»ê“ÀÚ)

=begin original

Binary "**" is the exponentiation operator.  It binds even more
tightly than unary minus, so -2**4 is -(2**4), not (-2)**4. (This is
implemented using C's pow(3) function, which actually works on doubles
internally.)

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÇ "**"“´Â “Áö“¼ö“¿¬“»ê“ÀÚ“ÀÔ“´Ï“´Ù.
“ÀÌ “¿¬“»ê“ÀÚ“´Â “´Ü“Ç×“ÀÇ “»©“±â“¿¡“¼­ “°á“ÇÕ“ÀÌ “°­“ÇÑ “¿¬“»ê“ÀÚ“·Î
-2**4 “´Â (-2)**4 “ÀÌ “¾Æ“´Ï“¶ó -(2**4) “·Î “ÇØ“¼®“µË“´Ï“´Ù.
(“ÀÌ“°Í“Àº C “ÀÇ pow(3) “À» “»ç“¿ë“ÇØ “±¸“Ãà“µÇ“¾î “ÀÖ“¾î“¼­ “³»“ºÎ“Àû“À¸“·Î double “·Î “µ¿“ÀÛ“ÇÕ“´Ï“´Ù. 

=head2 Symbolic Unary Operators
X<unary operator> X<operator, unary>

(“´Ü“Ç×“¿¬“»ê“ÀÚ)

=begin original

Unary "!" performs logical negation, i.e., "not".  See also C<not> for a lower
precedence version of this.
X<!>

=end original

“´Ü“Ç×“¿¬“»ê“ÀÚ“ÀÇ "!"“´Â “³í“¸®“ºÎ“Á¤“À» “Ã³“¸®“ÇÕ“´Ï“´Ù. “Áï, "not"“ÀÔ“´Ï“´Ù.
“ÀÌ “¿¬“»ê“ÀÚ“ÀÇ “¿ì“¼±“¼ø“À§“¸¦ “ÀÛ“°Ô“ÇÏ“·Á“¸é C<not>“°¡ “»ç“¿ë“ÇÏ“¸é “µË“´Ï“´Ù.
X<!>

=begin original

Unary "-" performs arithmetic negation if the operand is numeric.  If
the operand is an identifier, a string consisting of a minus sign
concatenated with the identifier is returned.  Otherwise, if the string
starts with a plus or minus, a string starting with the opposite sign
is returned.  One effect of these rules is that -bareword is equivalent
to the string "-bareword".  If, however, the string begins with a
non-alphabetic character (excluding "+" or "-"), Perl will attempt to convert
the string to a numeric and the arithmetic negation is performed. If the
string cannot be cleanly converted to a numeric, Perl will give the warning
B<Argument "the string" isn't numeric in negation (-) at ...>.
X<-> X<negation, arithmetic>

=end original

“´Ü“Ç×“¿¬“»ê“ÀÚ“ÀÇ "-"“´Â “ÇÇ“¿¬“»ê“ÀÚ“°¡ “¼ý“ÀÚ“°ª“ÀÌ“¸é “»ê“¼ú“ºÎ“Á¤“ÇÕ“´Ï“´Ù..
“ÇÇ“¿¬“»ê“ÀÚ“°¡  “½Ä“º°“ÀÚ“¶ó“¸é, “»©“±â “±â“È£(-)“¿¡ “±× “½Ä“º°“ÀÚ“¸¦ “ÀÌ“¾î “¹®“ÀÚ“¿­“ÀÌ “¹Ý“È¯“µË“´Ï“´Ù.
“ÀÌ“¿Ü“¿¡ “ÇÇ“¿¬“»ê“ÀÚ“ÀÇ “ÃÖ“ÃÊ“ÀÇ “¹®“ÀÚ“°¡ “´õ“ÇÏ“±â “È¤“Àº “»©“±â “ÀÏ“¶§“¿¡“´Â
“±× “±â“È£“¸¦ “°Å“²Ù“·Î “¹Ù“²Û “¹®“ÀÚ“¿­“À» “¹Ý“È¯“ÇÕ“´Ï“´Ù.
“ÀÌ “±Ô“Ä¢“ÀÇ “°á“°ú -bareword “°¡ “¹®“ÀÚ“¿­ "-bareword"“¿Í “°°“Àº “°ª“ÀÌ “µË“´Ï“´Ù.
“ÇÏ“Áö“¸¸, “¹®“ÀÚ“¿­“ÀÌ “¿µ“¾î“ÀÌ“¿Ü("+"“¿Í "-"“¸¦ “Á¦“¿Ü“ÇÏ“°í)“ÀÇ “¹®“ÀÚ“·Î “½Ã“ÀÛ“µÇ“¸é
Perl “Àº “¹®“ÀÚ“¿­“À» “¼ö“Ä¡“·Î “º¯“È¯“ÇÏ“·Á“°í “ÇÏ“°í, “±×“·¡“¼­ “»ê“¼ú“ºÎ“Á¤“ÀÌ “»ø“Çà“µË“´Ï“´Ù.
“¸¸“¾à “¹®“ÀÚ“¿­“ÀÌ “¸í“È®“ÇÏ“°Ô “¼ý“ÀÚ“°ª“À¸“·Î “º¯“È¯“µÇ“Áö“¾Ê“À» “¶§“´Â, Perl“Àº
B<Argument "the string" isn't numeric in negation (-) at ...> “¶ó“´Â
“°æ“°í“¸¦ “³À“´Ï“´Ù.
X<-> X<negation, arithmetic>

=begin original

Unary "~" performs bitwise negation, i.e., 1's complement.  For
example, C<0666 & ~027> is 0640.  (See also L<Integer Arithmetic> and
L<Bitwise String Operators>.)  Note that the width of the result is
platform-dependent: ~0 is 32 bits wide on a 32-bit platform, but 64
bits wide on a 64-bit platform, so if you are expecting a certain bit
width, remember to use the & operator to mask off the excess bits.
X<~> X<negation, binary>

=end original

“´Ü“Ç×“¿¬“»ê“ÀÚ“ÀÇ "~"“´Â “ºñ“Æ®“´Ü“À§“ÀÇ “ºÎ“Á¤“À» “¼ö“Çà“ÇÕ“´Ï“´Ù. “Áï, 1“ÀÇ “º¸“¼ö“¸¦ “¹Ý“È¯“ÇÕ“´Ï“´Ù.
“¿¹“¸¦“µé“¸é, C<0666 & ~027> “´Â 0640 “ÀÔ“´Ï“´Ù.
(L<Integer Arithmetic> “°ú L<Bitwise String Operators> “¸¦ “Âü“Á¶“ÇØ“ÁÖ“¼¼“¿ä)
“°á“°ú“ÀÇ “³Ê“ºñ“Àº “ÇÃ“·§“Æû“¿¡ “ÀÇ“Á¸“ÇÏ“°í “ÀÖ“À¸“´Ï “ÁÖ“ÀÇ“ÇØ“ÁÖ“¼¼“¿ä.
~0 “´Â 32-bit “ÇÃ“·§“Æû“¿¡“¼­ 32“ºñ“Æ®“ÀÇ “³Ê“ºñ“ÀÌ“Áö“¸¸,
64-bit “ÇÃ“·§“Æû“¿¡“¼­“´Â 64“ºñ“Æ®“ÀÇ “³Ê“ºñ“ÀÌ“´Ï
“Æ¯“Á¤“ÀÇ “ºñ“Æ® “³Ê“ºñ“¸¦ “°¡“Á¤“ÇÏ“´Â “°æ“¿ì“´Â, “³²“Àº “ºñ“Æ®“¸¦ “¸¶“½º“Å©“ÇÏ“±â“À§“ÇØ & “¿¬“»ê“ÀÚ“¸¦
“»ç“¿ë“ÇÏ“´Â “°Í“À» “ÀØ“Áö “¾Ê“µµ“·Ï “ÁÖ“ÀÇ “ÇÏ“¼¼“¿ä.

X<~> X<negation, binary>

=begin original

Unary "+" has no effect whatsoever, even on strings.  It is useful
syntactically for separating a function name from a parenthesized expression
that would otherwise be interpreted as the complete list of function
arguments.  (See examples above under L<Terms and List Operators (Leftward)>.)
X<+>

=end original

“´Ü“Ç×“¿¬“»ê“ÀÚ“ÀÎ "+"“´Â “¿¹“¸¦ “µé“¾î “¹®“ÀÚ“¿­“¿¡ “´ë“ÇØ “»ç“¿ë“ÇÒ “°æ“¿ì“¿¡“´Â 
“¾Æ“¹«“°Í“µµ “ÇÏ“Áö “¾Ê“½À“´Ï“´Ù.
“ÇÔ“¼ö “ÀÌ“¸§“¿¡ “ÀÌ“¾î “°ý“È£“°¡ “ºÙ“Àº “½Ä“À» “¾²“´Â “°æ“¿ì“¿¡“´Â, “ÇÔ“¼ö“ÀÇ “ÀÎ“¼ö“¸®“½º“Æ®“·Î 
“ÇØ“¼®“µÇ“Áö “¾Ê“±â “À§“ÇØ“¼­ “»ç“¿ë“ÇÒ “¼ö “ÀÖ“½À“´Ï“´Ù.
(“¾Æ“·¡“¿¡ “¾´ L<Terms and List Operators (Leftward)> “ÀÇ “¿¹“¸¦ “Âü“Á¶“ÇØ“ÁÖ“¼¼“¿ä)
X<+>

=begin original

Unary "\" creates a reference to whatever follows it.  See L<perlreftut>
and L<perlref>.  Do not confuse this behavior with the behavior of
backslash within a string, although both forms do convey the notion
of protecting the next thing from interpolation.
X<\> X<reference> X<backslash>

=end original

“´Ü“Ç×“¿¬“»ê“ÀÚ“ÀÎ "\" “´Â “µÚ“¿¡ “ºÙ“Àº “°Í“¿¡ “´ë“ÇÑ “¸®“ÆÛ“·±“½º“¸¦ “»ý“¼º“ÇÕ“´Ï“´Ù.
L<perlreftut> “°ú L<perlref> “¸¦ “Âü“Á¶“ÇØ“ÁÖ“¼¼“¿ä.
“ÀÌ “»ç“¿ë“¹ý“µµ “¹®“ÀÚ“¿­ “¾È“¿¡ “¹é“½½“·¡“½¬“µµ “µÚ“¿¡ “¿À“´Â “°Í “Àü“°³“µÇ“´Â “°Í“À» 
“¸·“´Â “°Í“ÀÌ “°¡“´É“ÇÏ“Áö“¸¸ “µ¿“ÀÛ“À» “È¥“µ¿“ÇÏ“Áö “¸»“¾Æ“ÁÖ“¼¼“¿ä.
X<\> X<reference> X<backslash>

=head2 Binding Operators
X<binding> X<operator, binding> X<=~> X<!~>

(“Ï¬“áÖ“æÑ“ß©“í­)

=begin original

Binary "=~" binds a scalar expression to a pattern match.  Certain operations
search or modify the string $_ by default.  This operator makes that kind
of operation work on some other string.  The right argument is a search
pattern, substitution, or transliteration.  The left argument is what is
supposed to be searched, substituted, or transliterated instead of the default
$_.  When used in scalar context, the return value generally indicates the
success of the operation.  Behavior in list context depends on the particular
operator.  See L</"Regexp Quote-Like Operators"> for details and
L<perlretut> for examples using these operators.

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÎ "=~" “´Â, “½º“Ä®“¶ó“½Ä“À» “ÆÐ“ÅÏ“¸Å“Ä¡“·Î “¹­“½À“´Ï“´Ù.
“±â“º»“Àû“À¸“·Î $_ “ÀÇ “¹®“ÀÚ“¿­“À» “°Ë“»ö“ÇÏ“°Å“³ª “º¯“°æ“ÇÏ“°Å“³ª “ÇÏ“´Â “¿¬“»ê“ÀÌ “ÀÖ“½À“´Ï“´Ù.
“ÀÌ “¿¬“»ê“ÀÚ“´Â “±×“°°“Àº “¿¬“»ê“À» “´Ù“¸¥ “¹®“ÀÚ“¿­“¿¡ “´ë“ÇØ “¼ö“Çà“½Ã“Å°“´Â “°Í“ÀÔ“´Ï“´Ù.
“¿À“¸¥“ÂÊ “ÀÎ“¼ö“´Â “°Ë“»ö “ÆÐ“ÅÏ, “Ä¡“È¯, “¹®“ÀÚ“º¯“È¯ “Áß “¾î“´À “°Í“ÀÔ“´Ï“´Ù.
“¿Þ“ÂÊ “ÀÎ“¼ö“´Â “±â“º»“Àû“ÀÎ $_ “´ë“½Å“¿¡ “°Ë“»ö, “Ä¡“È¯, “¹®“ÀÚ“º¯“È¯“ÀÇ “´ë“»ó“ÀÌ “µË“´Ï“´Ù.
“½º“Ä®“¶ó“ÄÜ“ÅØ“½º“Æ®“¿¡“¼­ “»ç“¿ë“ÇÏ“¸é “¹Ý“È¯“°ª“Àº 
“ÀÏ“¹Ý“Àû“À¸“·Î “¿¬“»ê“ÀÇ “°á“°ú“°¡ “¼º“°ø“Çß“´Â“°¡ “½Ç“ÆÐ“Çß“´Â “°¡ “ÀÔ“´Ï“´Ù.
“¸®“½º“Æ®“ÄÜ“ÅØ“½º“Æ®“¿¡“¼­“ÀÇ “Çà“µ¿“Àº “¿¬“»ê“ÀÚ“¿¡ “ÀÇ“Á¸“ÇÕ“´Ï“´Ù.
“ÀÚ“¼¼“ÇÑ “³»“¿ë“Àº L</"Regexp Quote-Like Operators"> “¸¦, 
“ÀÌ “¿¬“»ê“ÀÚ“µé“À» “»ç“¿ë“ÇÑ “¿¹“Á¦“¿¡ “´ë“ÇØ“¼­“´Â L<perlretut> “¸¦ “Âü“Á¶“ÇÏ“¼¼“¿ä“¡£

=begin original

If the right argument is an expression rather than a search pattern,
substitution, or transliteration, it is interpreted as a search pattern at run
time. Note that this means that its contents will be interpolated twice, so

=end original

“¿À“¸¥“ÂÊ“ÀÎ“¼ö“°¡ “°Ë“»ö “ÆÐ“ÅÏ, “Ä¡“È¯, “¹®“ÀÚ“º¯“È¯“ÀÌ “¾Æ“´Ñ “½Ä“ÀÌ“¶ó“¸é 
“±×“°Í“Àº “½Ç“Çà“ÇÒ “¶§“¿¡ “°á“Á¤“µÇ“´Â “°Ë“»ö“ÆÐ“ÅÏ“À¸“·Î “ÇØ“¼®“µË“´Ï“´Ù.
“ÀÌ“°Í“Àº “³»“¿ë“ÀÌ 2“¹ø “Àü“°³“µÇ“´Â “°Í“À» “ÀÇ“¹Ì“ÇÏ“´Â “°Í“ÀÓ“À¸“·Î “ÁÖ“ÀÇ“ÇØ“ÁÖ“¼¼
“Áï:

  '\\' =~ q'\\';

=begin original

is not ok, as the regex engine will end up trying to compile the
pattern C<\>, which it will consider a syntax error.

=end original

“Àº “¹Ù“¸£“Áö “¾Ê“½À“´Ï“´Ù. “Á¤“±Ô“Ç¥“Çö“¿£“Áø“Àº “ÃÖ“Á¾“Àû“À¸“·Î “ÆÐ“ÅÏ C<\>“¸¦
“ÄÄ“ÆÄ“ÀÏ“ÇÏ“·Á“°í“ÇØ“¼­, “ÀÌ“°Í“Àº “¹®“¹ý“¿¡“·¯“·Î “»ý“°¢“ÇÏ“±â “¶§“¹®“ÀÔ“´Ï“´Ù.

=begin original

Binary "!~" is just like "=~" except the return value is negated in
the logical sense.

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÎ "!~"“´Â “¹Ý“È¯“°ª“ÀÌ “³í“¸®“ºÎ“Á¤“µÇ“´Â “°Í“À» “Á¦“¿Ü“ÇÏ“°í“´Â "=~"“¿Í “°°“½À“´Ï“´Ù.

=head2 Multiplicative Operators
X<operator, multiplicative>

(’¾è“Ûö“æÑ“ß©“í­)

=begin original

Binary "*" multiplies two numbers.
X<*>

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÎ "*" “´Â 2“°³“ÀÇ “¼ý“ÀÚ“°ª“ÀÇ “°ö“À» “¹Ý“È¯“ÇÕ“´Ï“´Ù.
X<*>

=begin original

Binary "/" divides two numbers.
X</> X<slash>

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÎ "/" “´Â 2“°³“ÀÇ “¼ý“ÀÚ“°ª“ÀÇ “³ª“´« “°ª“À» “¹Ý“È¯“ÇÕ“´Ï“´Ù.

X</> X<slash>

=begin original

Binary "%" computes the modulus of two numbers.  Given integer
operands C<$a> and C<$b>: If C<$b> is positive, then C<$a % $b> is
C<$a> minus the largest multiple of C<$b> that is not greater than
C<$a>.  If C<$b> is negative, then C<$a % $b> is C<$a> minus the
smallest multiple of C<$b> that is not less than C<$a> (i.e. the
result will be less than or equal to zero).  If the operands
C<$a> and C<$b> are floating point values and the absolute value of
C<$b> (that is C<abs($b)>) is less than C<(UV_MAX + 1)>, only
the integer portion of C<$a> and C<$b> will be used in the operation
(Note: here C<UV_MAX> means the maximum of the unsigned integer type).
If the absolute value of the right operand (C<abs($b)>) is greater than
or equal to C<(UV_MAX + 1)>, "%" computes the floating-point remainder
C<$r> in the equation C<($r = $a - $i*$b)> where C<$i> is a certain
integer that makes C<$r> should have the same sign as the right operand
C<$b> (B<not> as the left operand C<$a> like C function C<fmod()>)
and the absolute value less than that of C<$b>.
Note that when C<use integer> is in scope, "%" gives you direct access
to the modulus operator as implemented by your C compiler.  This
operator is not as well defined for negative operands, but it will
execute faster.
X<%> X<remainder> X<modulus> X<mod>

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÎ "%" “´Â 2“°³“ÀÇ “¼ý“ÀÚ“°ª“ÀÇ “³ª“¸Ó“Áö“¸¦ “¹Ý“È¯“ÇÕ“´Ï“´Ù.
C<$a> “¿Í C<$b> “ÀÇ 2“°³“ÀÇ “Á¤“¼ö“ÀÇ “ÇÇ“¿¬“»ê“ÀÚ“¸¦ “Ãë“ÇÕ“´Ï“´Ù.
C<$b> “°¡ “³ô“Àº “°æ“¿ì C<$a % $b> “´Â C<$a> “¿¡“¼­ C<$a> “¸¦ “³Ñ“Áö“¾Ê“´Â
“ÃÖ“´ë“ÀÇ C<$b> “ÀÇ “¹è“¼ö“¸¦ “²ø“¾î“¿Â “°ª(?)“ÀÔ“´Ï“´Ù. 
C<$b> “°¡ “³·“Àº “°æ“¿ì C<$a % $b> “´Â C<$a> “¿¡“¼­ C<$a> “º¸“´Ù “³·“Áö “¾Ê“Àº 
“ÃÖ“¼Ò“ÀÇ C<$b> “¹è“¼ö“¸¦ “²ø“¾î“¿Â “°ª“ÀÔ“´Ï“´Ù.(“µû“¶ó“¼­ “°á“°ú“´Â 0 “ÀÌ“ÇÏ)
If the operands
C<$a> and C<$b> are floating point values and the absolute value of
C<$b> (that is C<abs($b)>) is less than C<(UV_MAX + 1)>, only
the integer portion of C<$a> and C<$b> will be used in the operation
(Note: here C<UV_MAX> means the maximum of the unsigned integer type).
If the absolute value of the right operand (C<abs($b)>) is greater than
or equal to C<(UV_MAX + 1)>, "%" computes the floating-point remainder
C<$r> in the equation C<($r = $a - $i*$b)> where C<$i> is a certain
integer that makes C<$r> should have the same sign as the right operand
C<$b> (B<not> as the left operand C<$a> like C function C<fmod()>)
and the absolute value less than that of C<$b>.

C<use integer> “°¡ “½º“ÄÚ“ÇÁ “¾È“¿¡ “ÀÖ“´Â “°æ“¿ì,
"%" “´Â C “ÄÄ“ÆÄ“ÀÏ“·¯“·Î “±¸“Ãà“µÈ “³ª“¸Ó“Áö“¿¬“»ê“ÀÚ“¸¦ “»ç“¿ë“ÇÕ“´Ï“´Ù. 
“ÀÌ“°Í“Àº “ÇÇ“¿¬“»ê“ÀÚ“°¡ “³·“Àº “°æ“¿ì“ÀÇ “¿ò“Á÷“ÀÓ“ÀÌ “ºÒ“È®“½Ç“ÇÏ“Áö“¸¸ “º¸“´Ù “ºü“¸£“°Ô “½Ç“Çà“µË“´Ï“´Ù.
X<%> X<remainder> X<modulus> X<mod>
(TBT)

=begin original

Binary "x" is the repetition operator.  In scalar context or if the left
operand is not enclosed in parentheses, it returns a string consisting
of the left operand repeated the number of times specified by the right
operand.  In list context, if the left operand is enclosed in
parentheses or is a list formed by C<qw/STRING/>, it repeats the list.
If the right operand is zero or negative, it returns an empty string
or an empty list, depending on the context.
X<x>

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÎ "x" “´Â “¹Ý“º¹“¹Ý“È¯“¿¬“»ê“ÀÚ“ÀÔ“´Ï“´Ù.
“½º“Ä®“¶ó “ÄÁ“ÅØ“½º“Æ® “È¤“Àº “¿Þ“ÂÊ“ÀÇ “°ª“ÀÌ “°ý“È£“·Î “°¨“½Î“Áø “°æ“¿ì“¿¡“´Â
“¿Þ“ÂÊ “ÇÇ“¿¬“»ê“ÀÚ“¸¦ “¿À“¸¥“ÂÊ “ÇÇ“¿¬“»ê“ÀÚ“¿¡ “Ç¥“½Ã “È½“¼ö“¸¸ “¹Ý“º¹“ÇØ “¾ò“Àº “°ª“À¸“·Î “±¸“¼º“µÈ
“¹®“ÀÚ“¿­“À» “¸®“ÅÏ“ÇÕ“´Ï“´Ù.
“¸®“½º“Æ® “ÄÁ“ÅÙ“½º“Æ®“¿¡“¼­“´Â “¿Þ“ÂÊ “ÇÇ“¿¬“»ê“ÀÚ“°¡ “°ý“È£ “°¨“½Î“Áø “°æ“¿ì “È¤“Àº , “¡¡C<qw/STRING>“ÀÇ
“Çü“ÅÂ“ÀÇ “¸®“½º“Æ®“ÀÇ “°æ“¿ì “¸®“½º“Æ®“¸¦ “¹Ý“º¹“ÇÑ “°ª“ÀÌ “¹Ý“È¯“µË“´Ï“´Ù.
“¿À“¸¥“ÂÊ “ÇÇ“¿¬“»ê“ÀÚ“°¡ 0 “È¤“Àº “³·“Àº “°ª“ÀÏ “°æ“¿ì, “ÄÜ“ÅØ“½º“Æ®“¿¡ “ÀÇ“ÇØ “ºó “¹®“ÀÚ“¿­ “È¤“Àº 
“ºó “¸®“½º“Æ®“¸¦ “¹Ý“È¯“ÇÕ“´Ï“´Ù.

X<x>

    print '-' x 80;		# print row of dashes

    print "\t" x ($tab/8), ' ' x ($tab%8);	# tab over

    @ones = (1) x 80;		# a list of 80 1's
    @ones = (5) x @ones;	# set all elements to 5


=head2 Additive Operators
X<operator, additive>

(“µ¡“¼À“¿¬“»ê“ÀÚ)

=begin original

Binary "+" returns the sum of two numbers.
X<+>

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÇ "+" “´Â “µÎ “¼ý“ÀÚ“°ª“ÀÇ “ÇÕ“À» “¹Ý“È¯“ÇÕ“´Ï“´Ù.
X<+>

=begin original

Binary "-" returns the difference of two numbers.
X<->

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÇ "-"“´Â “µÎ “¼ý“ÀÚ“°ª“ÀÇ “»« “°ª“À» “¹Ý“È¯“ÇÕ“´Ï“´Ù.
X<->

=begin original

Binary "." concatenates two strings.
X<string, concatenation> X<concatenation>
X<cat> X<concat> X<concatenate> X<.>

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÎ "." “´Â “µÎ “¹®“ÀÚ“¿­“À» “¿¬“°á“ÇÕ“´Ï“´Ù.
X<string, concatenation> X<concatenation>
X<cat> X<concat> X<concatenate> X<.>

=head2 Shift Operators
X<shift operator> X<operator, shift> X<<< << >>>
X<<< >> >>> X<right shift> X<left shift> X<bitwise shift>
X<shl> X<shr> X<shift, right> X<shift, left>

(“½Ã“ÇÁ“Æ® “¿¬“»ê“ÀÚ)

=begin original

Binary "<<" returns the value of its left argument shifted left by the
number of bits specified by the right argument.  Arguments should be
integers.  (See also L<Integer Arithmetic>.)

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÎ "<<" “´Â “¿Þ“ÂÊ “ÀÎ“¼ö“ÀÇ “°ª“À» “¿À“¸¥“ÂÊ “ÀÎ“¼ö“°¡ “³ª“Å¸“³»“´Â “ºñ“Æ®“ÀÇ “¼ö“¸¸“Å­
“¿Þ“ÂÊ“À¸“·Î “½Ã“ÇÁ“Æ®“ÇÑ “°ª“À» “¹Ý“È¯“ÇÕ“´Ï“´Ù.
“ÀÎ“¼ö“´Â “Á¤“¼ö“°¡ “¾Æ“´Ï“¸é “¾È“µË“´Ï“´Ù.
(L<Integer Arithmetic> “ªâ‘²Î“ðÎ“ª·“ªÆ“ù»“ªµ“ª¤“¡£)

=begin original

Binary ">>" returns the value of its left argument shifted right by
the number of bits specified by the right argument.  Arguments should
be integers.  (See also L<Integer Arithmetic>.)

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÎ ">>" “´Â “¿Þ“ÂÊ “ÀÎ“¼ö“ÀÇ “°ª“À» “¿À“¸¥“ÂÊ “ÀÎ“¼ö“°¡ “³ª“Å¸“³»“´Â “ºñ“Æ®“ÀÇ “¼ö“¸¸“Å­
“¿À“¸¥“ÂÊ“À¸“·Î “½Ã“ÇÁ“Æ®“ÇÑ “°ª“À» “¹Ý“È¯“ÇÕ“´Ï“´Ù.
“ÀÎ“¼ö“´Â “Á¤“¼ö“°¡ “¾Æ“´Ï“¸é “¾È“µË“´Ï“´Ù.
(L<Integer Arithmetic> “À» “Âü“Á¶“ÇØ“ÁÖ“¼¼“¿ä)

=begin original

Note that both "<<" and ">>" in Perl are implemented directly using
"<<" and ">>" in C.  If C<use integer> (see L<Integer Arithmetic>) is
in force then signed C integers are used, else unsigned C integers are
used.  Either way, the implementation isn't going to generate results
larger than the size of the integer type Perl was built with (32 bits
or 64 bits).

=end original

Perl “¿¡“¼­ "<<" “¿Í ">>" “´Â C “¿¡“¼­“ÀÇ "<<" “¿Í ">>" “¸¦ “Á÷“Á¢ “ÀÌ“¿ë“ÇØ“¼­
“±¸“Ãà“µÇ“¾î “ÀÖ“À½“¿¡ “ÁÖ“ÀÇ“ÇØ“ÁÖ“¼¼“¿ä
C<use integer> (L<Integer Arithmetic> “¸¦ “Âü“Á¶)“°¡ “À¯“È¿“ÀÎ“°æ“¿ì“¿¡“´Â 
C “ÀÇ “ºÎ“È£“°¡ “ºÙ“Àº “Á¤“¼ö“°¡ “»ç“¿ë“µÇ“°í, “±×“·¸“Áö “¾Ê“Àº “°æ“¿ì“¿¡“´Â C “ÀÇ “ºÎ“È£“¾ø“´Â “Á¤“¼ö“°¡
“»ç“¿ë“µË“´Ï“´Ù. (unsigned int)
“¾î“´À “°æ“¿ì“¿¡“µµ “ÀÌ “±¸“Á¶“´Â Perl “ÀÌ “ºô“µå“µÈ “Á¤“¼ö“Çü“ÀÇ “»ç“ÀÌ“Áî(32“ºñ“Æ® “È¤“Àº 64“ºñ“Æ®)
“º¸“´Ù “Å« “°á“°ú“¸¦ “¸¸“µé“¾î“³»“´Â “°æ“¿ì“´Â “¾ø“½À“´Ï“´Ù.

=begin original

The result of overflowing the range of the integers is undefined
because it is undefined also in C.  In other words, using 32-bit
integers, C<< 1 << 32 >> is undefined.  Shifting by a negative number
of bits is also undefined.

=end original

“Á¤“¼ö“ÀÇ “¹ü“À§“¸¦ “³Ñ“¾î“¼± “°æ“¿ì“ÀÇ “°á“°ú“´Â C“¿¡“¼­“µµ “¹Ì“Á¤“ÀÇ“µÇ“¾ú“±â“¿¡, Perl“µµ “¸¶“Âù“°¡“Áö“·Î
“¹Ì“Á¤“ÀÇ“µÇ“¾î “ÀÖ“½À“´Ï“´Ù. “¹Ù“²ã “¸»“ÇÏ“¸é 32“ºñ“Æ®“Á¤“¼ö“¸¦ “»ç“¿ë“ÇÒ “¶§, C<< 1 << 32>>“´Â
“¹Ì“Á¤“ÀÇ“ÀÔ“´Ï“´Ù. “½Ã“ÇÁ“Æ® “ÇÏ“´Â “ºñ“Æ®“¼ö“·Î “Àû“Àº “¼ö“¸¦ “Áö“Á¤“ÇÑ “°æ“¿ì“µµ “Á¤“ÀÇ“µÇ“Áö “¾Ê“½À“´Ï“´Ù.

=head2 Named Unary Operators
X<operator, named unary>

(“ÀÌ“¸§“ºÙ“Àº “´Ü“Ç×“¿¬“»ê“ÀÚ)

=begin original

The various named unary operators are treated as functions with one
argument, with optional parentheses.

=end original

“¿©“·¯“°¡“Áö “ÀÌ“¸§“ÀÌ “ºÙ“Àº “´Ü“Ç×“¿¬“»ê“ÀÚ“´Â “ÇÏ“³ª“ÀÇ “ÀÎ“¼ö“¸¦ “°¡“Áö“°í “°ý“È£“°¡ “»ý“·«“°¡“´É“ÇÑ
“ÇÔ“¼ö“·Î “Ãë“±Þ“µË“´Ï“´Ù.


=begin original

If any list operator (print(), etc.) or any unary operator (chdir(), etc.)
is followed by a left parenthesis as the next token, the operator and
arguments within parentheses are taken to be of highest precedence,
just like a normal function call.  For example,
because named unary operators are higher precedence than ||:

=end original

“¸®“½º“Æ®“¿¬“»ê“ÀÚ (print() “µî“µî) “³ª “´Ü“Ç×“¿¬“»ê“ÀÚ (chdir() “µî“µî) “Àº “¸ð“µÎ
“´Ù“À½ “Åä“Å«“À¸“·Î “¿­“¸°“°ý“È£“°¡ “¿À“¸é, “±× “¿¬“»ê“ÀÚ“¿Í “°ý“È£“¾È“ÀÇ “ÀÎ“¼ö“´Â
“º¸“Åë “ÇÔ“¼ö“È£“Ãâ“°ú “°°“Àº “ÃÖ“°í“ÀÇ “¿ì“¼±“¼ø“À§“·Î “Ãë“±Þ“µË“´Ï“´Ù.
“¿¹“¸¦ “µé“¾î “ÀÌ“¸§“ºÙ“Àº “´Ü“Ç×“¿¬“»ê“ÀÚ“´Â || “º¸“´Ù “¿ì“¼±“¼ø“À§“°¡ “³ô“¾Æ“¼­,
“¾Æ“·¡“¿Í “°°“ÀÌ “µË“´Ï“´Ù.

    chdir $foo    || die;	# (chdir $foo) || die
    chdir($foo)   || die;	# (chdir $foo) || die
    chdir ($foo)  || die;	# (chdir $foo) || die
    chdir +($foo) || die;	# (chdir $foo) || die

=begin original

but, because * is higher precedence than named operators:

=end original

“ÇÏ“Áö“¸¸ * “´Â “ÀÌ“¸§“ºÙ“Àº “¿¬“»ê“ÀÚ“º¸“´Ù “¿ì“¼±“¼ø“À§“°¡ “³ô“À¸“¹Ç“·Î “¾Æ“·¡“¿Í “°°“ÀÌ “µË“´Ï“´Ù.

    chdir $foo * 20;	# chdir ($foo * 20)
    chdir($foo) * 20;	# (chdir $foo) * 20
    chdir ($foo) * 20;	# (chdir $foo) * 20
    chdir +($foo) * 20;	# chdir ($foo * 20)

    rand 10 * 20;	# rand (10 * 20)
    rand(10) * 20;	# (rand 10) * 20
    rand (10) * 20;	# (rand 10) * 20
    rand +(10) * 20;	# rand (10 * 20)

=begin original

Regarding precedence, the filetest operators, like C<-f>, C<-M>, etc. are
treated like named unary operators, but they don't follow this functional
parenthesis rule.  That means, for example, that C<-f($file).".bak"> is
equivalent to C<-f "$file.bak">.
X<-X> X<filetest> X<operator, filetest>

=end original

“¿ì“¼±“¼ø“À§“¿¡ “°ü“ÇØ“¼­ C<-f> “³ª <C-M>“°°“Àº “ÆÄ“ÀÏ “Å×“½º“Æ®“¿¬“»ê“ÀÚ“´Â “ÀÌ“¸§“ºÙ“Àº “´Ü“Ç×“¿¬“»ê“ÀÚ“·Î
“Ãë“±Þ“µÇ“Áö“¸¸, “ÀÌ “ÇÔ“¼ö“ÀÇ “°ý“È£“·ê“Àº “Àû“¿ë“µÇ“Áö “¾Ê“½À“´Ï“´Ù. 
“¿¹“¸¦ “µé“ÀÚ“¸é C<-f($file).".bak"> “Àº C<-f "$file.bak"> “°°“Àº “°Í“À¸“·Î “Ãë“±Þ“ÇÕ“´Ï“´Ù.

X<-X> X<filetest> X<operator, filetest>

=begin original

See also L<"Terms and List Operators (Leftward)">.

=end original

L<"Terms and List Operators (Leftward)"> “¸¦ “Âü“Á¶“ÇÏ“¼¼“¿ä“¡£

=head2 Relational Operators
X<relational operator> X<operator, relational>

(“ºñ“±³“¿¬“»ê“ÀÚ)

=begin original

Binary "<" returns true if the left argument is numerically less than
the right argument.
X<< < >>

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÎ "<" “Àº “¿Þ“ÂÊ “ÀÎ“¼ö“°¡ “¼ö“Ä¡“Àû“À¸“·Î “¿À“¸¥“ÂÊ “ÀÎ“¼ö“º¸“´Ù “ÀÛ“À¸“¸é
"“Âü" “À» “¹Ý“È¯“ÇÕ“´Ï“´Ù.

=begin original

Binary ">" returns true if the left argument is numerically greater
than the right argument.
X<< > >>

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÎ "<" “´Â “¿Þ“ÂÊ “ÀÎ“¼ö“°¡ “¼ö“Ä¡“Àû“À¸“·Î “¿À“¸¥“ÂÊ “ÀÎ“¼ö“º¸“´Ù “Å©“¸é
"“Âü" “À» “¹Ý“È¯“ÇÕ“´Ï“´Ù.

=begin original

Binary "<=" returns true if the left argument is numerically less than
or equal to the right argument.
X<< <= >>

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÎ "<=" “´Â “¿Þ“ÂÊ “ÀÎ“¼ö“°¡ “¼ö“Ä¡“Àû“À¸“·Î “¿À“¸¥“ÂÊ “ÀÎ“¼ö“º¸“´Ù “ÀÛ“°Å“³ª “°°“À¸“¸é
"“Âü" “À» “¹Ý“È¯“ÇÕ“´Ï“´Ù.

=begin original

Binary ">=" returns true if the left argument is numerically greater
than or equal to the right argument.
X<< >= >>

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÎ ">=" “´Â “¿Þ“ÂÊ“ÀÎ“¼ö“°¡ “¼ö“Ä¡“Àû“À¸“·Î “¿À“¸¥“ÂÊ “ÀÎ“¼ö“º¸“´Ù “Å©“°Å“³ª “°°“À¸“¸é
"“Âü" “À» “¹Ý“È¯“ÇÕ“´Ï“´Ù.

=begin original

Binary "lt" returns true if the left argument is stringwise less than
the right argument.
X<< lt >>

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÎ "lt" “´Â “¿Þ“ÂÊ “ÀÎ“¼ö“°¡ “¹®“ÀÚ“¿­“·Î“½á “¿À“¸¥“ÂÊ “ÀÎ“¼ö“º¸“´Ù “ÀÛ“À¸“¸é 
"“Âü"“À» “¹Ý“È¯“ÇÕ“´Ï“´Ù.

=begin original

Binary "gt" returns true if the left argument is stringwise greater
than the right argument.
X<< gt >>

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÎ "gt" “´Â “¿Þ“ÂÊ “ÀÎ“¼ö“°¡ “¹®“ÀÚ“¿­“·Î“½á “¿À“¸¥“ÂÊ “ÀÎ“¼ö“º¸“´Ù “ÀÛ“À¸“¸é
"“Âü"“À» “¹Ý“È¯“ÇÕ“´Ï“´Ù.

=begin original

Binary "le" returns true if the left argument is stringwise less than
or equal to the right argument.
X<< le >>

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÎ "le" “´Â “¿Þ“ÂÊ “ÀÎ“¼ö“°¡ “¹®“ÀÚ“¿­“·Î“½á “¿À“¸¥“ÂÊ “ÀÎ“¼ö“º¸“´Ù “ÀÛ“°Å“³ª “°°“À¸“¸é
"“Âü"“À» “¹Ý“È¯“ÇÕ“´Ï“´Ù.

=begin original

Binary "ge" returns true if the left argument is stringwise greater
than or equal to the right argument.
X<< ge >>

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÎ "ge" “´Â “¿Þ“ÂÊ “ÀÎ“¼ö“°¡ “¹®“ÀÚ“¿­“·Î“½á “¿À“¸¥“ÂÊ “ÀÎ“¼ö“º¸“´Ù “Å©“°Å“³ª “°°“À¸“¸é
"“Âü"“À» “¹Ý“È¯“ÇÕ“´Ï“´Ù.

=head2 Equality Operators
X<equality> X<equal> X<equals> X<operator, equality>

(“µî“°¡“¿¬“»ê“ÀÚ)

=begin original

Binary "==" returns true if the left argument is numerically equal to
the right argument.
X<==>

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÎ "==" “´Â “¿Þ“ÂÊ “ÀÎ“¼ö“°¡ “¼ö“Ä¡“·Î“½á “¿À“¸¥“ÂÊ “ÀÎ“¼ö“º¸“´Ù “°°“À¸“¸é
"“Âü"“À» “¹Ý“È¯“ÇÕ“´Ï“´Ù.

=begin original

Binary "!=" returns true if the left argument is numerically not equal
to the right argument.
X<!=>

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÎ "!=" “´Â “¿Þ“ÂÊ “ÀÎ“¼ö“°¡ “¼ö“Ä¡“·Î“½á “¿À“¸¥“ÂÊ “ÀÎ“¼ö“¿Í “°°“Áö “¾Ê“À¸“¸é
"“Âü"“À» “¹Ý“È¯“ÇÕ“´Ï“´Ù.

=begin original

Binary "<=>" returns -1, 0, or 1 depending on whether the left
argument is numerically less than, equal to, or greater than the right
argument.  If your platform supports NaNs (not-a-numbers) as numeric
values, using them with "<=>" returns undef.  NaN is not "<", "==", ">",
"<=" or ">=" anything (even NaN), so those 5 return false. NaN != NaN
returns true, as does NaN != anything else. If your platform doesn't
support NaNs then NaN is just a string with numeric value 0.
X<< <=> >> X<spaceship>

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÎ "<=>" “´Â “¿Þ“ÂÊ “ÀÎ“¼ö“°¡ “¼ö“Ä¡“·Î“½á “¿À“¸¥“ÂÊ “ÀÎ“¼ö“º¸“´Ù
“ÀÛ“Àº“°¡, “°°“Àº“°¡, “Å«“°¡“¿¡ “µû“¶ó -1, 0, 1 “À» “¹Ý“È¯“ÇÕ“´Ï“´Ù.
“¼ö“Ä¡“·Î“½á NaN(“¼ý“ÀÚ“°¡ “¾Æ“´Ñ) “¿¡ “´ë“ÀÀ“ÇÏ“°í “ÀÖ“´Â “ÇÃ“·§“Æû“¿¡“¼­“´Â
NaN “¿¡ “´ë“ÇØ "<=>"“¸¦ “»ç“¿ë“ÇÏ“¸é undef “¸¦ “¹Ý“È¯“ÇÕ“´Ï“´Ù.
NaN “Àº “¾î“´À “°ª“¿¡ “´ë“ÇØ“¼­“µµ (NaN“¿¡ “´ë“ÇØ“¼­“µµ) "<", "==", ">", "<=", ">="
“Áß “¾î“´À “ÇÏ“³ª“µµ “¼º“¸³“ÇÏ“Áö “¾Ê“±â“¶§“¹®“¿¡ “ÀÌ“°Í“Àº “¸ð“µÎ "“°Å“Áþ"“ÀÌ “µË“´Ï“´Ù.
NaN != NaN “Àº "“Âü"“À» “¹Ý“È¯“ÇÏ“Áö“¸¸, “±× “¿Ü“ÀÇ “¾î“´À “°ª“¿¡ “´ë“ÇØ“¼­“µµ != “´Â
"“°Å“Áþ"“À» “¹Ý“È¯“ÇÕ“´Ï“´Ù. 
NaN “¿¡ “´ë“ÀÀ“ÇÏ“Áö “¾Ê“´Â “ÇÃ“·§“Æû“¿¡“¼­“´Â NaN “Àº “´Ü“¼ø“È÷ “¼ý“ÀÚ“·Î“½á“ÀÇ “°ª 0“À» “°¡“Áø
“¹®“ÀÚ“¿­“ÀÔ“´Ï“´Ù.

    perl -le '$a = "NaN"; print "No NaN support here" if $a == $a'
    perl -le '$a = "NaN"; print "NaN support here" if $a != $a'

=begin original

Binary "eq" returns true if the left argument is stringwise equal to
the right argument.
X<eq>

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÎ "eq" “´Â “¿Þ“ÂÊ “ÀÎ“¼ö“°¡ “¹®“ÀÚ“¿­“·Î“½á “¿À“¸¥“ÂÊ “ÀÎ“¼ö“¿Í “°°“´Ù“¸é
"“Âü" “À» “¹Ý“È¯“ÇÕ“´Ï“´Ù.

=begin original

Binary "ne" returns true if the left argument is stringwise not equal
to the right argument.
X<ne>

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÎ "ne" “´Â “¿Þ“ÂÊ“ÀÎ“¼ö“°¡ “¹®“ÀÚ“¿­“·Î“½á “¿À“¸¥“ÂÊ “ÀÎ“¼ö“¿Í “°°“Áö “¾Ê“´Ù“¸é
"“Âü"“À» “¹Ý“È¯“ÇÕ“´Ï“´Ù.

=begin original

Binary "cmp" returns -1, 0, or 1 depending on whether the left
argument is stringwise less than, equal to, or greater than the right
argument.
X<cmp>

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÎ "cmp"“´Â “¿Þ“ÂÊ“ÀÎ“¼ö“°¡ “¹®“ÀÚ“¿­“·Î“½á “¿À“¸¥“ÂÊ “ÀÎ“¼ö“º¸“´Ù,
“ÀÛ“°Å“³ª, “°°“°Å“³ª, “Å©“°Å“³ª “µû“¶ó“¼­ -1, -, 1 “À» “¹Ý“È¯“ÇÕ“´Ï“´Ù.

=begin original

Binary "~~" does a smart match between its arguments. Smart matching
is described in L<perlsyn/"Smart matching in detail">.
This operator is only available if you enable the "~~" feature:
see L<feature> for more information.
X<~~>

=end original

“ÀÌ“Ç×“¿¬“»ê“Áö“ÀÎ "~~"“´Â “½º“¸¶“Æ®“¸Å“Äª“À¸“·Î“½á “µ¿“ÀÛ“ÇÕ“´Ï“´Ù.
“½º“¸¶“Æ® “¸Å“Äª“¿¡ “´ë“ÇØ“¼­“´Â L<perlsyn/"Smart matching in detail"> “¿¡“¼­
“±â“¼ú“ÇÏ“°í “ÀÖ“½À“´Ï“´Ù.
“ÀÌ “¿¬“»ê“ÀÚ“´Â "~~" “±â“´É“ÀÌ “À¯“È¿“ÇÑ “°æ“¿ì“¸¸ “»ç“¿ë“°¡“´É“ÇÕ“´Ï“´Ù.
“ÀÌ“¿¡ “´ë“ÇÑ “Á¤“º¸“¿¡ “´ë“ÇØ“¼­“´Â L<feature> “¸¦ “Âü“Á¶“ÇØ“ÁÖ“¼¼“¿ä.

X<~~>

=begin original

"lt", "le", "ge", "gt" and "cmp" use the collation (sort) order specified
by the current locale if C<use locale> is in effect.  See L<perllocale>.

=end original

"lt", "le", "ge", "gt", "cmp" “´Â C<use locale> “°¡ “À¯“È¿“ÇÑ “°æ“¿ì“´Â
“Çö“Àç“ÀÇ “·Î“ÄÉ“ÀÏ“¿¡“¼­ “Áö“Á¤“µÈ “Æä“ÀÌ“Áö“¼ø“¼­“·Î “»ç“¿ë“µË“´Ï“´Ù.
L<perllocale> “À» “Âü“Á¶“ÇÏ“¼¼“¿ä.

=head2 Bitwise And
X<operator, bitwise, and> X<bitwise and> X<&>

(“ºñ“Æ®“´Ü“À§“ÀÇ AND)

=begin original

Binary "&" returns its operands ANDed together bit by bit.
(See also L<Integer Arithmetic> and L<Bitwise String Operators>.)

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÎ "&" “´Â, “µÎ “ÇÇ“¿¬“»ê“ÀÚ“ÀÇ “ºñ“Æ®“¸¶“´Ù “³í“¸®“°ö“À» “Ãë“ÇØ,
“±× “°á“°ú“¸¦ “¹Ý“È¯“ÇÕ“´Ï“´Ù.
(L<Integer Arithmetic> “°ú L<Bitwise String Operators> “À» “Âü“Á¶“ÇØ“ÁÖ“¼¼“¿ä)

=begin original

Note that "&" has lower priority than relational operators, so for example
the brackets are essential in a test like

=end original

"&" “´Â “°ü“°è“¿¬“»ê“ÀÚ“º¸“´Ù “¿ì“¼±“¼ø“À§“°¡ “³·“±â“¶§“¹®“¿¡, “¾Æ“·¡“¿Í “°°“Àº “Å×“½º“Æ®“¿¡“¼­“´Â
“°ý“È£“°¡ “ÇÊ“¿ä“ÇÕ“´Ï“´Ù.

	print "Even\n" if ($x & 1) == 0;

=head2 Bitwise Or and Exclusive Or
X<operator, bitwise, or> X<bitwise or> X<|> X<operator, bitwise, xor>
X<bitwise xor> X<^>

(“ºñ“Æ®“´Ü“À§“ÀÇ OR “¿Í XOR)

=begin original

Binary "|" returns its operands ORed together bit by bit.
(See also L<Integer Arithmetic> and L<Bitwise String Operators>.)

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÎ "|" “´Â “µÎ “ÇÇ“¿¬“»ê“ÀÚ“ÀÇ “ºñ“Æ®“¸¶“´Ù “³í“¸®“ÇÕ“À» “Ãë“ÇØ,
“±× “°á“°ú“¸¦ “¹Ý“È¯“ÇÕ“´Ï“´Ù.
(L<Integer Arithmetic> “°ú L<Bitwise String Operators> “¸¦ “Âü“Á¶“ÇØ“ÁÖ“¼¼“¿ä)

=begin original

Binary "^" returns its operands XORed together bit by bit.
(See also L<Integer Arithmetic> and L<Bitwise String Operators>.)

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÎ "^" “´Â “µÎ “ÇÇ“¿¬“»ê“ÀÚ“ÀÇ “ºñ“Æ®“¸¶“´Ù “¹è“Å¸“³í“¸®“ÇÕ“À» “Ãë“ÇØ
“±× “°á“°ú“¸¦ “¹Ý“È¯“ÇÕ“´Ï“´Ù.
(L<Integer Arithmetic> “°ú L<Bitwise String Operators> “¸¦ “Âü“Á¶“ÇØ“ÁÖ“¼¼“¿ä)

=begin original

Note that "|" and "^" have lower priority than relational operators, so
for example the brackets are essential in a test like

=end original

"|" “¿Í "^" “Àº “°ü“°è“¿¬“»ê“ÀÚ“º¸“´Ù “¿ì“¼±“¼ø“À§“°¡ “³·“±â“¶§“¹®“¿¡, “¾Æ“·¡“¿Í “°°“Àº
“Å×“½º“Æ®“¿¡“¼­“´Â “°ý“È£“°¡ “ÇÊ“¿ä“ÇÕ“´Ï“´Ù.

	print "false\n" if (8 | 2) != 10;

=head2 C-style Logical And
X<&&> X<logical and> X<operator, logical, and>

(C “½º“Å¸“ÀÏ“ÀÇ “³í“¸®“°ö)

=begin original

Binary "&&" performs a short-circuit logical AND operation.  That is,
if the left operand is false, the right operand is not even evaluated.
Scalar or list context propagates down to the right operand if it
is evaluated.

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÎ "&&"“´Â “´Ü“¶ô“ÀÇ “³í“¸®“°ö“¿¬“»ê“À» “¼ö“Çà“ÇÕ“´Ï“´Ù. 
“Áï, “¿Þ“ÂÊ “ÇÇ“¿¬“»ê“ÀÚ“°¡ "“°Å“Áþ"“À» “°æ“¿ì“¿¡“´Â “¿À“¸¥“ÂÊ “ÇÇ“¿¬“»ê“¸¦ “Æò“°¡“ÇØ“¼­
“½Ç“Çà“ÇÏ“Áö “¾Ê“µµ“·Ï “ÇÏ“´Â “°Í“ÀÔ“´Ï“´Ù.
“Æò“°¡“µÉ “°æ“¿¡“´Â, “½º“Ä®“¶ó “È¤“Àº “¸®“½º“Æ® “ÄÜ“ÅØ“½º“Æ®“´Â
“¿À“¸¥“ÂÊ “ÇÇ“¿¬“»ê“ÀÚ“¿¡“µµ “Àü“´Þ“ÇÕ“´Ï“´Ù.

=head2 C-style Logical Or
X<||> X<operator, logical, or>

(C “½º“Å¸“ÀÏ“ÀÇ “³í“¸®“ÇÕ)

=begin original

Binary "||" performs a short-circuit logical OR operation.  That is,
if the left operand is true, the right operand is not even evaluated.
Scalar or list context propagates down to the right operand if it
is evaluated.

=end original

“ÀÌ“Ç×“¿¬“»ê“ÀÚ“ÀÎ "||" “´Â, “´Ü“¶ô“ÀÇ “³í“¸®“ÇÕ“¿¬“»ê“À» “¼ö“Çà“ÇÕ“´Ï“´Ù.
“Áï, “¿Þ“ÂÊ “ÇÇ“¿¬“»ê“ÀÚ“°¡ "“Âü"“ÀÏ “°æ“¿ì,“¿À“¸¥“ÂÊ “¿¬“»ê“ÀÚ“´Â “Æò“°¡“µÇ“Áö
“¾Ê“°Ô “ÇÏ“´Â “°Í“ÀÔ“´Ï“´Ù.
“Æò“°¡“µÉ “°æ“¿ì“¿¡“´Â, “½º“Ä®“¶ó “È¤“Àº “¸®“½º“Æ® “ÄÜ“ÅØ“½º“Æ®“´Â
“¿À“¸¥“ÂÊ “ÇÇ“¿¬“»ê“ÀÚ“¿¡“µµ “Àü“´Þ“µË“´Ï“´Ù.

=head2 C-style Logical Defined-Or
X<//> X<operator, logical, defined-or>

(C “½º“Å¸“ÀÏ“ÀÇ “Á¤“ÀÇ“¼º“ÇÕ)

=begin original

Although it has no direct equivalent in C, Perl's C<//> operator is related
to its C-style or.  In fact, it's exactly the same as C<||>, except that it
tests the left hand side's definedness instead of its truth.  Thus, C<$a // $b>
is similar to C<defined($a) || $b> (except that it returns the value of C<$a>
rather than the value of C<defined($a)>) and is exactly equivalent to
C<defined($a) ? $a : $b>.  This is very useful for providing default values
for variables.  If you actually want to test if at least one of C<$a> and
C<$b> is defined, use C<defined($a // $b)>.

=end original

Although it has no direct equivalent in C, Perl's C<//> operator is related
to its C-style or.  In fact, it's exactly the same as C<||>, except that it
tests the left hand side's definedness instead of its truth.  Thus, C<$a // $b>
is similar to C<defined($a) || $b> (except that it returns the value of C<$a>
rather than the value of C<defined($a)>) and is exactly equivalent to
C<defined($a) ? $a : $b>.  This is very useful for providing default values
for variables.  If you actually want to test if at least one of C<$a> and
C<$b> is defined, use C<defined($a // $b)>.
(TBT)

=begin original

The C<||>, C<//> and C<&&> operators return the last value evaluated
(unlike C's C<||> and C<&&>, which return 0 or 1). Thus, a reasonably
portable way to find out the home directory might be:

=end original

C<||>, C<//>,  C<&&> “¿¬“»ê“ÀÚ“´Â, (C “Ã³“·³ “´Ü“¼ø“È÷ 0 “ÀÌ“³ª 1“À» “¹Ý“È¯“ÇÏ“´Â “°Í“ÀÌ “¾Æ“´Ñ) 
“¸¶“Áö“¸·“¿¡ “Æò“°¡“µÇ“´Â “°ª“À» “¹Ý“È¯“ÇÕ“´Ï“´Ù.
“ÀÌ“¿¡ “ÀÇ“ÇØ“¼­ “ÀÏ“¹Ý“Àû“À¸“·Î “»ç“¿ë“ÇÒ “¼ö “ÀÖ“´Â “È¨ “µð“·º“Åä“¸®“¸¦ “Ã£“´Â “¹æ“¹ý“Àº : 

    $home = $ENV{'HOME'} // $ENV{'LOGDIR'} //
	(getpwuid($<))[7] // die "You're homeless!\n";

=begin original

In particular, this means that you shouldn't use this
for selecting between two aggregates for assignment:

=end original

“Æ¯“º°“È÷ “ÀÌ“°Í“ÀÎ “´ë“ÀÔ“À» “À§“ÇØ “µÎ“°³“ÀÇ “Áý“ÇÕ“À» “¼±“ÅÃ“ÇÏ“±â “À§“ÇØ 
“»ç“¿ë“ÇÏ“´Â “°Í“ÀÌ “¾Æ“´Ô“À» “ÀÇ“¹Ì“ÇÕ“´Ï“´Ù.

    @a = @b || @c;		# this is wrong
    @a = scalar(@b) || @c;	# really meant this
    @a = @b ? @b : @c;		# this works fine, though

=begin original

As more readable alternatives to C<&&> and C<||> when used for
control flow, Perl provides the C<and> and C<or> operators (see below).
The short-circuit behavior is identical.  The precedence of "and"
and "or" is much lower, however, so that you can safely use them after a
list operator without the need for parentheses:

=end original

Perl “¿¡“¼­“´Â “Èå“¸§“Á¦“¾î“¿¡ “»ç“¿ë“ÇÏ“´Â “°æ“¿ì“ÀÇ “´Ù“¼Ò “ÀÐ“±â “½¬“¿î C<&&> “¿Í C<||> “ÀÇ “µ¿“ÀÇ“¾î“·Î C<and> “¿¬“»ê“ÀÚ“¿Í C<or> “¿¬“»ê“ÀÚ“°¡ “ÀÖ“½À“´Ï“´Ù.(“¾Æ“·¡ “Âü“Á¶) 
“´Ü“¶ô“ÀÇ “µ¿“ÀÛ“Àº “¸ð“µÎ “°°“½À“´Ï“¸¸, "and"“¿Í "or"“ÀÇ “¿ì“¼±“¼ø“À§“´Â “²Ï “³·“À¸“¹Ç“·Î,
“ÀÎ“¼ö“¿¡ “°ý“È£“¸¦ “»ç“¿ë“ÇÏ“Áö “¾Ê“´Â “¸®“½º“Æ®“¿¬“»ê“ÀÚ“ÀÇ “µÚ“¿¡ “ºÙ“¿©“¼­ “¾µ “°æ“¿ì“¿¡“µµ
“¾È“½É“ÇØ“¼­ “»ç“¿ë“ÇÒ “¼ö “ÀÖ“½À“´Ï“´Ù.

    unlink "alpha", "beta", "gamma"
	    or gripe(), next LINE;

=begin original

With the C-style operators that would have been written like this:

=end original

C “½º“Å¸“ÀÏ“ÀÇ “¿¬“»ê“ÀÚ“¿¡“¼­“´Â “¾Æ“·¡“¿Í “°°“ÀÌ “¾µ “ÇÊ“¿ä“°¡ “ÀÖ“½À“´Ï“´Ù.

    unlink("alpha", "beta", "gamma")
	    || (gripe(), next LINE);

=begin original

Using "or" for assignment is unlikely to do what you want; see below.

=end original

“ÓÛ“ìý“ªÇ "or" “ªò“ÞÅ“ª¦“ªÈ“¡¢“ª·“ª¿“ª¤“ª³“ªÈ“ªÈ“êÞ“ª¦“ª³“ªÈ“ªË“ªÊ“ªê“ªÞ“ª¹“¡£
“ì¤“ù»“ªò‘²Î“ðÎ“ª·“ªÆ“ù»“ªµ“ª¤“¡£

=head2 Range Operators
X<operator, range> X<range> X<..> X<...>

(“Ûô’°Ï“æÑ“ß©“í­)

=begin original

Binary ".." is the range operator, which is really two different
operators depending on the context.  In list context, it returns a
list of values counting (up by ones) from the left value to the right
value.  If the left value is greater than the right value then it
returns the empty list.  The range operator is useful for writing
C<foreach (1..10)> loops and for doing slice operations on arrays. In
the current implementation, no temporary array is created when the
range operator is used as the expression in C<foreach> loops, but older
versions of Perl might burn a lot of memory when you write something
like this:

=end original

“ì£“ú£“æÑ“ß©“í­“ªÎ ".." “ªÏ“Ûô’°Ï“æÑ“ß©“í­“ªÇ“¡¢“ÞÅ“ªï“ªì“ªë“«³“«ó“«Æ“«­“«¹“«È“ªË“ªè“ªÃ“ªÆ
“ì¶“ªÊ“ªë“ÔÑ“íÂ“ªò“ª¹“ªë 2 “ªÄ“ªÎ“æÑ“ß©“í­“ªò“ùê“ªï“ª»“ª¿“ªâ“ªÎ“ªÇ“ª¹“¡£
“«ê“«¹“«È“«³“«ó“«Æ“«­“«¹“«È“ªÇ“ªÏ“¡¢“ñ§“ªÎ“ö·“ª«“ªé“éÓ“ªÎ“ö·“ªÞ“ªÇ (1 “ªÅ“ªÄ“ã°“â÷“ªÇ) ‘Êý“ª¨“ª¢“ª²“ª¿“ö·“ª«“ªé
“ªÊ“ªë“«ê“«¹“«È“ªò“Ú÷“ª·“ªÞ“ª¹“¡£
“ñ§“ö°“ªÎ“ö·“ª¬“éÓ“ö°“ªÎ“ö·“ªè“ªê“ÓÞ“ª­“ª¤“íÞ“ùê“ªÏ“¡¢“Íö“«ê“«¹“«È“ªò“Ú÷“ª·“ªÞ“ª¹“¡£
“Ûô’°Ï“æÑ“ß©“í­“ªÏ“¡¢C<foreach (1..10)> “ªÎ“ªè“ª¦“ªÊ“«ë’¡¼“«×“ªò“ßö“ª¯“ªÈ“ª­“ªä“¡¢
“ÛÕ“Öª“ªÎ“«¹“«é“«¤“«¹“æÑ“ß©“ªò“ú¼“ªÊ“ª¦“ªÈ“ª­“ªË“øµ“××“ªÇ“ª¹“¡£
“úÞ‘×´“ªÎ’¼Â‘×°“ªÇ“ªÏ“¡¢C<foreach> “«ë’¡¼“«×“ªÎ“ãÒ“ªÎ“ñé“ªÇ“Ûô’°Ï“æÑ“ß©“í­“ªò“ÞÅ“ªÃ“ªÆ“ªâ
“ìé“ãÁ“ÛÕ“Öª“ªÏ“íÂ“ªê“ªÞ“ª»“ªó“ª¬“¡¢“Í¯“ª¤ Perl “ªÏ“ì¤“ù»“ªÎ“ªè“ª¦“ªÊ“ª³“ªÈ“ªò“ßö“ª¯“ªÈ“¡¢
“ÓÞ“Õá“ªÎ“«á“«â“«ê“ªò“á¼“Þ¨“ª¹“ªë“ª³“ªÈ“ªË“ªÊ“ªê“ªÞ“ª¹:

    for (1 .. 1_000_000) {
	# code
    }

=begin original

The range operator also works on strings, using the magical auto-increment,
see below.

=end original

“Ûô’°Ï“æÑ“ß©“í­“ªÏ“¡¢“«Þ“«¸“««“«ë“í»“ÔÑ“«¤“«ó“«¯“«ê“«á“«ó“«È“ªò“ÞÅ“ª¦“ª³“ªÈ“ªÇ“Ùþ“í®“Öª“ªÇ“ªâ“ÔÑ“íÂ“ª·“ªÞ“ª¹“¡£
“ì¤“ù»“ªò‘²Î“ðÎ“ª·“ªÆ“ª¯“ªÀ“ªµ“ª¤“¡£

=begin original

In scalar context, ".." returns a boolean value.  The operator is
bistable, like a flip-flop, and emulates the line-range (comma) operator
of B<sed>, B<awk>, and various editors.  Each ".." operator maintains its
own boolean state.  It is false as long as its left operand is false.
Once the left operand is true, the range operator stays true until the
right operand is true, I<AFTER> which the range operator becomes false
again.  It doesn't become false till the next time the range operator is
evaluated.  It can test the right operand and become false on the same
evaluation it became true (as in B<awk>), but it still returns true once.
If you don't want it to test the right operand till the next
evaluation, as in B<sed>, just use three dots ("...") instead of
two.  In all other regards, "..." behaves just like ".." does.

=end original

“«¹“««“«é“«³“«ó“«Æ“«­“«¹“«È“ªÇ“ÞÅ“ªï“ªì“ª¿“ªÈ“ª­“ªË“ªÏ“¡¢".." “ªÏ‘Õæ˜ºô“ö·“ªò“Ú÷“ª·“ªÞ“ª¹“¡£
“ª³“ªÎ“æÑ“ß©“í­“ªÏ“¡¢“«Õ“«ê“«Ã“«×“«Õ“«í“«Ã“«×“ªÎ“ªè“ª¦“ªË 2 “ö·“äÌ“ïÒ“ªÇ“¡¢
B<sed> “ªä B<awk> “ªä“Òý“ª¯“ªÎ“«¨“«Ç“«£“«¿“ªÇ“ªÎ“ú¼“Ûô’°Ï (“«³“«ó“«Þ) “æÑ“ß©“í­“ªò
“«¨“«ß“«å“«ì’¡¼“«È“ª¹“ªë“ªâ“ªÎ“ªÈ“ªÊ“ªê“ªÞ“ª¹“¡£
“ÊÀ‘¡©“ªÎ ".." “æÑ“ß©“í­“ª¬“ª½“ªì“ª¾“ªì“ªË‘¶À“Ø¡“ª·“ªÆ“í»“ÝÂ“ªÎ‘Õæ˜ºô‘×´“÷¾“ªò“Î·“×â“ª·“ªÞ“ª¹“¡£
“ªÏ“ª¸“ªá“ªÏ“¡¢“ñ§“ù¬“æÑ“ß©“í­“ª¬˜ºô“ªÇ“ª¢“ªë“Êà“¡¢“æÑ“ß©“îï‘Ìå“ªâ˜ºô“ªÈ“ªÊ“ªÃ“ªÆ“ª¤“ªÞ“ª¹“¡£
“Ûô’°Ï“æÑ“ß©“í­“ªÏ“¡¢“ª¤“ªÃ“ª¿“ªó“ñ§“ù¬“æÑ“ß©“í­“ª¬‘Õæ“ªË“ªÊ“ªë“ªÈ“¡¢“éÓ“ù¬“æÑ“ß©“í­“ª¬‘Õæ“ªÇ“ª¢“ªë“Êà“¡¢
‘Õæ“ªò“Ú÷“ª¹“ªè“ª¦“ªË“ªÊ“ªê“ªÞ“ª¹“¡£
“éÓ“ù¬“æÑ“ß©“í­“ª¬˜ºô“ªË“ªÊ“ªë“ªÈ“¡¢“æÑ“ß©“í­“ªâ˜ºô“ªò“Ú÷“ª¹“ªè“ª¦“ªË“ªÊ“ªê“ªÞ“ª¹“¡£
(“ó­“ªË“Ûô’°Ï“æÑ“ß©“í­“ª¬“øÄ’²Á“ªµ“ªì“ªë“ªÞ“ªÇ“ªÏ“¡¢˜ºô“ªÈ“ªÏ“ªÊ“ªê“ªÞ“ª»“ªó“¡£
(B<awk> “ªÇ“ªÎ“ªè“ª¦“ªË) ‘Õæ“ªÈ“ªÊ“ªÃ“ª¿“¡¢“ª½“ªÎ“øÄ’²Á“ªÎ“ñé“ªÇ“éÓ“ù¬“æÑ“ß©“í­“ªò“«Æ“«¹“«È“ª·“¡¢
˜ºô“ªÈ“ª¹“ªë“ª³“ªÈ“ª¬“ªÇ“ª­“ªÞ“ª¹“ª¬“¡¢1 “Óø“ªÏ‘Õæ“ªò“Ú÷“ª¹“ª³“ªÈ“ªË“ªÊ“ªê“ªÞ“ª¹“¡£
B<sed> “ªÇ“ªÎ“ªè“ª¦“ªË“¡¢“ó­“ªË“øÄ’²Á“ªµ“ªì“ªë“ªÞ“ªÇ“éÓ“ù¬“æÑ“ß©“í­“ªò“«Æ“«¹“«È“ª·“ª¿“ª¯“ªÊ“ª±“ªì“ªÐ“¡¢
2 “ËÁ“ªÎ“«É“«Ã“«È“ªÎ“ÓÛ“ªï“ªê“ªË 3 “ªÄ“ªÎ“«É“«Ã“«È ("...") “ªò“ÞÅ“ªÃ“ªÆ“ª¯“ªÀ“ªµ“ª¤“¡£
“ª½“ªÎ“öâ“ªÎ“ïÃ“ªÇ“ªÏ“¡¢"..." “ªÏ ".." “ªÈ“ÔÒ’ÍÍ“ªË“òÉ“Ùñ“ª¤“ªÞ“ª¹“£®

=begin original

The right operand is not evaluated while the operator is in the
"false" state, and the left operand is not evaluated while the
operator is in the "true" state.  The precedence is a little lower
than || and &&.  The value returned is either the empty string for
false, or a sequence number (beginning with 1) for true.  The
sequence number is reset for each range encountered.  The final
sequence number in a range has the string "E0" appended to it, which
doesn't affect its numeric value, but gives you something to search
for if you want to exclude the endpoint.  You can exclude the
beginning point by waiting for the sequence number to be greater
than 1.

=end original

“éÓ“ù¬“æÑ“ß©“í­“ªÏ“¡¢“æÑ“ß©“í­“ªÎ‘×´“÷¾“ª¬“¡¸˜ºô“¡¹“ªÇ“ª¢“ªë“Êà“ªÏ“øÄ’²Á“ªµ“ªì“ªë“ª³“ªÈ“ª¬“ªÊ“ª¯“¡¢
“ñ§“ù¬“æÑ“ß©“í­“ªÏ“¡¢“æÑ“ß©“í­“ªÎ‘×´“÷¾“ª¬“¡¸‘Õæ“¡¹“ªÇ“ª¢“ªë“Êà“ªÏ“øÄ’²Á“ªµ“ªì“ªë“ª³“ªÈ“ª¬“ª¢“ªê“ªÞ“ª»“ªó“¡£
“éÐ“à»“â÷“êÈ“ªÏ“¡¢|| “ªÈ && “ªÎ“á´“ª·“ù»“ªÇ“ª¹“¡£
˜ºô“ªÈ“ª·“ªÆ“ªÏ“Íö“Ùþ“í®“Öª“ª¬“Ú÷“ªµ“ªì“¡¢
‘Õæ“ªÈ“ª·“ªÆ“ªÏ (1 “ª«“ªé“ã·“ªÞ“ªë) “â÷“ªË˜­å“ªó“ªÀ‘Êý“ö·“ª¬“Ú÷“ªµ“ªì“ªÞ“ª¹“¡£
“ª³“ªÎ“÷×“ª·“Ûã‘ºÅ“ªÏ“¡¢“ãæ“ª¿“ªË“Ûô’°Ï“ª¬“ã·“ªÞ“ªë“ª´“ªÈ“ªË“«ê“«»“«Ã“«È“ªµ“ªì“ªÞ“ª¹“¡£
“Ûô’°Ï“ªÎ“õÌ“ý­“ªÎ‘Êý“í®“ªË“ªÏ“¡¢“Ùþ“í®“Öª "E0" “ª¬“ªª“Í¶“ªË“ªÄ“ª±“ªé“ªì“ªÞ“ª¹“¡£
“ª³“ªì“ªÏ“¡¢‘Êý“ö·“ªÈ“ª·“ªÆ“ªÏ“ù¼“ªÎ“ç¯“úÂ“ªâ“ª¢“ªê“ªÞ“ª»“ªó“ª¬“¡¢“Ûô’°Ï“ªÎ“ðû“ªï“ªê“ªÇ“ù¼“ª«“÷å“Ü¬“ªÊ“ª³“ªÈ“ªò
“ª·“ª¿“ª¤“íÞ“ùê“ªË“¡¢“ÙÍ“ìÔ“ªÈ“ª·“ªÆ“ÞÅ“ª¦“ª³“ªÈ“ª¬“ªÇ“ª­“ªÞ“ª¹“¡£
“Ûô’°Ï“ªÎ“ã·“ªÞ“ªê“ªÇ“ù¼“ª«“ª·“ª¿“ª¤“íÞ“ùê“ªË“ªÏ“¡¢“÷×“ª·“Ûã‘ºÅ“ª¬ 1 “ªè“ªê“ªâ“ÓÞ“ª­“ª¯“ªÊ“ªë“ªÎ“ªò
“Óâ“ªÃ“ªÆ“ª¤“ªì“ªÐ“ªè“ª¤“ªÇ“ª·“ªç“ª¦“¡£

=begin original

If either operand of scalar ".." is a constant expression,
that operand is considered true if it is equal (C<==>) to the current
input line number (the C<$.> variable).

=end original

“«¹“««“«é“ªÎ ".." “ªÎ“ù¬“æÑ“ß©“í­“ª¬“ïÒ‘Êý“øú“úÞ“ªÇ“ª¢“ªë“ªÈ“ª­“ªÏ“¡¢“ª½“ªÎ“ù¬“æÑ“ß©“í­“ªÏ“äÞ’ÌÛ“ªË“¡¢
“úÞ“î¤“ªÎ“ìý“Õô“ú¼“Ûã‘ºÅ(’ÊÑ‘Êý C<$.>) “ªÈ“Ôõ“ª·“ª¤(C<==>) “íÞ“ùê“ªË‘Õæ“ªÈ“ªÊ“ªê“ªÞ“ª¹“¡£

=begin original

To be pedantic, the comparison is actually C<int(EXPR) == int(EXPR)>,
but that is only an issue if you use a floating point expression; when
implicitly using C<$.> as described in the previous paragraph, the
comparison is C<int(EXPR) == int($.)> which is only an issue when C<$.>
is set to a floating point value and you are not reading from a file.
Furthermore, C<"span" .. "spat"> or C<2.18 .. 3.14> will not do what
you want in scalar context because each of the operands are evaluated
using their integer representation.

=end original

“ªÈ“ªÆ“ªâ“á¬“ª«“ª¤“ü¥“ªò“ª¹“ªë“ªÈ“¡¢“Ýï“Îò“ªÏ’¼Â“ð·“ªË“ªÏ C<int(EXPR) == int(EXPR)> “ªÇ“ª¹“ª¬“¡¢
“ª³“ªì“ªÏ“Ý©“ÔÑ“á³‘Êý“ïÃ‘Êý“ªò“ÞÅ“ª¦“ªÈ“ª­“ªË“ªÀ“ª±“Ùý“ð¹“ªË“ªÊ“ªê“ªÞ“ª¹; “îñ“ªÎ“Ó«“Õª“ªÇ“ÑÀ“âû“ª·“ª¿“ªè“ª¦“ªË
“Ù¥“ãÆ“îÜ“ªË C<$.> “ªò“ÞÅ“ªÃ“ª¿“ªÈ“ª­“¡¢“Ýï“Îò“ªÏ C<int(EXPR) == int($.)> “ªÈ“ªÊ“ªê“¡¢
C<$.> “ªË“Ý©“ÔÑ“á³‘Êý“ïÃ‘Êý“ª¬“«»“«Ã“«È“ªµ“ªì“¡¢“«Õ“«¡“«¤“«ë“ª«“ªé’ÆÉ“ªß’¹þ“ªß“ªò“ú¼“ªï“ªÊ“ª¤“íÞ“ùê“ªË“ªÎ“ªß
“Ùý“ð¹“ªË“ªÊ“ªê“ªÞ“ª¹“¡£
“ªµ“ªé“ªË“¡¢C<"span" .. "spat"> “ªä C<2.18 .. 3.14> “ªÏ“¡¢“ª½“ªì“ª¾“ªì“ªÎ“«ª“«Ú“«é“«ó“«É“ª¬
“ïÚ‘Êý“øú“úÞ“ªò“ÞÅ“ªÃ“ªÆ“øÄ’²Á“ªµ“ªì“ªë“ª¿“ªá“¡¢“«¹“««“«é“«³“«ó“«Æ“«­“«¹“«È“ªÇ“ªÏ“ØÐ“ªß“ªÉ“ªª“ªê“ªÎ“Ì¿“Íý“ªË
“ªÊ“ªê“ªÞ“ª»“ªó“¡£

=begin original

Examples:

=end original

“ÖÇ:

=begin original

As a scalar operator:

=end original

“«¹“««“«é“æÑ“ß©“í­“ªÈ“ª·“ªÆ:

    if (101 .. 200) { print; } # print 2nd hundred lines, short for
                               #   if ($. == 101 .. $. == 200) ...

    next LINE if (1 .. /^$/);  # skip header lines, short for
                               #   ... if ($. == 1 .. /^$/);
                               # (typically in a loop labeled LINE)

    s/^/> / if (/^$/ .. eof());  # quote body

    # parse mail messages
    while (<>) {
        $in_header =   1  .. /^$/;
        $in_body   = /^$/ .. eof;
        if ($in_header) {
            # ...
        } else { # in body
            # ...
        }
    } continue {
        close ARGV if eof;             # reset $. each file
    }

=begin original

Here's a simple example to illustrate the difference between
the two range operators:

=end original

“ì¤“ù»“ªÏ“ì£“ªÄ“ªÎ“Ûô’°Ï“æÑ“ß©“í­“ªÎ“êÞ“ª¤“ªò“ãÆ“ª¹’Ã±“âí“ªÊ“ÖÇ“ªÇ“ª¹:

    @lines = ("   - Foo",
              "01 - Bar",
              "1  - Baz",
              "   - Quux");

    foreach (@lines) {
        if (/0/ .. /1/) {
            print "$_\n";
        }
    }

=begin original

This program will print only the line containing "Bar". If
the range operator is changed to C<...>, it will also print the
"Baz" line.

=end original

“ª³“ªÎ“«×“«í“«°“«é“«à“ªÏ "Bar" “ªò“ùß“ªà“ú¼“ªÀ“ª±“ªò“øú“ãÆ“ª·“ªÞ“ª¹“¡£
“Ûô’°Ï“æÑ“ß©“í­“ªò C<...> “ªË’ÊÑ“ÌÚ“ª¹“ªë“ªÈ“¡¢"Baz" “ªÎ“ú¼“ªâ“øú“ãÆ“ª·“ªÞ“ª¹“¡£

=begin original

And now some examples as a list operator:

=end original

“ª³“ªì“ªÏ“«ê“«¹“«È“æÑ“ß©“í­“ªÎ“ÖÇ“ªÇ“ª¹:

    for (101 .. 200) { print; }	# print $_ 100 times
    @foo = @foo[0 .. $#foo];	# an expensive no-op
    @foo = @foo[$#foo-4 .. $#foo];	# slice last 5 items

=begin original

The range operator (in list context) makes use of the magical
auto-increment algorithm if the operands are strings.  You
can say

=end original

(“«ê“«¹“«È“«³“«ó“«Æ“«­“«¹“«È“ªÇ“ªÎ) “Ûô’°Ï“æÑ“ß©“í­“ªÏ“¡¢“ù¬“æÑ“ß©“í­“ª¬“Ùþ“í®“Öª“ªÇ“ª¢“ªë“ªÈ“ª­“ªË“ªÏ“¡¢
“«Þ“«¸“««“«ë“«¤“«ó“«¯“«ê“«á“«ó“«È“ªÎ“Ñ¦“Òö“ªò“ÞÅ“ª¤“ªÞ“ª¹“¡£
“ì¤“ù»“ªÎ“ªè“ª¦“ªË“ßö“ª¯“ªÈ:

    @alphabet = ('A' .. 'Z');

=begin original

to get all normal letters of the English alphabet, or

=end original

“çÈ“åÞ“ªÎ“ÓÞ“Ùþ“í®“ª¹“ªÙ“ªÆ“ªò“Ôð“ªé“ªì“ªÞ“ª¹“ª·:

    $hexdigit = (0 .. 9, 'a' .. 'f')[$num & 15];

=begin original

to get a hexadecimal digit, or

=end original

“ªÈ“ßö“ª±“ªÐ“¡¢16 “òä“ªÎ‘Êý“í®“ª¬“Ôð“ªé“ªì“ªÞ“ª¹“ª·“¡¢

    @z2 = ('01' .. '31');  print $z2[$mday];

=begin original

to get dates with leading zeros.

=end original

“ªÈ“ª¹“ªì“ªÐ“¡¢0 “Üõ“ª­“ªÎ“ìí“Üõ“ª¬“Ôð“ªé“ªì“ªÞ“ª¹“¡£

=begin original

If the final value specified is not in the sequence that the magical
increment would produce, the sequence goes until the next value would
be longer than the final value specified.

=end original

“«Þ“«¸“««“«ë“«¤“«ó“«¯“«ê“«á“«ó“«È“ªË“ªè“ªÃ“ªÆ“Ôð“ªé“ªì“ªë“ö·“ªÎ“ñé“ªË“ò¦“ïÒ“ª·“ª¿“õÌ“ðû“ö·“ªË
“ªÁ“ªç“ª¦“ªÉ“ìé“öÈ“ª¹“ªë“ªâ“ªÎ“ª¬“Ì¸“ªÄ“ª«“ªé“ªÊ“ª¤“ªè“ª¦“ªÊ“íÞ“ùê“ªË“ªÏ“¡¢
“«Þ“«¸“««“«ë“«¤“«ó“«¯“«ê“«á“«ó“«È“ªË“ªè“ªÃ“ªÆ“Ôð“ªé“ªì“ªë“ó­“ªÎ“ö·“ªÎ“Ùþ“í®“Öª“íþ“ª¬“¡¢
“õÌ“ðû“ö·“ªÈ“ª·“ªÆ“ò¦“ïÒ“ª·“ª¿“ö·“ªÎ“ªâ“ªÎ“ªè“ªê“íþ“ª¯“ªÊ“ªë“ªÞ“ªÇ“«¤“«ó“«¯“«ê“«á“«ó“«È“ª¬’Â³“ª±“ªé“ªì“ªÞ“ª¹“¡£

=begin original

If the initial value specified isn't part of a magical increment
sequence (that is, a non-empty string matching "/^[a-zA-Z]*[0-9]*\z/"),
only the initial value will be returned.  So the following will only
return an alpha:

=end original

If the initial value specified isn't part of a magical increment
sequence (that is, a non-empty string matching "/^[a-zA-Z]*[0-9]*\z/"),
only the initial value will be returned.  So the following will only
return an alpha:
(TBT)

    use charnames 'greek';
    my @greek_small =  ("\N{alpha}" .. "\N{omega}");

=begin original

To get lower-case greek letters, use this instead:

=end original

“á³“Ùþ“í®“ªÎ“«®“«ê“«·“«ã“Ùþ“í®“ªò“Ôð“ªë“ª¿“ªá“ªË“ªÏ“¡¢“ÓÛ“ªï“ªê“ªË“ì¤“ù»“ªÎ“ªè“ª¦“ªË“ª·“ªÆ“ª¯“ªÀ“ªµ“ª¤:

    my @greek_small =  map { chr } ( ord("\N{alpha}") .. ord("\N{omega}") );

=begin original

Because each operand is evaluated in integer form, C<2.18 .. 3.14> will
return two elements in list context.

=end original

“ª½“ªì“ª¾“ªì“ªÎ“«ª“«Ú“«é“«ó“«É“ªÏ“ïÚ‘Êý“ªÎ“û¡“ªÇ“øÄ’²Á“ªµ“ªì“ªë“ªÎ“ªÇ“¡¢C<2.18 .. 3.14> “ªÏ
“«ê“«¹“«È“«³“«ó“«Æ“«­“«¹“«È“ªÇ“ªÏ“ì£“ªÄ“ªÎ“é©“áÈ“ªò“Ú÷“ª·“ªÞ“ª¹“¡£

    @list = (2.18 .. 3.14); # same as @list = (2 .. 3);

=head2 Conditional Operator
X<operator, conditional> X<operator, ternary> X<ternary> X<?:>

(‘Ìõ“Ëì“æÑ“ß©“í­)

=begin original

Ternary "?:" is the conditional operator, just as in C.  It works much
like an if-then-else.  If the argument before the ? is true, the
argument before the : is returned, otherwise the argument after the :
is returned.  For example:

=end original

“ß²“ú£“æÑ“ß©“í­“ªÎ "?:" “ªÏ“¡¢C “ªÎ“íÞ“ùê“ªÈ“ÔÒ“ª¸‘Ìõ“Ëì“æÑ“ß©“í­“ªÇ“ª¹“¡£
“ª³“ªì“ªÏ“¡¢if-then-else “ªÎ“ªè“ª¦“ªË’Æ¯“ª­“ªÞ“ª¹“¡£
"?" “ªÎ“îñ“ªÎ“ìÚ‘Êý“ª¬‘Õæ“ªÇ“ª¢“ªì“ªÐ ":" “ªÎ“îñ“ªÎ“ìÚ‘Êý“ª¬“Ú÷“ªµ“ªì“ªÞ“ª¹“ª¬“¡¢
‘Õæ“ªÇ“ªÊ“ª±“ªì“ªÐ“¡¢":" “ªÎ“ý­“ªÎ“ìÚ‘Êý“ª¬“Ú÷“ªµ“ªì“ªÞ“ª¹“¡£“ÖÇ:

    printf "I have %d dog%s.\n", $n,
	    ($n == 1) ? '' : "s";

=begin original

Scalar or list context propagates downward into the 2nd
or 3rd argument, whichever is selected.

=end original

“«¹“««“«é“«³“«ó“«Æ“«­“«¹“«È“ª«“«ê“«¹“«È“«³“«ó“«Æ“«­“«¹“«È“ª«“ªÈ“ª¤“ª¦‘×´“üÏ“ªÏ“¡¢
“àÔ’Âò“ªµ“ªì“ª¿ 2 “Ûã“ÙÍ“ªâ“ª·“ª¯“ªÏ 3 “Ûã“ÙÍ“ªÎ“ìÚ‘Êý“ªË“ªÞ“ªÇ™¡ó“ªï“ªê“ªÞ“ª¹“¡£

    $a = $ok ? $b : $c;  # get a scalar
    @a = $ok ? @b : @c;  # get an array
    $a = $ok ? @b : @c;  # oops, that's just a count!

=begin original

The operator may be assigned to if both the 2nd and 3rd arguments are
legal lvalues (meaning that you can assign to them):

=end original

2 “Ûã“ÙÍ“ªÈ 3 “Ûã“ÙÍ“ªÎ“ìÚ‘Êý‘Ë«“Û°“ª¬“ñ§’ÊÕ“ö· (“ÓÛ“ìý“Ê¦“Òö“ªÈ“ª¤“ª¦“ª³“ªÈ)“ªÇ“ª¢“ªì“ªÐ“¡¢
“ª³“ªÎ“æÑ“ß©“í­“ªË“ÓÛ“ìý“ªò“ú¼“ªÊ“ª¦“ª³“ªÈ“ªâ“ªÇ“ª­“ªÞ“ª¹:

    ($a_or_b ? $a : $b) = $c;

=begin original

Because this operator produces an assignable result, using assignments
without parentheses will get you in trouble.  For example, this:

=end original

“ª³“ªÎ“æÑ“ß©“í­“ªÏ“ÓÛ“ìý“Ê¦“Òö“ªÊ“Ì¿“Íý“ªò“ßæ“ªß“õó“ª¹“ªÎ“ªÇ“¡¢
“ÎÀ“ûÁ“ªÊ“ª·“ªÇ“ÓÛ“ìý“ªò“ú¼“ª¦“ªÈ“ªª“ª«“ª·“ª¯“ªÊ“ªë“ª«“ªâ“ª·“ªì“ªÞ“ª»“ªó“¡£“ÖÇ“ª¨“ªÐ:

    $a % 2 ? $a += 10 : $a += 2

=begin original

Really means this:

=end original

“ªÏ“ì¤“ù»“ªò“ëò“Ú«“ª·:

    (($a % 2) ? ($a += 10) : $a) += 2

=begin original

Rather than this:

=end original

“ì¤“ù»“ªÎ“ªè“ª¦“ªË“ªÏ“ªÊ“ªê“ªÞ“ª»“ªó:

    ($a % 2) ? ($a += 10) : ($a += 2)

=begin original

That should probably be written more simply as:

=end original

“Íð“ªé“ª¯“ì¤“ù»“ªÎ“ªè“ª¦“ªË“ªâ“ªÃ“ªÈ’Ã±“âí“ªË“ßö“ª¯“ªÙ“ª­“ªÇ“ª·“ªç“ª¦:

    $a += ($a % 2) ? 10 : 2;

=head2 Assignment Operators
X<assignment> X<operator, assignment> X<=> X<**=> X<+=> X<*=> X<&=>
X<<< <<= >>> X<&&=> X<-=> X</=> X<|=> X<<< >>= >>> X<||=> X<//=> X<.=>
X<%=> X<^=> X<x=>

(“ÓÛ“ìý“æÑ“ß©“í­)

=begin original

"=" is the ordinary assignment operator.

=end original

"=" “ªÏ“÷×“ßÈ“ªÎ“ÓÛ“ìý“æÑ“ß©“í­“ªÇ“ª¹“¡£

=begin original

Assignment operators work as in C.  That is,

=end original

“ÓÛ“ìý“æÑ“ß©“í­“ªÏ C “ªÎ“íÞ“ùê“ªÈ“ÔÒ’ÍÍ“ªÎ’Æ¯“ª­“ªò“ª·“ªÞ“ª¹“¡£“ªÄ“ªÞ“ªê“¡¢

    $a += 2;

=begin original

is equivalent to

=end original

“ªÏ“ì¤“ù»“ªÈ“Ôõ’²Á“ªÇ“ª¹“¡£

    $a = $a + 2;

=begin original

although without duplicating any side effects that dereferencing the lvalue
might trigger, such as from tie().  Other assignment operators work similarly.
The following are recognized:

=end original

“ª·“ª«“ª·“¡¢tie() “ªÎ“ªè“ª¦“ªÊ“ªâ“ªÎ“ªÇ“ÑÃ“ª³“ªë“ñ§’ÊÕ“ö·“ªÎ“ù¬‘²Î“ðÎ“ªË“ªè“ªë
“Üù“íÂ“éÄ“ª¬ 2 “üÞ“ÑÃ“ª³“ªë“ª³“ªÈ“ªÏ“ª¢“ªê“ªÞ“ª»“ªó“¡£
“öâ“ªÎ“ÓÛ“ìý“æÑ“ß©“ªâ“ÔÒ’ÍÍ“ªË’Æ¯“ª­“ªÞ“ª¹“¡£“ì¤“ù»“ªÎ“ªâ“ªÎ“ª¬“ìã“ãÛ“ªµ“ªì“ªÞ“ª¹:

    **=    +=    *=    &=    <<=    &&=
           -=    /=    |=    >>=    ||=
           .=    %=    ^=           //=
                 x=

=begin original

Although these are grouped by family, they all have the precedence
of assignment.

=end original

“«°“«ë’¡¼“«×“ÝÂ“ª±“ª·“ªÆ“ª¢“ªê“ªÞ“ª¹“ª¬“¡¢“ª³“ªì“ªé“ªÏ“ª¤“ªº“ªì“ªâ“ÓÛ“ìý“æÑ“ß©“í­“ªÈ“ª·“ªÆ
“ÔÒ“ª¸“éÐ“à»“â÷“êÈ“ªÈ“ªÊ“ªÃ“ªÆ“ª¤“ªÞ“ª¹“¡£

=begin original

Unlike in C, the scalar assignment operator produces a valid lvalue.
Modifying an assignment is equivalent to doing the assignment and
then modifying the variable that was assigned to.  This is useful
for modifying a copy of something, like this:

=end original

C “ªÈ“êÞ“ªÃ“ªÆ“¡¢“«¹“««“«é“ÓÛ“ìý“æÑ“ß©“í­“ªÏ“êó’¸ú“ªÊ“ñ§’ÊÕ“ö·“ªò“íÂ“ªê“õó“ª·“ªÞ“ª¹“¡£
“ÓÛ“ìý“ªò“áó“ïá“ª¹“ªë“ª³“ªÈ“ªÏ“¡¢“ÓÛ“ìý“ªò“ú¼“ªÊ“ªÃ“ªÆ“ª«“ªé“¡¢“ª½“ªÎ“ÓÛ“ìý“ªµ“ªì“ª¿’ÊÑ‘Êý“ªò“áó“ïá“ª¹“ªë“ªÎ“ªÈ
“ÔÒ“ª¸“ª³“ªÈ“ªË“ªÊ“ªê“ªÞ“ª¹“¡£
“ª³“ªì“ªÏ“¡¢“ì¤“ù»“ªÎ“ªè“ª¦“ªË“ù¼“ª«“ªÎ“«³“«Ô’¡¼“ªò’ÊÑ“ÌÚ“ª·“ª¿“ª¤“ªÈ“ª­“ªË“øµ“××“ªÇ“ª¹:

    ($tmp = $global) =~ tr [A-Z] [a-z];

=begin original

Likewise,

=end original

“ÔÒ’ÍÍ“ªË“¡¢

    ($a += 2) *= 3;

=begin original

is equivalent to

=end original

“ªÏ“ì¤“ù»“ªÈ“ÔÒ“Ôõ“ªÇ“ª¹“¡£

    $a += 2;
    $a *= 3;

=begin original

Similarly, a list assignment in list context produces the list of
lvalues assigned to, and a list assignment in scalar context returns
the number of elements produced by the expression on the right hand
side of the assignment.

=end original

“ÔÒ’ÍÍ“ªË“¡¢“«ê“«¹“«È“«³“«ó“«Æ“«­“«¹“«È“ªÇ“ªÎ“«ê“«¹“«È“ªØ“ªÎ“ÓÛ“ìý“ªÏ“ÓÛ“ìý“Ê¦“Òö“ªÊ“ñ§’ÊÕ“ö·“ªÎ“«ê“«¹“«È“ªÈ“ªÊ“ªê“¡¢
“«¹“««“«é“«³“«ó“«Æ“«­“«¹“«È“ªÇ“ªÎ“«ê“«¹“«È“ªØ“ªÎ“ÓÛ“ìý“ªÏ“ÓÛ“ìý“ªÎ“éÓ“ö°“ªÎ“ãÒ“ªÇ“íÂ“à÷“ªµ“ªì“ª¿
“é©“áÈ“ªÎ‘Êý“ªò“Ú÷“ª·“ªÞ“ª¹“¡£

=head2 Comma Operator
X<comma> X<operator, comma> X<,>

(“«³“«ó“«Þ“æÑ“ß©“í­)

=begin original

Binary "," is the comma operator.  In scalar context it evaluates
its left argument, throws that value away, then evaluates its right
argument and returns that value.  This is just like C's comma operator.

=end original

“ì£“ú£“æÑ“ß©“í­“ªÎ "," “ªÏ“«³“«ó“«Þ“æÑ“ß©“í­“ªÇ“ª¹“¡£
“«¹“««“«é“«³“«ó“«Æ“«­“«¹“«È“ªÇ“ªÏ“ª½“ªÎ“ñ§“ìÚ‘Êý“ªò“øÄ’²Á“ª·“¡¢“ª½“ªÎ“ö·“ªò“Þ×“ªÆ“ªÆ“¡¢
“ª½“ªì“ª«“ªé“éÓ“ìÚ‘Êý“ªò“øÄ’²Á“ª·“¡¢“ª½“ªÎ“ö·“ªò“Ú÷“ª·“ªÞ“ª¹“¡£
“ª³“ªì“ªÏ“ªÁ“ªç“ª¦“ªÉ“¡¢C “ªÎ“«³“«ó“«Þ“æÑ“ß©“í­“ªÈ“ÔÒ“ª¸“ªÇ“ª¹“¡£

=begin original

In list context, it's just the list argument separator, and inserts
both its arguments into the list.  These arguments are also evaluated
from left to right.

=end original

“«ê“«¹“«È“«³“«ó“«Æ“«­“«¹“«È“ªÇ“ªÏ“¡¢“ª³“ªì“ªÏ’Ã±“ªË“«ê“«¹“«È“ìÚ‘Êý“ªÎ‘Çø“ï·“ªê“Ùþ“í®“ªÇ“¡¢
‘Ë«“Û°“ªÎ“ìÚ‘Êý“ªò“ª½“ªÎ“«ê“«¹“«È“ªË’ÁÞ“ìý“ª¹“ªë’Æ¯“ª­“ª¬“ª¢“ªê“ªÞ“ª¹“¡£
“ª³“ªì“ªé“ªÎ“ìÚ‘Êý“ªâ“éÓ“ª«“ªé“ñ§“ªË“øÄ’²Á“ªµ“ªì“ªÞ“ª¹“¡£

=begin original

The C<< => >> operator is a synonym for the comma, but forces any word
(consisting entirely of word characters) to its left to be interpreted
as a string (as of 5.001).  This includes words that might otherwise be
considered a constant or function call.

=end original

C<< => >> “æÑ“ß©“í­“ªÏ“«³“«ó“«Þ“æÑ“ß©“í­“ªÎ“ÔÒ“ëù“åÞ“ªÇ“ª¹“ª¬“¡¢(5.001 “ì¤“Ë½)“ñ§’ÊÕ“ö·“ªÎ’Ã±“åÞ
(’Ã±“åÞ“Ùþ“í®“ªÇ“Ï°“à÷“ªµ“ªì“ªë“îï‘Ìå)“ªò“ù±“ªº“Ùþ“í®“Öª“ªÈ“ª·“ªÆ“Ðâ“ª¦“ªÈ“ª¤“ª¦’¸ú“Íý“ªâ“ª¢“ªê“ªÞ“ª¹“¡£
“ª³“ªì“ªË“ªÏ“öâ“ªÎ“íÞ“á¶“ªÇ“ªÏ“ïÒ‘Êý“ªä’´Ø‘Êý“û¼“ªÓ“õó“ª·“ªÈ“ª·“ªÆ“Ðâ“ªï“ªì“ªë’Ã±“åÞ“ªò“ùß“ªß“ªÞ“ª¹“¡£

    use constant FOO => "something";

    my %h = ( FOO => 23 );

=begin original

is equivalent to:

=end original

“ªÏ“¡¢“ì¤“ù»“ªÈ“Ôõ’²Á“ªÇ“ª¹:

    my %h = ("FOO", 23);

=begin original

It is I<NOT>:

=end original

“ª³“ªì“ªÏ I<“êÞ“ª¤“ªÞ“ª¹>:

    my %h = ("something", 23);

=begin original

If the argument on the left is not a word, it is first interpreted as
an expression, and then the string value of that is used.

=end original

“ñ§“ö°“ªÎ“ìÚ‘Êý“ª¬’Ã±“åÞ“ªÇ“ªÊ“ª«“ªÃ“ª¿“íÞ“ùê“¡¢“ªÞ“ªº“ªÏ“ãÒ“ªÈ“ª·“ªÆ“ú°’¼á“ªµ“ªì“¡¢“ª½“ªì“ª«“ªé
“ª½“ªì“ªò“ÞÅ“ªÃ“ª¿“Ùþ“í®“Öª“ö·“ªÈ“ª·“ªÆ“ú°’¼á“ªµ“ªì“ªÞ“ª¹“¡£

=begin original

The C<< => >> operator is helpful in documenting the correspondence
between keys and values in hashes, and other paired elements in lists.

=end original

C<< => >> “æÑ“ß©“í­“ªÏ“¡¢“«Ï“«Ã“«·“«å“ªÎ“«­’¡¼“ªÈ“ö·“ªä“¡¢“ª½“ªÎ“öâ“ªÎ“«ê“«¹“«È“ñé“ªÎ“ðÚ“ªÈ“ªÊ“ªë
“é©“áÈ“ªÎ’´Ø“Ìõ“ªò“øú“úÞ“ª¹“ªë“ªÎ“ªË“øµ“××“ªÇ“ª¹“¡£

        %hash = ( $key => $value );
        login( $username => $password );

=head2 List Operators (Rightward)
X<operator, list, rightward> X<list operator>

(“«ê“«¹“«È“æÑ“ß©“í­ (“éÓ“Û°“ú¾))

=begin original

On the right side of a list operator, it has very low precedence,
such that it controls all comma-separated expressions found there.
The only operators with lower precedence are the logical operators
"and", "or", and "not", which may be used to evaluate calls to list
operators without the need for extra parentheses:

=end original

“«ê“«¹“«È“æÑ“ß©“í­“ªÎ“éÓ“ö°“ªÎ“ªâ“ªÎ“ªË“ªÈ“ªÃ“ªÆ“¡¢“«ê“«¹“«È“æÑ“ß©“í­“ªÏ“ªÈ“ªÆ“ªâ“î¸“ª¤“éÐ“à»“â÷“êÈ“ªË“ªÊ“ªê“ªÞ“ª¹“¡£
“ª³“ªì“ªË“ªè“ªÃ“ªÆ“«³“«ó“«Þ“ªÇ‘Çø“ï·“ªÃ“ª¿“ãÒ“ªò“«ê“«¹“«È“æÑ“ß©“í­“ªÎ“ìÚ‘Êý“ªÈ“ª·“ªÆ
“öÇ“ª¯“ª³“ªÈ“ª¬“ªÇ“ª­“ªÞ“ª¹“¡£
“ª³“ªì“ªè“ªê“ªâ“éÐ“à»“â÷“êÈ“ª¬“î¸“ª¤“ªâ“ªÎ“ªÏ“¡¢“Öå“×â“æÑ“ß©“í­“ªÎ "and", "or", "not" “ªÎ“ªß“ªÇ“¡¢
“åù“ÝÂ“ªÊ“ÎÀ“ûÁ“ªò“Üõ“ª±“ªÊ“ª¤“«ê“«¹“«È“æÑ“ß©“í­“ªÎ“û¼“ªÓ“õó“ª·“ªò“øÄ’²Á“ª¹“ªë“ª¿“ªá“ªË“ÞÅ“ª¦“ª³“ªÈ“ª¬“ªÇ“ª­“ªÞ“ª¹:

    open HANDLE, "filename"
	or die "Can't open: $!\n";

=begin original

See also discussion of list operators in L<Terms and List Operators (Leftward)>.

=end original

L<Terms and List Operators (Leftward)> “ªÎ“«ê“«¹“«È“æÑ“ß©“í­“ªÎ“ì¡“Öå“ªâ‘²Î“ðÎ“ª·“ªÆ“ù»“ªµ“ª¤“¡£

=head2 Logical Not
X<operator, logical, not> X<not>

(“Öå“×â“Üú“ïÒ)

=begin original

Unary "not" returns the logical negation of the expression to its right.
It's the equivalent of "!" except for the very low precedence.

=end original

’Ã±“ú£“æÑ“ß©“í­“ªÎ "not" “ªÏ“éÓ“ö°“ªË‘À´“ªë“ãÒ“ªÎ“Üú“ïÒ“ªò“Ú÷“ª·“ªÞ“ª¹“¡£
“ª³“ªì“ªÏ“¡¢“éÐ“à»“â÷“êÈ“ª¬“ªº“ªÃ“ªÈ“î¸“ª¤“ª³“ªÈ“ªò“ð¶“ª¤“ªÆ“ªÏ "!" “ªÈ“Ôõ’²Á“ªÇ“ª¹“¡£

=head2 Logical And
X<operator, logical, and> X<and>

(“Öå“×â“îÝ)

=begin original

Binary "and" returns the logical conjunction of the two surrounding
expressions.  It's equivalent to && except for the very low
precedence.  This means that it short-circuits: i.e., the right
expression is evaluated only if the left expression is true.

=end original

“ì£“ú£“æÑ“ß©“í­“ªÎ "and" “ªÏ’Î¾“ö°“ªÎ“ãÒ“ªÎ“Öå“×â“îÝ“ªò“Ú÷“ª·“ªÞ“ª¹“¡£
“ª³“ªì“ªÏ“¡¢“éÐ“à»“â÷“êÈ“ª¬“ªº“ªÃ“ªÈ“î¸“ª¤“ª³“ªÈ“ªò“ð¶“ª±“ªÐ && “ªÈ“Ôõ’²Á“ªÇ“ª¹“¡£
“ªÄ“ªÞ“ªê“¡¢“ª³“ªì“ªâ“Ó­“Õ©“æÑ“ß©“ªò“ú¼“ªÊ“ª¤“¡¢“éÓ“ö°“ªÎ“ãÒ“ªÏ“ñ§“ö°“ªÎ“ãÒ“ª¬
“¡¸‘Õæ“¡¹“ªÇ“ª¢“ªÃ“ª¿“íÞ“ùê“ªË“ªÎ“ªß“øÄ’²Á“ªµ“ªì“ªÞ“ª¹“¡£

=head2 Logical or, Defined or, and Exclusive Or
X<operator, logical, or> X<operator, logical, xor>
X<operator, logical, defined or> X<operator, logical, exclusive or>
X<or> X<xor>

(“Öå“×â“ûú“ªÈ“ïÒ“ëù“àõ“ûú“ªÈ“ÛÉ“öâ“Öå“×â“ûú)

=begin original

Binary "or" returns the logical disjunction of the two surrounding
expressions.  It's equivalent to || except for the very low precedence.
This makes it useful for control flow

=end original

“ì£“ú£“æÑ“ß©“í­“ªÎ "or" “ªÏ’Î¾“ö°“ªÎ“ãÒ“ªÎ“Öå“×â“ûú“ªò“Ú÷“ª·“ªÞ“ª¹“¡£
“ª³“ªì“ªÏ“¡¢“éÐ“à»“â÷“êÈ“ª¬“ªº“ªÃ“ªÈ“î¸“ª¤“ª³“ªÈ“ªò“ð¶“ª¤“ªÆ || “ªÈ“Ôõ’²Á“ªÇ“ª¹“¡£
“ª³“ªì“ªÏ“«Õ“«í’¡¼“ªò“ð¤“åÙ“ª¹“ªë“ªÎ“ªË“êó“éÄ“ªÇ“ª¹:

    print FH $data		or die "Can't write to FH: $!";

=begin original

This means that it short-circuits: i.e., the right expression is evaluated
only if the left expression is false.  Due to its precedence, you should
probably avoid using this for assignment, only for control flow.

=end original

“ªÄ“ªÞ“ªê“¡¢“ª³“ªì“ªâ“Ó­“Õ©“æÑ“ß©“ªò“ú¼“ªÊ“ª¤“¡¢“éÓ“ö°“ªÎ“ãÒ“ªÏ“ñ§“ö°“ªÎ“ãÒ“ª¬
“¡¸˜ºô“¡¹“ªÇ“ª¢“ªÃ“ª¿“íÞ“ùê“ªË“ªÎ“ªß“øÄ’²Á“ªµ“ªì“ªÞ“ª¹“¡£
“éÐ“à»“Óø“ªÎ’´Ø“Ìõ“ªÇ“¡¢“ª³“ªì“ªÏ“ÓÛ“ìý“ªË“ªÏ“ÞÅ“ªï“ªº“¡¢“«Õ“«í’¡¼“ªÎ“ð¤“åÙ“ªÎ“ªß“ªË“ÞÅ“ª¦“ªÙ“ª­“ªÇ“ª¹“¡£

    $a = $b or $c;		# bug: this is wrong
    ($a = $b) or $c;		# really means this
    $a = $b || $c;		# better written this way

=begin original

However, when it's a list-context assignment and you're trying to use
"||" for control flow, you probably need "or" so that the assignment
takes higher precedence.

=end original

“ª·“ª«“ª·“¡¢“ÓÛ“ìý“ª¬“«ê“«¹“«È“«³“«ó“«Æ“«­“«¹“«È“ªÎ“ãÁ“ªË "||" “ªò“«Õ“«í’¡¼“ð¤“åÙ“ªË“ÞÅ“ªª“ª¦“ªÈ“ª¹“ªë“íÞ“ùê“¡¢
“ÓÛ“ìý“ªË“ªè“ªê“ÓÞ“ª­“ªÊ“éÐ“à»“â÷“êÈ“ªò“ò¥“ª¿“ª»“ªë“ª¿“ªá“ªË "or" “ª¬“ù±“é©“ª«“ªâ“ª·“ªì“ªÞ“ª»“ªó“¡£

    @info = stat($file) || die;     # oops, scalar sense of stat!
    @info = stat($file) or die;     # better, now @info gets its due

=begin original

Then again, you could always use parentheses.

=end original

“ªâ“ªÁ“ªí“ªó“¡¢“ßÈ“ªË“ÎÀ“ûÁ“ªò“ªÄ“ª±“ªÆ“ªâ“ªè“ª¤“ªÇ“ª¹“¡£

=begin original

Binary "xor" returns the exclusive-OR of the two surrounding expressions.
It cannot short circuit, of course.

=end original

“ì£“ú£“æÑ“ß©“í­“ªÎ "xor" “ªÏ’Î¾“ö°“ªÎ“ãÒ“ªÎ“ÛÉ“öâ“Öå“×â“ûú“ªò“Ú÷“ª·“ªÞ“ª¹“¡£
“ª³“ªì“ªÏ“ªâ“ªÁ“ªí“ªó“¡¢“Ó­“Õ©“ªÇ“ªÏ“ª¢“ªê“ªÞ“ª»“ªó“¡£

=head2 C Operators Missing From Perl
X<operator, missing from perl> X<&> X<*>
X<typecasting> X<(TYPE)>

(Perl “ªË“ªÊ“ª¤ C “ªÎ“æÑ“ß©“í­)

=begin original

Here is what C has that Perl doesn't:

=end original

C “ªË“ª¢“ªÃ“ªÆ Perl “ªË“Ùí“ª¤“ªâ“ªÎ“ªÏ“ì¤“ù»“ªÎ“÷×“ªê“ªÇ“ª¹:

=over 8

=item unary &

=begin original

Address-of operator.  (But see the "\" operator for taking a reference.)

=end original

“«¢“«É“«ì“«¹“æÑ“ß©“í­“¡£
("\" “æÑ“ß©“í­“ª¬“«ê“«Õ“«¡“«ì“«ó“«¹“ªÎ“ª¿“ªá“ªË“éÄ“ª¤“ªé“ªì“ªÞ“ª¹“¡£)

=item unary *

=begin original

Dereference-address operator. (Perl's prefix dereferencing
operators are typed: $, @, %, and &.)

=end original

“ù¬“«¢“«É“«ì“«¹‘²Î“ðÎ“æÑ“ß©“í­“¡£
(Perl “ªÎ“ù¬‘²Î“ðÎ“«×“«ê“«Õ“«£“«¯“«¹“æÑ“ß©“í­“ª¬“úþ“ªÅ“ª±“ªò“ú¼“ªÊ“ª¤“ªÞ“ª¹: $, @, %, &“¡£)

=item (TYPE)

=begin original

Type-casting operator.

=end original

“úþ“ªÎ“«­“«ã“«¹“«È“æÑ“ß©“í­“¡£

=back

=head2 Quote and Quote-like Operators
X<operator, quote> X<operator, quote-like> X<q> X<qq> X<qx> X<qw> X<m>
X<qr> X<s> X<tr> X<'> X<''> X<"> X<""> X<//> X<`> X<``> X<<< << >>>
X<escape sequence> X<escape>

(“«¯“«©’¡¼“«È“ªÈ“«¯“«©’¡¼“«È“ù¦“ªÎ“æÑ“ß©“í­)

=begin original

While we usually think of quotes as literal values, in Perl they
function as operators, providing various kinds of interpolating and
pattern matching capabilities.  Perl provides customary quote characters
for these behaviors, but also provides a way for you to choose your
quote character for any of them.  In the following table, a C<{}> represents
any pair of delimiters you choose.

=end original

“«¯“«©’¡¼“«È“ªÏ“«ê“«Æ“«é“«ë“ö·“ªÇ“ª¢“ªë“ªÈ“ÍÅ“ª¨“ªë“ªÎ“ª¬“ÜÅ“÷×“ªÇ“ª¹“ª¬“¡¢Perl “ªË“ªª“ª¤“ªÆ“¡¢
“«¯“«©’¡¼“«È“ªÏ“æÑ“ß©“í­“ªÈ“ª·“ªÆ’Æ¯“ª­“¡¢“ªµ“ªÞ“ª¶“ªÞ“ªÊ“î÷“ËÒ“ªä“«Ñ“«¿’¡¼“«ó“«Þ“«Ã“«Á“ªÎ“Ñ¦“Òö“ªò
“ò¥“ªÃ“ªÆ“ª¤“ªÞ“ª¹“¡£
“ª½“ªÎ“ªè“ª¦“ªÊ“ÔÑ“íÂ“ªò“ªµ“ª»“ªë“ªÎ“ªË“¡¢Perl “ªÏ“Î±“ã§“îÜ“ªË“«¯“«©’¡¼“«È“Ùþ“í®“ªò“ÞÅ“ªÃ“ªÆ“ª¤“ªÞ“ª¹“ª¬“¡¢
“ªÉ“ªÎ“ðú“×¾“ªÎ“«¯“«©’¡¼“«È“ªâ“¡¢“í»“ÝÂ“ªÇ“«¯“«©’¡¼“«È“Ùþ“í®“ªò“àÔ“ªÙ“ªë“ªè“ª¦“ªË“ªÊ“ªÃ“ªÆ“ª¤“ªÞ“ª¹“¡£
“ì¤“ù»“ªÎ“øú“ªÇ“ªÏ“¡¢{} “ª¬“ª½“ªÎ“àÔ“ªó“ªÀ‘Çø“ï·“Ùþ“í®“ªÎ“«Ú“«¢“ªò“ãÆ“ª·“ªÆ“ª¤“ªÞ“ª¹“¡£

=begin original

    Customary  Generic        Meaning	     Interpolates
	''	 q{}	      Literal		  no
	""	qq{}	      Literal		  yes
	``	qx{}	      Command		  yes*
		qw{}	     Word list		  no
	//	 m{}	   Pattern match	  yes*
		qr{}	      Pattern		  yes*
		 s{}{}	    Substitution	  yes*
		tr{}{}	  Transliteration	  no (but see below)
        <<EOF                 here-doc            yes*

	* unless the delimiter is ''.

=end original

     “÷×“ßÈ“ÑÀ“Ûö  “Ûñ“éÄ“ÑÀ“Ûö        “ëò“Ú«             “î÷“ËÒ
    =================================================
	''	 q{}	     “«ê“«Æ“«é“«ë		“Üô“Ê¦
	""	qq{}	     “«ê“«Æ“«é“«ë		“Ê¦
	``	qx{}	     “«³“«Þ“«ó“«É		“Ê¦ *
		qw{}	     ’Ã±“åÞ“«ê“«¹“«È		“Üô“Ê¦
	//	 m{}	  “«Ñ“«¿’¡¼“«ó“«Þ“«Ã“«Á	“Ê¦ *
		qr{}	     “«Ñ“«¿’¡¼“«ó		“Ê¦ *
		 s{}{}	       “öÇ“üµ		“Ê¦ *
		tr{}{}	       ’ÊÑ“üµ		“Üô“Ê¦ (“Ó£“ª·“ì¤“ù»“ªò‘²Î“ðÎ“ªÎ“ª³“ªÈ)
        <<EOF            “«Ò“«¢“«É“«­“«å“«á“«ó“«È       “Ê¦ *

	* '' “ª¬“«Ç“«ê“«ß“«¿“ªÇ“ªÊ“ª¤“íÞ“ùê“ªÎ“ªß

=begin original

Non-bracketing delimiters use the same character fore and aft, but the four
sorts of brackets (round, angle, square, curly) will all nest, which means
that

=end original

“àÔ“ªó“ªÀ‘Çø“ï·“Ùþ“í®“ª¬“ÎÀ“ûÁ“ªÎ“×¾“ªÇ“ªÊ“ª¤“íÞ“ùê“ªË“ªÏ“¡¢“îñ“ý­“ªÎ“Ùþ“í®“ªÈ“ª·“ªÆ“ÔÒ“ìé“ªÎ“ªâ“ªÎ“ªò
“ÞÅ“ª¤“ªÞ“ª¹“ª¬“¡¢4 “ªÄ“ªÎ“ÎÀ“ûÁ ((), <>, [], {}) “ªÎ“íÞ“ùê“ªË“ªÏ“«Í“«¹“«È“ªÇ“ª­“ªÞ“ª¹“¡£
“ªÄ“ªÞ“ªê“¡¢“ì¤“ù»“ªÎ“ªâ“ªÎ“ªÏ“¡¢

	q{foo{bar}baz}

=begin original

is the same as

=end original

“ì¤“ù»“ªÈ“ÔÒ“ª¸“ªÇ“ª¹“¡£

	'foo{bar}baz'

=begin original

Note, however, that this does not always work for quoting Perl code:

=end original

“ª·“ª«“ª·“¡¢“ì¤“ù»“ªÎ“«³’¡¼“«É“ªÏ“«¯“«©’¡¼“«È“ªµ“ªì“ª¿ Perl “«³’¡¼“«É“ªÇ“ªÏ
“ª¤“ªÄ“ªâ“ïá“ª·“ª¯“ÔÑ“ª¯“ªï“ª±“ªÇ“ªÏ“ªÊ“ª¤“ª³“ªÈ“ªË“ñ¼“ëò“ª·“ªÆ“ª¯“ªÀ“ªµ“ª¤:

	$s = q{ if($a eq "}") ... }; # WRONG

=begin original

is a syntax error. The C<Text::Balanced> module (from CPAN, and
starting from Perl 5.8 part of the standard distribution) is able
to do this properly.

=end original

“ª³“ªì“ªÏ“Ùþ“Ûö“«¨“«é’¡¼“ªÈ“ªÊ“ªê“ªÞ“ª¹“¡£
C<Text::Balanced> “«â“«¸“«å’¡¼“«ë(CPAN “ª«“ªé“¡¢“ªÞ“ª¿“ªÏ Perl 5.8 “ª«“ªé“ªÏ“øö“ñÞ“ÛÕ“øÖ
“ªÎ“ìé“Ý»“ªÇ“ª¹)“ªÏ“ª³“ªì“ªò“îê“ï·“ªË“ú¼“ª¤“ªÞ“ª¹“¡£

=begin original

There can be whitespace between the operator and the quoting
characters, except when C<#> is being used as the quoting character.
C<q#foo#> is parsed as the string C<foo>, while C<q #foo#> is the
operator C<q> followed by a comment.  Its argument will be taken
from the next line.  This allows you to write:

=end original

“æÑ“ß©“í­“ªÈ“«¯“«©’¡¼“«È“Ùþ“í®“ªÎ“Êà“ªË“Íö“ÛÜ“ªò“öÇ“ª¯“ª³“ªÈ“ªâ“õó‘À´“ªÞ“ª¹“¡£
“ª¿“ªÀ“ª·“¡¢C<#> “ªò“«¯“«©’¡¼“«È“Ùþ“í®“ªÈ“ª·“ªÆ“ÞÅ“ª¦“íÞ“ùê“ªÏ“ÖÇ“èâ“ªÇ“ª¹“¡£
C<q#foo#> “ªÏ“Ùþ“í®“Öª C<foo> “ªÈ“ª·“ªÆ“«Ñ’¡¼“«¹“ªµ“ªì“ªÞ“ª¹“ª¬“¡¢
C<q #foo#> “ªÏ C<q> “æÑ“ß©“í­“ªÎ“ý­“ªË“«³“«á“«ó“«È“ª¬“ª¢“ªë“ªÈ“ªß“ªÊ“ªµ“ªì“ªÞ“ª¹“¡£
“ª³“ªÎ“ìÚ‘Êý“ªÏ“ó­“ªÎ“ú¼“ª«“ªé“ö¢“ªé“ªì“ªÞ“ª¹“¡£“ªÄ“ªÞ“ªê“¡¢“ì¤“ù»“ªÎ“ªè“ª¦“ªË“ßö“ª±“ªÞ“ª¹:

    s {foo}  # Replace foo
      {bar}  # with bar.

=begin original

The following escape sequences are available in constructs that interpolate
and in transliterations.
X<\t> X<\n> X<\r> X<\f> X<\b> X<\a> X<\e> X<\x> X<\0> X<\c> X<\N>

=end original

“ì¤“ù»“ªÎ“«¨“«¹“«±’¡¼“«×“«·’¡¼“«±“«ó“«¹“ª¬“î÷“ËÒ“ªÈ“Ùþ“í®’ÊÑ“üµ“ªÎ“Ï°“Ùþ“ªÇ“××“éÄ“Ê¦“Òö“ªÇ“ª¹“¡£
X<\t> X<\n> X<\r> X<\f> X<\b> X<\a> X<\e> X<\x> X<\0> X<\c> X<\N>

=begin original

    \t		tab             (HT, TAB)
    \n		newline         (NL)
    \r		return          (CR)
    \f		form feed       (FF)
    \b		backspace       (BS)
    \a		alarm (bell)    (BEL)
    \e		escape          (ESC)
    \033	octal char	(example: ESC)
    \x1b	hex char	(example: ESC)
    \x{263a}	wide hex char	(example: SMILEY)
    \c[		control char    (example: ESC)
    \N{name}	named Unicode character

=end original

    \t          “«¿“«Ö                      (HT, TAB)
    \n          “ËÇ“ú¼                      (NL)
    \r          “ÜÖ’µ¢                      (CR)
    \f          “ËÇ“«Ú’¡¼“«¸                  (FF)
    \b          “«Ð“«Ã“«¯“«¹“«Ú’¡¼“«¹            (BS)
    \a          “«¢“«é’¡¼“«à                  (BEL)
    \e          “«¨“«¹“«±’¡¼“«×                (ESC)
    \033        8 “òä‘Êý“ªÇ“øú“ª·“ª¿“Ùþ“í®        (“ÖÇ: ESC)
    \x1b        16 “òä‘Êý“ªÇ“øú“ª·“ª¿“Ùþ“í®       (“ÖÇ: ESC)
    \x{263a}	16 “òä‘Êý“ªÇ“øú“ª·“ª¿“«ï“«¤“«É“Ùþ“í® (“ÖÇ: SMILEY)
    \c[         “«³“«ó“«È“«í’¡¼“«ë“Ùþ“í®          (“ÖÇ: ESC)
    \N{name}	“Ù£“îñ“ªÄ“ª­ Unicode “Ùþ“í®

=begin original

The character following C<\c> is mapped to some other character by
converting letters to upper case and then (on ASCII systems) by inverting
the 7th bit (0x40). The most interesting range is from '@' to '_'
(0x40 through 0x5F), resulting in a control character from 0x00
through 0x1F. A '?' maps to the DEL character. On EBCDIC systems only
'@', the letters, '[', '\', ']', '^', '_' and '?' will work, resulting
in 0x00 through 0x1F and 0x7F.

=end original

The character following C<\c> is mapped to some other character by
converting letters to upper case and then (on ASCII systems) by inverting
the 7th bit (0x40). The most interesting range is from '@' to '_'
(0x40 through 0x5F), resulting in a control character from 0x00
through 0x1F. A '?' maps to the DEL character. On EBCDIC systems only
'@', the letters, '[', '\', ']', '^', '_' and '?' will work, resulting
in 0x00 through 0x1F and 0x7F.
(TBT)

=begin original

B<NOTE>: Unlike C and other languages, Perl has no \v escape sequence for
the vertical tab (VT - ASCII 11), but you may use C<\ck> or C<\x0b>.

=end original

B<“ñ¼“ëò>: C “ªä“ª½“ªÎ“öâ“ªÎ“åë“åÞ“ªÈ“êÞ“ªÃ“ªÆ“¡¢Perl “ªÏ“á÷“òÁ“«¿“«Ö (VT - ASCII 11) “ªÎ“ª¿“ªá“ªÎ
\v “«¨“«¹“«±’¡¼“«×“«·’¡¼“«±“«ó“«¹“ªÏ“ª¢“ªê“ªÞ“ª»“ªó“ª¬“¡¢C<\ck> “ªÞ“ª¿“ªÏ C<\x0b> “ª¬“ÞÅ“ª¨“ªÞ“ª¹“¡£

=begin original

The following escape sequences are available in constructs that interpolate
but not in transliterations.
X<\l> X<\u> X<\L> X<\U> X<\E> X<\Q>

=end original

“ì¤“ù»“ªÎ“«¨“«¹“«±’¡¼“«×“«·’¡¼“«±“«ó“«¹“ª¬“î÷“ËÒ“ªÈ“Ùþ“í®’ÊÑ“üµ“ªÎ“Ï°“Ùþ“ªÇ“××“éÄ“Ê¦“Òö“ªÇ“ª¹“¡£
X<\l> X<\u> X<\L> X<\U> X<\E> X<\Q>

=begin original

    \l		lowercase next char
    \u		uppercase next char
    \L		lowercase till \E
    \U		uppercase till \E
    \E		end case modification
    \Q		quote non-word characters till \E

=end original

    \l          “ó­“ªÎ“Ùþ“í®“ªò“á³“Ùþ“í®“ªË“ª¹“ªë
    \u          “ó­“ªÎ“Ùþ“í®“ªò“ÓÞ“Ùþ“í®“ªË“ª¹“ªë
    \L          \E “ªÞ“ªÇ“á³“Ùþ“í®“ªË“ª¹“ªë
    \U          \E “ªÞ“ªÇ“ÓÞ“Ùþ“í®“ªË“ª¹“ªë
    \E          ’ÊÑ“ÌÚ“ªÎ“ðû“ªï“ªê
    \Q          \E “ªÞ“ªÇ“Þª’Ã±“åÞ“Ùþ“í®“ªò“«¯“«©’¡¼“«È“ª¹“ªë

=begin original

If C<use locale> is in effect, the case map used by C<\l>, C<\L>,
C<\u> and C<\U> is taken from the current locale.  See L<perllocale>.
If Unicode (for example, C<\N{}> or wide hex characters of 0x100 or
beyond) is being used, the case map used by C<\l>, C<\L>, C<\u> and
C<\U> is as defined by Unicode.  For documentation of C<\N{name}>,
see L<charnames>.

=end original

C<use locale> “ª¬“êó’¸ú“ªÎ“íÞ“ùê“¡¢
C<\l>, C<\L>, C<\u>, C<\U> “ªÇ“ÞÅ“ªï“ªì“ªë“ÓÞ“Ùþ“í®“á³“Ùþ“í®“«Æ’¡¼“«Ö“«ë“ªÏ
“úÞ“î¤“ªÎ“«í“«±’¡¼“«ë“ªÎ“ªâ“ªÎ“ª¬“ÞÅ“ªï“ªì“ªÞ“ª¹“¡£
L<perllocale> “ªò‘²Î“ðÎ“ª·“ªÆ“ù»“ªµ“ª¤“¡£
(“ÖÇ“ª¨“ªÐ“¡¢C<\N{}> “ªä“¡¢0x100 “ì¤“ß¾“ªÎ“«ï“«¤“«É 16 “òä“Ùþ“í®“ªò“ÞÅ“ªÃ“ª¿) Unicode “ª¬
“ÞÅ“ªï“ªì“ªÆ“ª¤“ªë“íÞ“ùê“¡¢C<\l>, C<\L>, C<\u>, C<\U> “ªÇ“ÞÅ“ªï“ªì“ªë“ÓÞ“Ùþ“í®“á³“Ùþ“í®
“«Æ’¡¼“«Ö“«ë“ªÏ Unicode “ªÇ“ïÒ“ëù“ªµ“ªì“ªÆ“ª¤“ªë“ªâ“ªÎ“ªË“ªÊ“ªê“ªÞ“ª¹“¡£
C<\N{name}> “ªÎ“«É“«­“«å“«á“«ó“«È“ªË’´Ø“ª·“ªÆ“ªÏ“¡¢L<charnames> “ªò‘²Î“ðÎ“ª·“ªÆ“ù»“ªµ“ª¤“¡£

=begin original

All systems use the virtual C<"\n"> to represent a line terminator,
called a "newline".  There is no such thing as an unvarying, physical
newline character.  It is only an illusion that the operating system,
device drivers, C libraries, and Perl all conspire to preserve.  Not all
systems read C<"\r"> as ASCII CR and C<"\n"> as ASCII LF.  For example,
on a Mac, these are reversed, and on systems without line terminator,
printing C<"\n"> may emit no actual data.  In general, use C<"\n"> when
you mean a "newline" for your system, but use the literal ASCII when you
need an exact character.  For example, most networking protocols expect
and prefer a CR+LF (C<"\015\012"> or C<"\cM\cJ">) for line terminators,
and although they often accept just C<"\012">, they seldom tolerate just
C<"\015">.  If you get in the habit of using C<"\n"> for networking,
you may be burned some day.
X<newline> X<line terminator> X<eol> X<end of line>
X<\n> X<\r> X<\r\n>

=end original

“îï“ªÆ“ªÎ“«·“«¹“«Æ“«à“ªÇ“ªÏ "newline" “ªÈ“û¼“ªÐ“ªì“ªë“ú¼“Ó®“ØÇ“í­“ªò“øú“úÞ“ª¹“ªë“ª¿“ªá“ªË
’²¾“ßÌ“îÜ“ªÊ C<"\n"> “ª¬“éÄ“ª¤“ªé“ªì“ªÞ“ª¹“¡£
“ÜÅ“ø¼“ªÎ“¡¢“Úª“×â“îÜ“ªÊ "newline" “Ùþ“í®“ªÈ“åë“ª¦“ªâ“ªÎ“ªÏ“ª¢“ªê“ªÞ“ª»“ªó“¡£
“«ª“«Ú“«ì’¡¼“«Æ“«£“«ó“«°“«·“«¹“«Æ“«à“¡¢“«Ç“«Ð“«¤“«¹“«É“«é“«¤“«Ð“¡¢C “«é“«¤“«Ö“«é“«ê“¡¢
Perl “ª¬“îï“ªÆ“úð“Õô“ª·“ªÆ“ÜÁ“ðí“ª·“ªè“ª¦“ªÈ“ª¹“ªë“ªÈ“åë“ª¦“ªÎ“ªÏ’Ã±“ªÊ“ªë“ü³“ßÌ“ªÇ“ª¹“¡£
“îï“ªÆ“ªÎ“«·“«¹“«Æ“«à“ªÇ C<"\r"> “ªò ASCII CR “ªÈ“ª·“ªÆ“¡¢“ªÞ“ª¿ C<"\n"> “ªò
ASCII LF “ªÈ“ª·“ªÆ’ÆÉ“ªß’¹þ“ªà“ªï“ª±“ªÇ“ªÏ“ª¢“ªê“ªÞ“ª»“ªó“¡£
“ÖÇ“ª¨“ªÐ Mac “ªÇ“ªÏ“ª³“ªì“ªé“ªÏ“ÜÁ“ðí“ªµ“ªì“¡¢“ú¼“Ó®“ØÇ“í­“ªÎ“ªÊ“ª¤“«·“«¹“«Æ“«à“ªÇ“ªÏ“¡¢
C<"\n"> “ªò print “ª·“ªÆ“ªâ’¼Â“ð·“ªÎ“«Ç’¡¼“«¿“ªÏ“ù¼“ªâ“õó“Õô“ª·“ªÞ“ª»“ªó“¡£
“ìé“Úõ“ªË“¡¢“«·“«¹“«Æ“«à“ªÇ "newline" “ªò“ëò“Ú«“ª·“ª¿“ª¤“ªÈ“ª­“ªË“ªÏ C<"\n"> “ªò“ÞÅ“ª¤“ªÞ“ª¹“ª¬“¡¢
“ïá“ü¬“ªÊ“Ùþ“í®“ª¬“ù±“é©“ªÊ“íÞ“ùê“ªÏ“«ê“«Æ“«é“«ë“ªÊ ASCII “ªò“ÞÅ“ª¤“ªÞ“ª¹“¡£
“ÖÇ“ª¨“ªÐ“¡¢“ªÛ“ªÈ“ªó“ªÉ“ªÎ“«Í“«Ã“«È“«ï’¡¼“«¯“«×“«í“«È“«³“«ë“ªÇ“ªÏ“ú¼“Ó®“ØÇ“í­“ªÈ“ª·“ªÆ
CR+LF (C<"\015\012"> “ªÞ“ª¿“ªÏ C<"\cM\cJ">) “ªò“åø“ßÌ“ª·“¡¢“ªÞ“ª¿“û¿“ªß“ªÞ“ª¹“ª¬“¡¢
“ª·“ªÐ“ª·“ªÐ C<"\012"> “ªÀ“ª±“ªÇ“ªâ“úÉ“é»“ª·“¡¢“ªµ“ªé“ªË“ãÁ‘¡©“ªÏ C<"\015"> “ªÀ“ª±“ªÇ“ªâ“ìã“ªá“ªÞ“ª¹“¡£
“ªâ“ª·“«Í“«Ã“«È“«ï’¡¼“«¯’´Ø“Ìõ“ªÇ C<"\n"> “ªò“ÞÅ“ª¦“ã§“Î±“ª¬“ªÄ“ª¤“ªÆ“ª¤“ªë“ªÈ“¡¢
“ª¤“ªÄ“ª«“÷Ô“ª¤“ÙÍ“ªò“Ì¸“ªë“ª³“ªÈ“ªË“ªÊ“ªë“ªÇ“ª·“ªç“ª¦“¡£

=begin original

For constructs that do interpolate, variables beginning with "C<$>"
or "C<@>" are interpolated.  Subscripted variables such as C<$a[3]> or
C<< $href->{key}[0] >> are also interpolated, as are array and hash slices.
But method calls such as C<< $obj->meth >> are not.

=end original

“î÷“ËÒ“ª¬“ú¼“ªÊ“ªï“ªì“ªë“Ï°“Ùþ“ªÇ“ªÏ“¡¢"C<$>" “ªä "C<@>" “ªÇ“ã·“ªÞ“ªë’ÊÑ‘Êý“ª¬“î÷“ËÒ“ªµ“ªì“ªÞ“ª¹“¡£
Subscripted variables such as C<$a[3]> or
C<< $href->{key}[0] >> “ªâ“ªÞ“ª¿“ÛÕ“Öª“ªä“«Ï“«Ã“«·“«å“ªÎ“«¹“«é“«¤“«¹“ªÎ“ªè“ª¦“ªË“î÷“ËÒ“ªµ“ªì“ªÞ“ª¹“¡£
“ª·“ª«“ª·“¡¢C<< $obj->meth >> “ªÎ“ªè“ª¦“ªÊ“«á“«½“«Ã“«É“û¼“ªÓ“õó“ª·“ªÏ“î÷“ËÒ“ªµ“ªì“ªÞ“ª»“ªó“¡£

=begin original

Interpolating an array or slice interpolates the elements in order,
separated by the value of C<$">, so is equivalent to interpolating
C<join $", @array>.    "Punctuation" arrays such as C<@*> are only
interpolated if the name is enclosed in braces C<@{*}>, but special
arrays C<@_>, C<@+>, and C<@-> are interpolated, even without braces.

=end original

“ÛÕ“Öª“ªä“«¹“«é“«¤“«¹“ªÎ“î÷“ËÒ“ªÏ“¡¢“é©“áÈ“ªò“â÷“Ûã“ªË“¡¢C<$"> “ªÎ“ö·“ªÇ“ÝÂ“ùÜ“ª·“ªÆ“î÷“ËÒ“ªµ“ªì“ªë“ªÎ“ªÇ“¡¢
C<join $", @array> “ªÎ“î÷“ËÒ“ªÈ“Ôõ’²Á“ªÇ“ª¹“¡£
C<@*> “ªÎ“ªè“ª¦“ªÊ“¡¸“Ï£’ÆÉ“ïÃ“¡¹“ÛÕ“Öª“ªÏ“Ù£“îñ“ª¬ C<@{*}> “ªÎ“ªè“ª¦“ªË“ñé“ª«“ªÃ“ª³“ªÇ’°Ï“ªï“ªì“ªÆ“ª¤“ªë
“íÞ“ùê“ªË“ªÎ“ªß“î÷“ËÒ“ªµ“ªì“ªÞ“ª¹“ª¬“¡¢“÷å“â¨“ÛÕ“Öª C<@_>, C<@+>, C<@-> “ªÏ“ñé“ª«“ªÃ“ª³“ªÊ“ª·“ªÇ“ªâ
“î÷“ËÒ“ªµ“ªì“ªÞ“ª¹“¡£

=begin original

You cannot include a literal C<$> or C<@> within a C<\Q> sequence.
An unescaped C<$> or C<@> interpolates the corresponding variable,
while escaping will cause the literal string C<\$> to be inserted.
You'll need to write something like C<m/\Quser\E\@\Qhost/>.

=end original

C<\Q> “«·’¡¼“«±“«ó“«¹“ªÎ“ñé“ªË“«ê“«Æ“«é“«ë“ªÊ C<$> “ªä C<@> “ªò“ìý“ªì“ªë“ª³“ªÈ“ªÏ“ªÇ“ª­“ªÞ“ª»“ªó“¡£
“«¨“«¹“«±’¡¼“«×“ªµ“ªì“ªÊ“ª¤ C<$> “ªä C<@> “ªÏ’ÂÐ’±þ“ª¹“ªë’ÊÑ‘Êý“ªË’ÊÑ“üµ“ªµ“ªì“ªÞ“ª¹“¡£
“ìé“Û°“¡¢“«¨“«¹“«±’¡¼“«×“ª¹“ªë“ªÈ“¡¢“«ê“«Æ“«é“«ë“ªÊ“Ùþ“í®“Öª C<\$> “ª¬’ÁÞ“ìý“ªµ“ªì“ªÞ“ª¹“¡£
C<m/\Quser\E\@\Qhost/> “ªÊ“ªÉ“ªÈ“ª¤“ª¦“ù¦“ªË“ßö“ª¯“ù±“é©“ª¬“ª¢“ªê“ªÞ“ª¹“¡£

=begin original

Patterns are subject to an additional level of interpretation as a
regular expression.  This is done as a second pass, after variables are
interpolated, so that regular expressions may be incorporated into the
pattern from the variables.  If this is not what you want, use C<\Q> to
interpolate a variable literally.

=end original

“«Ñ“«¿’¡¼“«ó“ªÏ“ªµ“ªé“ªË“¡¢“ïá“Ð®“øú“úÞ“ªÈ“ª·“ªÆ“î÷“ËÒ“ª¬“ú¼“ªÊ“ªï“ªì“ªÞ“ª¹“¡£
“ª³“ªì“ªÏ“¡¢’ÊÑ‘Êý“ª¬“î÷“ËÒ“ªµ“ªì“ª¿“ý­“ªÎ 2 “üÞ“ÙÍ“ªÎ“«Ñ“«¹“ªÇ“ú¼“ªÊ“ªï“ªì“ªë“ªÎ“ªÇ“¡¢
’ÊÑ‘Êý“ªË“ïá“Ð®“øú“úÞ“ªò“ùß“ªá“ªÆ“ªª“ª­“¡¢“«Ñ“«¿’¡¼“«ó“ªÎ“ñé“ªØ“î÷“ËÒ“ª¹“ªë“ª³“ªÈ“ª¬“ªÇ“ª­“ªÞ“ª¹“¡£
“ªâ“ª·“¡¢“ª½“ª¦“ª·“ª¿“ª¯“ªÊ“ª¤“ªÎ“ªÇ“ª¢“ªì“ªÐ“¡¢C<\Q> “ªò“ÞÅ“ª¦“ªÈ’ÊÑ‘Êý“ªÎ‘ÄÚ“é»“ªò“Ùþ“í®“÷×“ªê“ªË
“î÷“ËÒ“ª¹“ªë“ª³“ªÈ“ª¬“ªÇ“ª­“ªÞ“ª¹“¡£

=begin original

Apart from the behavior described above, Perl does not expand
multiple levels of interpolation.  In particular, contrary to the
expectations of shell programmers, back-quotes do I<NOT> interpolate
within double quotes, nor do single quotes impede evaluation of
variables when used within double quotes.

=end original

“ß¾“ÑÀ“ªÎ“òÉ“ªë“Ùñ“ª¤“ªò“ð¶“ª±“ªÐ“¡¢Perl “ªÏ “ÜÜ‘Êý“ªÎ“Ó«“Í­“ªò“ÓÎ“ªó“ªÇ“î÷“ËÒ“ªò“ú¼“ªÊ“ª¤“ªÞ“ª»“ªó“¡£
“÷å“ªË“¡¢“«·“«§“«ë“ªÎ“«×“«í“«°“«é“«Þ“ªÎ“Ñ¢“Óâ“ªÈ“ªÏ“×ê“ÜÙ“ªË“¡¢
“«Ð“«Ã“«¯“«¯“«©’¡¼“«È“ªÏ“«À“«Ö“«ë“«¯“«©’¡¼“«È“ªÎ“ñé“ªÇ“ªÏ“î÷“ËÒ“ªµ“ªì“ªÞ“ª»“ªó“ª·“¡¢“«·“«ó“«°“«ë“«¯“«©’¡¼“«È“ª¬
“«À“«Ö“«ë“«¯“«©’¡¼“«È“ªÎ“ñé“ªÇ“ÞÅ“ªï“ªì“ªÆ“ªâ“¡¢’ÊÑ‘Êý“ªÎ“î÷“ËÒ“ªò“Ûª“ª²“ªë“ª³“ªÈ“ªÏ I<“ª¢“ªê“ªÞ“ª»“ªó>“¡£

=head2 Regexp Quote-Like Operators
X<operator, regexp>

(“ïá“Ð®“øú“úÞ“ªÎ“«¯“«©’¡¼“«È“ù¦“ªÎ“æÑ“ß©“í­)

=begin original

Here are the quote-like operators that apply to pattern
matching and related activities.

=end original

“ì¤“ù»“ªÏ“«Ñ“«¿’¡¼“«ó“«Þ“«Ã“«Á“«ó“«°“ªÈ’´Ø“Ö§“ª¹“ªë“ú¼“ÔÑ“ªË’´Ø“ª¹“ªë“«¯“«©’¡¼“«È“ù¦“ªÎ“æÑ“ß©“í­“ªÇ“ª¹“¡£

=over 8

=item qr/STRING/msixpo
X<qr> X</i> X</m> X</o> X</s> X</x> X</p>

=begin original

This operator quotes (and possibly compiles) its I<STRING> as a regular
expression.  I<STRING> is interpolated the same way as I<PATTERN>
in C<m/PATTERN/>.  If "'" is used as the delimiter, no interpolation
is done.  Returns a Perl value which may be used instead of the
corresponding C</STRING/msixpo> expression. The returned value is a
normalized version of the original pattern. It magically differs from
a string containing the same characters: C<ref(qr/x/)> returns "Regexp",
even though dereferencing the result returns undef.

=end original

“ª³“ªÎ“æÑ“ß©“í­“ªÏ I<STRING> “ªò“ïá“Ð®“øú“úÞ“ªÈ“ª·“ªÆ“«¯“«©’¡¼“«È“ª·“ªÞ“ª¹
(“ª½“ª·“ªÆ“Ê¦“Òö“ªÊ“ªé“«³“«ó“«Ñ“«¤“«ë“ª·“ªÞ“ª¹)“¡£
I<STRING> “ªÏ C<m/PATTERN/> ‘ÄÚ“ªÎ I<PATTERN> “ªÈ“ÔÒ’ÍÍ“ªË“Ùþ“í®’ÊÑ“üµ“ªµ“ªì“ªÞ“ª¹“¡£
"'" “ª¬“«Ç“«ê“«ß“«¿“ªÈ“ª·“ªÆ“ÞÅ“éÄ“ªµ“ªì“ª¿“íÞ“ùê“¡¢“Ùþ“í®’ÊÑ“üµ“ªÏ“ú¼“ªï“ªì“ªÞ“ª»“ªó“¡£
’ÂÐ’±þ“ª¹“ªë C</STRING/msixpo> “øú“úÞ“ªÎ“ÓÛ“ªï“ªê“ªË“ÞÅ“ªï“ªì“ª¿ Perl “ªÎ“ö·“ªò“Ú÷“ª·“ªÞ“ª¹“¡£
“Ú÷“ªê“ö·“ªÏ“êª“ªÎ“«Ñ“«¿’¡¼“«ó“ªò“ïá“Ð®“ûù“ª·“ª¿“ªâ“ªÎ“ªÇ“ª¹“¡£
“ª³“ªì“ªÏ“Üô“ÞÖ“ì¡“ªÊ“ª³“ªÈ“ªË“¡¢“ÔÒ“ª¸“Ùþ“í®“ªò“ùß“ªà“Ùþ“í®“Öª“ªÈ“ªÏ“ì¶“ªÊ“ªê“ªÞ“ª¹:
C<ref(qr/x/)> “ªÏ“¡¢“Ì¿“Íý“ªò“«Ç“«ê“«Õ“«¡“«ì“«ó“«¹“ª¹“ªë“ªÈ“Ú±“ïÒ“ëù“ö·“ªò“Ú÷“ª¹“ªË“ªâ’´Ø“ªï“ªé“ªº“¡¢
"Regexp" “ªò“Ú÷“ª·“ªÞ“ª¹“¡£

=begin original

For example,

=end original

“ÖÇ“ª¨“ªÐ:

    $rex = qr/my.STRING/is;
    print $rex;                 # prints (?si-xm:my.STRING)
    s/$rex/foo/;

=begin original

is equivalent to

=end original

“ªÏ“ì¤“ù»“ªÈ“Ôõ’²Á“ªÇ“ª¹:

    s/my.STRING/foo/is;

=begin original

The result may be used as a subpattern in a match:

=end original

“Ì¿“Íý“ªÏ“«Þ“«Ã“«Á“ªÎ“«µ“«Ö“«Ñ“«¿’¡¼“«ó“ªÈ“ª·“ªÆ“ÞÅ“ª¨“ªÞ“ª¹:

    $re = qr/$pattern/;
    $string =~ /foo${re}bar/;	# can be interpolated in other patterns
    $string =~ $re;		# or used standalone
    $string =~ /$re/;		# or this way

=begin original

Since Perl may compile the pattern at the moment of execution of qr()
operator, using qr() may have speed advantages in some situations,
notably if the result of qr() is used standalone:

=end original

Perl “ªÏ qr() “æÑ“ß©“í­“ªò’¼Â“ú¼“ª¹“ªë“âë“Êà“ªË“«Ñ“«¿’¡¼“«ó“ªò“«³“«ó“«Ñ“«¤“«ë“ª¹“ªë“ªÎ“ªÇ“¡¢
qr() “ªò“ÞÅ“ª¦“ª³“ªÈ“ªÇ“ª¤“ª¯“ªÄ“ª«“ªÎ“íÞ“Øü“ªÇ“áÜ“Óø“îÜ“ªË“êó“××“ªË“ªÊ“ªê“ªÞ“ª¹“¡£
“÷å“ªË qr() “ªÎ“Ì¿“Íý“ª¬‘¶À“Ø¡“ª·“ªÆ“ÞÅ“ªï“ªì“ªë“íÞ“ùê“ªË“êó“××“ªË“ªÊ“ªê“ªÞ“ª¹“¡£

    sub match {
	my $patterns = shift;
	my @compiled = map qr/$_/i, @$patterns;
	grep {
	    my $success = 0;
	    foreach my $pat (@compiled) {
		$success = 1, last if /$pat/;
	    }
	    $success;
	} @_;
    }

=begin original

Precompilation of the pattern into an internal representation at
the moment of qr() avoids a need to recompile the pattern every
time a match C</$pat/> is attempted.  (Perl has many other internal
optimizations, but none would be triggered in the above example if
we did not use qr() operator.)

=end original

qr() “ªÎ“ãÁ“ïÃ“ªÇ“«Ñ“«¿’¡¼“«ó“ªò‘ÄÚ“Ý»“øú“úÞ“ªË“«×“«ê“«³“«ó“«Ñ“«¤“«ë“ª¹“ªë“ª³“ªÈ“ªË“ªè“ªê“¡¢
C</$pat/> “ªò“ãË“ªß“ªë’Ëè“ªË’Ëè“üÞ“«Ñ“«¿’¡¼“«ó“ªò“î¢“«³“«ó“«Ñ“«¤“«ë“ª¹“ªë“ªÎ“ªò“ù­“ª±“ªë“ª³“ªÈ“ª¬“ªÇ“ª­“ªÞ“ª¹
(Perl “ªÏ“ª½“ªÎ“öâ“ªË“ªâ“Òý“ª¯“ªÎ‘ÄÚ“Ý»“õÌ“îê“ûù“ªò“ú¼“ª¤“ªÞ“ª¹“ª¬“¡¢
“ß¾“ªÎ“ÖÇ“ªÇ qr() “æÑ“ß©“í­“ªò“ÞÅ“ªï“ªÊ“ª«“ªÃ“ª¿“íÞ“ùê“ªÏ“ªÉ“ªÎ“õÌ“îê“ûù“ªâ“ú¼“ªï“ªì“ªÞ“ª»“ªó)“¡£

=begin original

Options are:

=end original

“«ª“«×“«·“«ç“«ó“ªÏ“ì¤“ù»“ªÎ“÷×“ªê“ªÇ“ª¹:

=begin original

    m	Treat string as multiple lines.
    s	Treat string as single line. (Make . match a newline)
    i	Do case-insensitive pattern matching.
    x	Use extended regular expressions.
    p	When matching preserve a copy of the matched string so
        that ${^PREMATCH}, ${^MATCH}, ${^POSTMATCH} will be defined.
    o	Compile pattern only once.

=end original

    m	“Ùþ“í®“Öª“ªò“ÜÜ‘Êý“ú¼“ªÈ“ª·“ªÆ“Ðâ“ª¦
    s	“Ùþ“í®“Öª“ªò“ìé“ú¼“ªÈ“ª·“ªÆ“Ðâ“ª¦ (. “ª¬ “ËÇ“ú¼“ªË“«Þ“«Ã“«Á“«ó“«°“ª¹“ªë“ªè“ª¦“ªË“ª¹“ªë)
    i	“«Ñ“«¿’¡¼“«ó“«Þ“«Ã“«Á“ªË“ªª“ª¤“ªÆ“ÓÞ“Ùþ“í®“á³“Ùþ“í®“ªò‘Çø“Ü¬“ª·“ªÊ“ª¤
    x	’³È“íå“ïá“Ð®“øú“úÞ“ªò“ÞÅ“ª¦
    p	“«Þ“«Ã“«Á“«ó“«°“ãÁ“ªË“«Þ“«Ã“«Á“«ó“«°“ª·“ª¿“Ùþ“í®“Öª“ªò“ÜÁ“ðí“ª¹“ªë“ªÎ“ªÇ“¡¢
        ${^PREMATCH}, ${^MATCH}, ${^POSTMATCH} “ª¬“ïÒ“ëù“ªµ“ªì“ªë
    o	“ìé“Óø“ªÀ“ª±“«³“«ó“«Ñ“«¤“«ë“ª¹“ªë

=begin original

If a precompiled pattern is embedded in a larger pattern then the effect
of 'msixp' will be propagated appropriately.  The effect of the 'o'
modifier has is not propagated, being restricted to those patterns
explicitly using it.

=end original

If a precompiled pattern is embedded in a larger pattern then the effect
of 'msixp' will be propagated appropriately.  The effect of the 'o'
modifier has is not propagated, being restricted to those patterns
explicitly using it.
(TBT)

=begin original

See L<perlre> for additional information on valid syntax for STRING, and
for a detailed look at the semantics of regular expressions.

=end original


=item m/PATTERN/msixpogc
X<m> X<operator, match>
X<regexp, options> X<regexp> X<regex, options> X<regex>
X</m> X</s> X</i> X</x> X</p> X</o> X</g> X</c>

=item /PATTERN/msixpogc

=begin original

Searches a string for a pattern match, and in scalar context returns
true if it succeeds, false if it fails.  If no string is specified
via the C<=~> or C<!~> operator, the $_ string is searched.  (The
string specified with C<=~> need not be an lvalue--it may be the
result of an expression evaluation, but remember the C<=~> binds
rather tightly.)  See also L<perlre>.  See L<perllocale> for
discussion of additional considerations that apply when C<use locale>
is in effect.

=end original

“«Ñ“«¿’¡¼“«ó“«Þ“«Ã“«Á“ªÇ“Ùþ“í®“Öª’¸¡“ßã“ªò“ú¼“ªÊ“ª¤“¡¢“«¹“««“«é“«³“«ó“«Æ“«­“«¹“«È“ªÇ“ªÏ“à÷“Íí“ª·“ª¿“ªÈ“ª­“ªÏ‘Õæ“¡¢
“ã÷“ø¨“ª·“ª¿“ªÈ“ª­“ªÏ˜ºô“ªò“Ú÷“ª·“ªÞ“ª¹“¡£
C<=~> “æÑ“ß©“í­“ª« C<!~> “æÑ“ß©“í­“ªÇ’¸¡“ßã’ÂÐ“ßÚ“ªÎ“Ùþ“í®“Öª“ªò“ãÆ“ªµ“ªÊ“ª«“ªÃ“ª¿“ªÈ“ª­“ªË“ªÏ“¡¢
C<$_> “ªÎ“Ùþ“í®“Öª“ª¬’¸¡“ßã’ÂÐ“ßÚ“ªÈ“ªÊ“ªê“ªÞ“ª¹“¡£
(C<=~> “ªÇ“ò¦“ïÒ“ªµ“ªì“ªë“Ùþ“í®“Öª“ªÏ“¡¢“ñ§’ÊÕ“ö·“ªÇ“ª¢“ªë“ù±“é©“ªÏ“ª¢“ªê“ªÞ“ª»“ªó“¡£
“ãÒ“ªò“øÄ’²Á“ª·“ª¿“Ì¿“Íý“ªÇ“ªâ“ª«“ªÞ“ª¤“ªÞ“ª»“ªó“ª¬“¡¢C<=~> “ªÎ“éÐ“à»“â÷“êÈ“ª¬“ª¤“ª¯“ªÖ“ªó“ÍÔ“ª¤“ª³“ªÈ“ªË
“ñ¼“ëò“ª·“ªÆ“ª¯“ªÀ“ªµ“ª¤“¡£)
L<perlre> “ªâ‘²Î“ðÎ“ª·“ªÆ“ª¯“ªÀ“ªµ“ª¤“¡£
C<use locale> “ª¬“êó’¸ú“ªÎ“íÞ“ùê“ªÎ“ì¡“Öå“ªË“ªÄ“ª¤“ªÆ“ªÏ L<perllocale> “ªò‘²Î“ðÎ“ª·“ªÆ“ù»“ªµ“ª¤“¡£

=begin original

Options are as described in C<qr//>; in addition, the following match
process modifiers are available:

=end original

Options are as described in C<qr//>; in addition, the following match
process modifiers are available:
(TBT)

=begin original

    g	Match globally, i.e., find all occurrences.
    c	Do not reset search position on a failed match when /g is in effect.

=end original

    g   “«°“«í’¡¼“«Ð“«ë“ªË“«Þ“«Ã“«Á“¡¢“ªÄ“ªÞ“ªê“¡¢“ª¹“ªÙ“ªÆ“ªò“÷®“ª·“õó“ª¹
    c	/g “ª¬“êó’¸ú“ªÊ“ªÈ“ª­“¡¢“«Þ“«Ã“«Á“«ó“«°“ªË“ã÷“ø¨“ª·“ªÆ“ªâ’¸¡“ßã“êÈ“öÇ“ªò“«ê“«»“«Ã“«È“ª·“ªÊ“ª¤

=begin original

If "/" is the delimiter then the initial C<m> is optional.  With the C<m>
you can use any pair of non-alphanumeric, non-whitespace characters
as delimiters.  This is particularly useful for matching path names
that contain "/", to avoid LTS (leaning toothpick syndrome).  If "?" is
the delimiter, then the match-only-once rule of C<?PATTERN?> applies.
If "'" is the delimiter, no interpolation is performed on the PATTERN.

=end original

‘Çø“ï·“Ùþ“í®“ª¬ "/" “ªÎ“ªÈ“ª­“ªË“ªÏ“¡¢“õÌ“ôø“ªÎ C<m> “ªÏ“Üõ“ª±“ªÆ“ªâ“Üõ“ª±“ªÊ“ª¯“ªÆ“ªâ“ª«“ªÞ“ª¤“ªÞ“ª»“ªó“¡£
C<m> “ªò“Üõ“ª±“ªë“ªÈ“ª­“ªË“ªÏ“¡¢“çÈ‘Êý“í®“ªÇ“ªâ“Íö“ÛÜ“ªÇ“ªâ“ªÊ“ª¤“¡¢“ìò“ëò“ªÎ“Ùþ“í®“ªÎ“«Ú“«¢“ªò
‘Çø“ï·“Ùþ“í®“ªÈ“ª·“ªÆ“ÞÅ“ª¦“ª³“ªÈ“ª¬“ªÇ“ª­“ªÞ“ª¹“¡£
“ª³“ªì“ªÏ "/" “ªò“ùß“ªà“«Ñ“«¹“Ù£“ªË“«Ñ“«¿’¡¼“«ó“«Ñ“«Ã“«Á“ªò“ú¼“ªÊ“ª¦“ªÈ“ª­“ªË“øµ“××“ªÇ“ª·“ªç“ª¦“¡£
LTS (“åÅ“ò«“ø¶“òû“ñø“ý¦“ÏØ) “ªò“ù­“ª±“ªë“ª¿“ªá“ªË“ªâ“¡£
"'" “ª¬“«Ç“«ê“«ß“«¿“ªÎ“íÞ“ùê“¡¢PATTERN “ªË’ÂÐ“ª¹“ªë“î÷“ËÒ“ªÏ“ú¼“ªï“ªì“ªÞ“ª»“ªó“¡£

=begin original

PATTERN may contain variables, which will be interpolated (and the
pattern recompiled) every time the pattern search is evaluated, except
for when the delimiter is a single quote.  (Note that C<$(>, C<$)>, and
C<$|> are not interpolated because they look like end-of-string tests.)
If you want such a pattern to be compiled only once, add a C</o> after
the trailing delimiter.  This avoids expensive run-time recompilations,
and is useful when the value you are interpolating won't change over
the life of the script.  However, mentioning C</o> constitutes a promise
that you won't change the variables in the pattern.  If you change them,
Perl won't even notice.  See also L<"qr/STRING/msixpo">.

=end original

PATTERN “ªË“ªÏ“¡¢’ÊÑ‘Êý“ª¬“ùß“ªÞ“ªì“ªÆ“ª¤“ªÆ“ªâ“ªè“ª¯“¡¢“«Ñ“«¿’¡¼“«ó“ª¬“øÄ’²Á“ªµ“ªì“ªë“ª´“ªÈ“ªË“¡¢
(“«Ç“«ê“«ß“«¿“ª¬“«·“«ó“«°“«ë“«¯“«©’¡¼“«È“ªÇ“ªÊ“ª¤“ùÚ“ªê)
’ÊÑ‘Êý“ªÏ“î÷“ËÒ“ªµ“ªì (“«Ñ“«¿’¡¼“«ó“ª¬“î¢“«³“«ó“«Ñ“«¤“«ë“ªµ“ªì) “ªÞ“ª¹“¡£
(’ÊÑ‘Êý C<$(>, C<$)>, C<$|> “ªÏ“Ùþ“í®“Öª“ªÎ“ðû“ªï“ªê“ªò“ðà“ªÙ“ªë“«Ñ“«¿’¡¼“«ó“ªÇ“ª¢“ªë“ªÈ
“ú°’¼á“ªµ“ªì“ªë“ªÎ“ªÇ“¡¢“î÷“ËÒ“ªµ“ªì“ªÞ“ª»“ªó“¡£)
“«Ñ“«¿’¡¼“«ó“ª¬“«³“«ó“«Ñ“«¤“«ë“ªµ“ªì“ªë“ªÎ“ªò 1 “Óø“ªÀ“ª±“ªË“ª·“ª¿“ª¤“íÞ“ùê“ªË“ªÏ“¡¢
“ðû“ªï“ªê“ªÎ‘Çø“ï·“Ùþ“í®“ªÎ“ý­“ªË C</o> “áó“ãÞ“í­“ªò“Üõ“ª±“ªÞ“ª¹“¡£
“ª³“ªì“ªË“ªè“ªê“¡¢’¼Â“ú¼“ãÁ“ªË“î¢“«³“«ó“«Ñ“«¤“«ë“ª¬“Þº“Ûå“ªË“ÑÃ“ª³“ªë“ª³“ªÈ“ª¬“ù­“ª±“ªé“ªì“¡¢
“î÷“ËÒ“ª¹“ªë“ö·“ª¬“«¹“«¯“«ê“«×“«È“ªÎ’¼Â“ú¼“ñé“ªË’ÊÑ“ûù“ª·“ªÊ“ª¤“íÞ“ùê“ªË“êó’¸ú“ªÊ“ªâ“ªÎ“ªÈ“ªÊ“ªê“ªÞ“ª¹“¡£
“ª·“ª«“ª·“¡¢C</o> “ªò“Üõ“ª±“ªë“ª³“ªÈ“ªÏ“¡¢“«Ñ“«¿’¡¼“«ó“ªÎ“ñé“ªÎ’ÊÑ‘Êý“ªò’ÊÑ“ÌÚ“ª·“ªÊ“ª¤“ª³“ªÈ“ªò
“å³“áÖ“ª¹“ªë“ªâ“ªÎ“ªÇ“ª¹“¡£
’ÊÑ“ÌÚ“ª·“ª¿“ªÈ“ª·“ªÆ“ªâ“¡¢Perl “ª¬“ª½“ªì“ªË’µ¤“Üõ“ª¯“ª³“ªÈ“ªÏ“ª¢“ªê“ªÞ“ª»“ªó“¡£
L<"qr/STRING/msixpo"> “ªâ‘²Î“ðÎ“ª·“ªÆ“ù»“ªµ“ª¤“¡£

=begin original

If the PATTERN evaluates to the empty string, the last
I<successfully> matched regular expression is used instead. In this
case, only the C<g> and C<c> flags on the empty pattern is honoured -
the other flags are taken from the original pattern. If no match has
previously succeeded, this will (silently) act instead as a genuine
empty pattern (which will always match).

=end original

PATTERN “ªò“øÄ’²Á“ª·“ª¿“Ì¿“Íý“ª¬“Íö“Ùþ“í®“Öª“ªÈ“ªÊ“ªÃ“ª¿“íÞ“ùê“ªË“ªÏ“¡¢
“õÌ“ý­“ªË“«Þ“«Ã“«Á“ªË I<“à÷“Íí“ª·“ª¿> “ïá“Ð®“øú“úÞ“ª¬“¡¢“ÓÛ“ªï“ªê“ªË“ÞÅ“ªï“ªì“ªÞ“ª¹“¡£
“ª³“ªÎ“íÞ“ùê“¡¢“Íö“«Ñ“«¿’¡¼“«ó“ªË’ÂÐ“ª·“ªÆ C<g> “ªÎ C<c> “«Õ“«é“«°“ªÀ“ª±“ª¬“êó’¸ú“ªÇ“ª¹ -
“ª½“ªÎ“öâ“ªÎ“«Õ“«é“«°“ªÏ“êª“ªÎ“«Ñ“«¿’¡¼“«ó“ª«“ªé“ö¢“ªé“ªì“ªÞ“ª¹“¡£
“ì¤“îñ“ªË“à÷“Íí“ª·“ª¿“«Þ“«Ã“«Á“«ó“«°“ª¬“ªÊ“ª¤“íÞ“ùê“¡¢“ª³“ªì“ªÏ(“äÞ’ÌÛ“ªË)‘Õæ“ªÎ“Íö“«Ñ“«¿’¡¼“«ó“ªÈ“ª·“ªÆ
“ÔÑ“íÂ“ª·“ªÞ“ª¹(“ªÄ“ªÞ“ªê“ßÈ“ªË“«Þ“«Ã“«Á“«ó“«°“ª·“ªÞ“ª¹)“¡£

=begin original

Note that it's possible to confuse Perl into thinking C<//> (the empty
regex) is really C<//> (the defined-or operator).  Perl is usually pretty
good about this, but some pathological cases might trigger this, such as
C<$a///> (is that C<($a) / (//)> or C<$a // />?) and C<print $fh //>
(C<print $fh(//> or C<print($fh //>?).  In all of these examples, Perl
will assume you meant defined-or.  If you meant the empty regex, just
use parentheses or spaces to disambiguate, or even prefix the empty
regex with an C<m> (so C<//> becomes C<m//>).

=end original

Note that it's possible to confuse Perl into thinking C<//> (the empty
regex) is really C<//> (the defined-or operator).  Perl is usually pretty
good about this, but some pathological cases might trigger this, such as
C<$a///> (is that C<($a) / (//)> or C<$a // />?) and C<print $fh //>
(C<print $fh(//> or C<print($fh //>?).  In all of these examples, Perl
will assume you meant defined-or.  If you meant the empty regex, just
use parentheses or spaces to disambiguate, or even prefix the empty
regex with an C<m> (so C<//> becomes C<m//>).
(TBT)

=begin original

If the C</g> option is not used, C<m//> in list context returns a
list consisting of the subexpressions matched by the parentheses in the
pattern, i.e., (C<$1>, C<$2>, C<$3>...).  (Note that here C<$1> etc. are
also set, and that this differs from Perl 4's behavior.)  When there are
no parentheses in the pattern, the return value is the list C<(1)> for
success.  With or without parentheses, an empty list is returned upon
failure.

=end original

C</g>“«ª“«×“«·“«ç“«ó“ª¬“ÞÅ“ªï“ªì“ªÊ“ª«“ªÃ“ª¿“íÞ“ùê“¡¢“«ê“«¹“«È“«³“«ó“«Æ“«­“«¹“«È“ªÇ“ªÎC<m//>“ªÏ
“«Ñ“«¿’¡¼“«ó“ªÎ“ñé“ªÎ“ÎÀ“ûÁ“ªÇ“ÎÀ“ªé“ªì“ª¿“Ý»“ÝÂ“Öª“ªË“«Þ“«Ã“«Á“ª·“ª¿“ªâ“ªÎ“ªÇ“Ï°“à÷“ªµ“ªì“ªë“«ê“«¹“«È“ªò
“Ú÷“ª·“ªÞ“ª¹“¡£
“ª³“ªì“ªÏ“¡¢(C<$1>, C<$2>, C<$3>, ...) “ªÈ“ª¤“ª¦“ª³“ªÈ“ªÇ“ª¹“¡£
(“ª³“ªÎ“íÞ“ùê“¡¢C<$1> “ªÊ“ªÉ“ªâ“àâ“ïÒ“ªµ“ªì“ªÞ“ª¹“¡£
“ª³“ªÎ“ïÃ“ªÇ Perl 4 “ªÎ“ÔÑ“íÂ“ªÈ“êÞ“ªÃ“ªÆ“ª¤“ªÞ“ª¹“¡£)
“«Ñ“«¿’¡¼“«ó“ªË“ÎÀ“ûÁ“ª¬“ªÊ“ª¤“íÞ“ùê“ªÏ“¡¢“Ú÷“ªê“ö·“ªÏ“à÷“Íí“ãÁ“ªÏ“«ê“«¹“«È C<(1)> “ªÇ“ª¹“¡£
“ÎÀ“ûÁ“ªÎ“ª¢“ªë“ªÊ“ª·“ªË’´Ø“ªï“ªé“ªº“¡¢“ã÷“ø¨“ãÁ“ªÏ“Íö“«ê“«¹“«È“ªò“Ú÷“ª·“ªÞ“ª¹“¡£

=begin original

Examples:

=end original

“ÖÇ“ªò“ãÆ“ª·“ªÞ“ª¹:

    open(TTY, '/dev/tty');
    <TTY> =~ /^y/i && foo();	# do foo if desired

    if (/Version: *([0-9.]*)/) { $version = $1; }

    next if m#^/usr/spool/uucp#;

    # poor man's grep
    $arg = shift;
    while (<>) {
	print if /$arg/o;	# compile only once
    }

    if (($F1, $F2, $Etc) = ($foo =~ /^(\S+)\s+(\S+)\s*(.*)/))

=begin original

This last example splits $foo into the first two words and the
remainder of the line, and assigns those three fields to $F1, $F2, and
$Etc.  The conditional is true if any variables were assigned, i.e., if
the pattern matched.

=end original

“õÌ“ý­“ªÎ“ÖÇ“ªÏ“¡¢$foo “ªò“õÌ“ôø“ªÎ 2 “ªÄ“ªÎ’Ã±“åÞ“ªÈ“ú¼“ªÎ‘²Ð“ªê“ªË“ÝÂ“ú°“ª·“¡¢
$F1 “ªÈ $F2 “ªÈ $Etc “ªË“ÓÛ“ìý“ª·“ªÆ“ª¤“ªÞ“ª¹“¡£
’ÊÑ‘Êý“ªË“ÓÛ“ìý“ªµ“ªì“ªì“ªÐ“¡¢“ª¹“ªÊ“ªï“ªÁ“«Ñ“«¿’¡¼“«ó“ª¬“«Þ“«Ã“«Á“ª¹“ªì“ªÐ“¡¢
if “ªÎ‘Ìõ“Ëì“ª¬‘Õæ“ªÈ“ªÊ“ªê“ªÞ“ª¹“¡£

=begin original

The C</g> modifier specifies global pattern matching--that is,
matching as many times as possible within the string.  How it behaves
depends on the context.  In list context, it returns a list of the
substrings matched by any capturing parentheses in the regular
expression.  If there are no parentheses, it returns a list of all
the matched strings, as if there were parentheses around the whole
pattern.

=end original

C</g> “áó“ãÞ“í­“ªÏ“¡¢“«°“«í’¡¼“«Ð“«ë“ªÊ“«Ñ“«¿’¡¼“«ó“«Þ“«Ã“«Á“ªò“ò¦“ïÒ“ª¹“ªë“ªâ“ªÎ“ªÇ“¡¢
“Ùþ“í®“Öª“ªÎ“ñé“ªÇ“Ê¦“Òö“ªÊ“ùÚ“ªê“ª¿“ª¯“ªµ“ªó“«Þ“«Ã“«Á“ªò“ú¼“ªÊ“ª¤“ªÞ“ª¹“¡£
“ª³“ªÎ“ÔÑ“íÂ“ªÏ“¡¢“«³“«ó“«Æ“«­“«¹“«È“ªË“ëî“ðí“ª·“ªÞ“ª¹“¡£
“«ê“«¹“«È“«³“«ó“«Æ“«­“«¹“«È“ªÇ“ªÏ“¡¢“ïá“Ð®“øú“úÞ‘ÄÚ“ªÎ“ÎÀ“ûÁ“Üõ“ª±“ªµ“ªì“ª¿“ªâ“ªÎ“ªË“«Þ“«Ã“«Á“ª·“ª¿
“Ý»“ÝÂ“Ùþ“í®“Öª“ªÎ“«ê“«¹“«È“ª¬“Ú÷“ªµ“ªì“ªÞ“ª¹“¡£
“ÎÀ“ûÁ“ª¬“ªÊ“ª±“ªì“ªÐ“¡¢“«Ñ“«¿’¡¼“«ó“îï‘Ìå“ªò“ÎÀ“ûÁ“ªÇ“ÎÀ“ªÃ“ªÆ“ª¤“ª¿“ª«“ªÎ“ªè“ª¦“ªË“¡¢
“ª¹“ªÙ“ªÆ“ªÎ“«Þ“«Ã“«Á“ª·“ª¿“Ùþ“í®“Öª“ªÎ“«ê“«¹“«È“ª¬“Ú÷“ªµ“ªì“ªÞ“ª¹“¡£

=begin original

In scalar context, each execution of C<m//g> finds the next match,
returning true if it matches, and false if there is no further match.
The position after the last match can be read or set using the pos()
function; see L<perlfunc/pos>.   A failed match normally resets the
search position to the beginning of the string, but you can avoid that
by adding the C</c> modifier (e.g. C<m//gc>).  Modifying the target
string also resets the search position.

=end original

“«¹“««“«é“«³“«ó“«Æ“«­“«¹“«È“ªÇ“ªÏ“¡¢C<m//g> “ªò’¼Â“ú¼“ª¹“ªë’Ëè“ªË“ó­“ªÎ“«Þ“«Ã“«Á“ªò“÷®“ª·“ªÞ“ª¹“¡£
“«Þ“«Ã“«Á“ª·“ª¿“íÞ“ùê“ªÏ‘Õæ“ªò“Ú÷“ª·“¡¢“ªâ“ª¦“«Þ“«Ã“«Á“ª·“ªÊ“ª¯“ªÊ“ªÃ“ª¿“ªé˜ºô“ªò“Ú÷“ª·“ªÞ“ª¹“¡£
“õÌ“ý­“ªÎ“«Þ“«Ã“«Á“ªÎ“êÈ“öÇ“ªÏ pos() ’´Ø‘Êý“ªÇ’ÆÉ“ªß“õó“ª·“ªä“àâ“ïÒ“ª¬“ªÇ“ª­“ªÞ“ª¹“¡£
L<perlfunc/pos> “ªò‘²Î“ðÎ“ª·“ªÆ“ù»“ªµ“ª¤“¡£
“«Þ“«Ã“«Á“ªË“ã÷“ø¨“ª¹“ªë“ªÈ“÷×“ßÈ“ªÏ’¸¡“ßã“êÈ“öÇ“ªò“Ùþ“í®“Öª“ªÎ“à»“Ôé“ªË“«ê“«»“«Ã“«È“ª·“ªÞ“ª¹“ª¬“¡¢
C</c> “áó“ãÞ“í­“ªò“ªÄ“ª±“ªë(“ªÄ“ªÞ“ªê C<m//gc>)“ª³“ªÈ“ªÇ“ª³“ªì“ªò“ÛÁ“ª°“ª³“ªÈ“ª¬“ªÇ“ª­“ªÞ“ª¹“¡£
“«¿’¡¼“«²“«Ã“«È“ªÈ“ªÊ“ªë“Ùþ“í®“Öª“ª¬’ÊÑ“ÌÚ“ªµ“ªì“ª¿“íÞ“ùê“ªâ’¸¡“ßã“êÈ“öÇ“ªÏ“«ê“«»“«Ã“«È“ªµ“ªì“ªÞ“ª¹“¡£

=begin original

You can intermix C<m//g> matches with C<m/\G.../g>, where C<\G> is a
zero-width assertion that matches the exact position where the previous
C<m//g>, if any, left off.  Without the C</g> modifier, the C<\G> assertion
still anchors at pos(), but the match is of course only attempted once.
Using C<\G> without C</g> on a target string that has not previously had a
C</g> match applied to it is the same as using the C<\A> assertion to match
the beginning of the string.  Note also that, currently, C<\G> is only
properly supported when anchored at the very beginning of the pattern.

=end original

C<m//g> “«Þ“«Ã“«Á“ªò C<m/\G.../g> “ªÈ“ûè“ª¼“ªë“ª³“ªÈ“ªâ“ªÇ“ª­“ªÞ“ª¹“¡£
C<\G> “ªÏ“îñ“üÞ“ªÎ C<m//g> “ª¬“ª¢“ªì“ªÐ“ª½“ªÎ“ÔÒ“ª¸“êÈ“öÇ“ªÇ“«Þ“«Ã“«Á“ª¹“ªë
“«¼“«í“Ùþ“í®“øë“ªÎ“«¢“«µ’¡¼“«È“ªÇ“ª¹“¡£
C</g> “áó“ãÞ“í­“ªÊ“ª·“ªÎ“íÞ“ùê“¡¢C<\G> “«¢“«µ’¡¼“«È“ªÏ pos() “ªË“Í³“ïÒ“ª·“ªÞ“ª¹“ª¬“¡¢
“«Þ“«Ã“«Á“ªÏ“ªâ“ªÁ“ªí“ªó“ìé“Óø“ªÀ“ª±“ãË“ªµ“ªì“ªÞ“ª¹“¡£
“ì¤“îñ“ªË C</g> “«Þ“«Ã“«Á“ªò“îê“éÄ“ª·“ªÆ“ª¤“ªÊ“ª¤“«¿’¡¼“«²“«Ã“«È“Ùþ“í®“Öª“ªË’ÂÐ“ª·“ªÆ
C</g> “ªÊ“ª·“ªÇ C<\G> “ªò“ÞÅ“ª¦“ªÈ“¡¢“Ùþ“í®“Öª“ªÎ“à»“Ôé“ªË“«Þ“«Ã“«Á“ª¹“ªë C<\A> “«¢“«µ’¡¼“«È“ªò
“ÞÅ“ª¦“ªÎ“ªÈ“ÔÒ“ª¸“ª³“ªÈ“ªË“ªÊ“ªê“ªÞ“ª¹“¡£
C<\G> “ªÏ“úÞ“î¤“ªÎ“ªÈ“ª³“ªí“¡¢“«Ñ“«¿’¡¼“«ó“ªÎ“ªÞ“ªµ“ªË“à»“Ôé“ªò“ãÆ“ª¹“íÞ“ùê“ªË“ªÎ“ªß“ïá“ª·“ª¯
’ÂÐ’±þ“ª¹“ªë“ª³“ªÈ“ªË“ªâ“ñ¼“ëò“ª·“ªÆ“ª¯“ªÀ“ªµ“ª¤“¡£

=begin original

Examples:

=end original

“ÖÇ:

    # list context
    ($one,$five,$fifteen) = (`uptime` =~ /(\d+\.\d+)/g);

    # scalar context
    $/ = "";
    while (defined($paragraph = <>)) {
	while ($paragraph =~ /[a-z]['")]*[.!?]+['")]*\s/g) {
	    $sentences++;
	}
    }
    print "$sentences\n";

    # using m//gc with \G
    $_ = "ppooqppqq";
    while ($i++ < 2) {
        print "1: '";
        print $1 while /(o)/gc; print "', pos=", pos, "\n";
        print "2: '";
        print $1 if /\G(q)/gc;  print "', pos=", pos, "\n";
        print "3: '";
        print $1 while /(p)/gc; print "', pos=", pos, "\n";
    }
    print "Final: '$1', pos=",pos,"\n" if /\G(.)/;

=begin original

The last example should print:

=end original

“õÌ“ý­“ªÎ“ªâ“ªÎ“ªÏ“ì¤“ù»“ªÎ“ªâ“ªÎ“ªò“øú“ãÆ“ª¹“ªë“ªÏ“ªº“ªÇ“ª¹:

    1: 'oo', pos=4
    2: 'q', pos=5
    3: 'pp', pos=7
    1: '', pos=7
    2: 'q', pos=8
    3: '', pos=8
    Final: 'q', pos=8

=begin original

Notice that the final match matched C<q> instead of C<p>, which a match
without the C<\G> anchor would have done. Also note that the final match
did not update C<pos> -- C<pos> is only updated on a C</g> match. If the
final match did indeed match C<p>, it's a good bet that you're running an
older (pre-5.6.0) Perl.

=end original

C<\G> “ªÊ“ª·“ªÇ“ªÎ“«Þ“«Ã“«Á“ª¬“ú¼“ªï“ªì“ª¿“ª¿“ªá“¡¢“õÌ“ý­“ªÎ“«Þ“«Ã“«Á“ªÇ“ªÏ C<p> “ªÇ“ªÏ“ªÊ“ª¯
C<q> “ª¬“«Þ“«Ã“«Á“ª¹“ªë“ª³“ªÈ“ªË“ñ¼“ëò“ª·“ªÆ“ª¯“ªÀ“ªµ“ª¤“¡£
“ªÞ“ª¿“¡¢“õÌ“ý­“ªÎ“«Þ“«Ã“«Á“ªÏ C<pos> “ªò“ÌÚ“ãæ“ª·“ªÊ“ª¤“ª³“ªÈ“ªË“ñ¼“ëò“ª·“ªÆ“ª¯“ªÀ“ªµ“ª¤“¡£
C<pos> “ªÏ C</g> “«Þ“«Ã“«Á“ªÇ“ªÎ“ªß“ÌÚ“ãæ“ªµ“ªì“ªÞ“ª¹“¡£
“ªâ“ª·“õÌ“ý­“ªÎ“«Þ“«Ã“«Á“ªÇ C<p> “ªË“«Þ“«Ã“«Á“ª·“ª¿“íÞ“ùê“¡¢“ª«“ªÊ“ªê“ªÎ“ü¬“áã“ªÇ
“Í¯“ª¤ (5.6.0 “ì¤“îñ“ªÎ) Perl “ªÇ’¼Â“ú¼“ª·“ªÆ“ª¤“ªë“ªÏ“ªº“ªÇ“ª¹“¡£

=begin original

A useful idiom for C<lex>-like scanners is C</\G.../gc>.  You can
combine several regexps like this to process a string part-by-part,
doing different actions depending on which regexp matched.  Each
regexp tries to match where the previous one leaves off.

=end original

C<lex> “ù¦“ªË“«¹“«­“«ã“«ó“ª¹“ªë“ª¿“ªá“ªË“øµ“××“ªÊ“ò¦“ïÒ“ªÏ C</\G.../gc> “ªÇ“ª¹“¡£
“Ùþ“í®“Öª“ªò“Ý»“ÝÂ“ª´“ªÈ“ªË’½è“×â“ª¹“ªë“ª¿“ªá“ªË“ª¤“ª¯“ªÄ“ª«“ªÎ“ïá“Ð®“øú“úÞ“ªò“ªÄ“ªÊ“ª²“ªÆ“¡¢
“ªÉ“ªÎ“ïá“Ð®“øú“úÞ“ªË“«Þ“«Ã“«Á“ª·“ª¿“ª«“ªË“ªè“ªÃ“ªÆ“ì¶“ªÊ“ªë’½è“×â“ªò“ª¹“ªë“ª³“ªÈ“ª¬“ªÇ“ª­“ªÞ“ª¹“¡£
“ª½“ªì“ª¾“ªì“ªÎ“ïá“Ð®“øú“úÞ“ªÏ“îñ“ªÎ“ïá“Ð®“øú“úÞ“ª¬“Þ«“ªÐ“ª·“ª¿“Ý»“ÝÂ“ªË’ÂÐ“ª·“ªÆ
“«Þ“«Ã“«Á“ªò“ãË“ªß“ªÞ“ª¹“¡£

 $_ = <<'EOL';
      $url = URI::URL->new( "http://www/" );   die if $url eq "xXx";
 EOL
 LOOP:
    {
      print(" digits"),		redo LOOP if /\G\d+\b[,.;]?\s*/gc;
      print(" lowercase"),	redo LOOP if /\G[a-z]+\b[,.;]?\s*/gc;
      print(" UPPERCASE"),	redo LOOP if /\G[A-Z]+\b[,.;]?\s*/gc;
      print(" Capitalized"),	redo LOOP if /\G[A-Z][a-z]+\b[,.;]?\s*/gc;
      print(" MiXeD"),		redo LOOP if /\G[A-Za-z]+\b[,.;]?\s*/gc;
      print(" alphanumeric"),	redo LOOP if /\G[A-Za-z0-9]+\b[,.;]?\s*/gc;
      print(" line-noise"),	redo LOOP if /\G[^A-Za-z0-9]+/gc;
      print ". That's all!\n";
    }

=begin original

Here is the output (split into several lines):

=end original

“õó“Õô“ªÏ“ì¤“ù»“ªÎ“ªè“ª¦“ªË“ªÊ“ªê“ªÞ“ª¹(“ù¼“ú¼“ª«“ªË“ÝÂ“ùÜ“ª·“ªÆ“ª¤“ªÞ“ª¹):

 line-noise lowercase line-noise lowercase UPPERCASE line-noise
 UPPERCASE line-noise lowercase line-noise lowercase line-noise
 lowercase lowercase line-noise lowercase lowercase line-noise
 MiXeD line-noise. That's all!

=item ?PATTERN?
X<?>

=begin original

This is just like the C</pattern/> search, except that it matches only
once between calls to the reset() operator.  This is a useful
optimization when you want to see only the first occurrence of
something in each file of a set of files, for instance.  Only C<??>
patterns local to the current package are reset.

=end original

“ª³“ªì“ªÏ“¡¢reset() “æÑ“ß©“í­“ªò“û¼“ªÓ“õó“ª¹“ª´“ªÈ“ªË 1 “Óø“ªÀ“ª±“ª·“ª«
“«Þ“«Ã“«Á“ª·“ªÊ“ª¤“ª³“ªÈ“ªò“ð¶“ª¤“ªÆ“ªÏ C</pattern/> “ªË“ªè“ªë’¸¡“ßã“ªÈ“îï“ª¯“ÔÒ“ª¸“ªÇ“ª¹“¡£
“ª¿“ªÈ“ª¨“ªÐ“¡¢“«Õ“«¡“«¤“«ë“ªÎ“ó¢“ªÞ“ªê“ªÎ“ñé“ªÇ“ËÁ‘¡©“ªÎ“«Õ“«¡“«¤“«ë“ªË“ªÄ“ª¤“ªÆ“¡¢
“ª¢“ªë“ªâ“ªÎ“ªò“÷®“ª¹“ªÈ“ª­“¡¢“õÌ“ôø“ªÎ 1 “ªÄ“ªÀ“ª±“ªÎ“ðí“î¤“ª¬“ªï“ª«“ªì“ªÐ“ÕÞ“ª¤“ªÎ“ªÇ“ª¢“ªì“ªÐ“¡¢
“ª³“ªÎ“Ñ¦“Òö“ªò“ÞÅ“ªÃ“ªÆ“õÌ“îê“ûù“ªò“ªÏ“ª«“ªë“ª³“ªÈ“ª¬“ªÇ“ª­“ªÞ“ª¹“¡£
“úÞ“î¤“ªÎ“«Ñ“«Ã“«±’¡¼“«¸“ªË“«í’¡¼“««“«ë“ªÈ“ªÊ“ªÃ“ªÆ“ª¤“ªë C<??> “ªÎ“«Ñ“«¿’¡¼“«ó“ªÀ“ª±“ª¬
“«ê“«»“«Ã“«È“ªµ“ªì“ªÞ“ª¹“¡£

    while (<>) {
	if (?^$?) {
			    # blank line between header and body
	}
    } continue {
	reset if eof;	    # clear ?? status for next file
    }

=begin original

This usage is vaguely deprecated, which means it just might possibly
be removed in some distant future version of Perl, perhaps somewhere
around the year 2168.

=end original

“ª³“ªÎ“Û°“Ûö“ªÏ“¡¢“ª¢“ªÞ“ªê“ªª’´«“ªá“ª·“ªÞ“ª»“ªó“¡£
Perl “ªÎ“êÀ“ª¤‘½«‘À´“ªÎ“«Ð’¡¼“«¸“«ç“«ó(“ªª“ª½“ªé“ª¯ 2168 “Ò´“Ìñ)“ªÇ“ªÏ“Þû“ð¶“ªµ“ªì“ªë“ª«“ªâ“ª·“ªì“ªÞ“ª»“ªó“¡£

=item s/PATTERN/REPLACEMENT/msixpogce
X<substitute> X<substitution> X<replace> X<regexp, replace>
X<regexp, substitute> X</m> X</s> X</i> X</x> X</p> X</o> X</g> X</c> X</e>

=begin original

Searches a string for a pattern, and if found, replaces that pattern
with the replacement text and returns the number of substitutions
made.  Otherwise it returns false (specifically, the empty string).

=end original

“Ùþ“í®“Öª“ñé“ªÇ“«Ñ“«¿’¡¼“«ó“ªò’¸¡“ßã“ª·“¡¢“ªâ“ª·“Ì¸“ªÄ“ª«“ªì“ªÐ“¡¢“öÇ“üµ“«Æ“«­“«¹“«È“ªÇ“öÇ“ª­“üµ“ª¨“¡¢
“öÇ“üµ“ª·“ª¿‘Êý“ªò“Ú÷“ª·“ªÞ“ª¹“¡£
“Ì¸“ªÄ“ª«“ªé“ªÊ“ª±“ªì“ªÐ“¡¢˜ºô (“Îý‘Ìå“îÜ“ªË“ªÏ“¡¢“Íö“Ùþ“í®“Öª) “ªò“Ú÷“ª·“ªÞ“ª¹“¡£

=begin original

If no string is specified via the C<=~> or C<!~> operator, the C<$_>
variable is searched and modified.  (The string specified with C<=~> must
be scalar variable, an array element, a hash element, or an assignment
to one of those, i.e., an lvalue.)

=end original

C<=~> “æÑ“ß©“í­“ªä C<!~> “æÑ“ß©“í­“ªË“ªè“ªÃ“ªÆ“Ùþ“í®“Öª“ª¬“ò¦“ïÒ“ªµ“ªì“ªÆ“ª¤“ªÊ“ª±“ªì“ªÐ“¡¢
’ÊÑ‘Êý C<$_> “ª¬’¸¡“ßã“ªµ“ªì“¡¢“áó“ïá“ªµ“ªì“ªÞ“ª¹“¡£
(C<=~> “ªÇ“ò¦“ïÒ“ªµ“ªì“ªë“Ùþ“í®“Öª“ªÏ“¡¢“«¹“««“«é’ÊÑ‘Êý“¡¢“ÛÕ“Öª“é©“áÈ“¡¢“«Ï“«Ã“«·“«å“é©“áÈ“¡¢
“ª¢“ªë“ª¤“ªÏ“¡¢“ª³“ªì“ªé“ªØ“ªÎ“ÓÛ“ìý“ãÒ“ªÈ“ª¤“ªÃ“ª¿“ñ§’ÊÕ“ö·“ªÇ“ªÊ“ª±“ªì“ªÐ“ªÊ“ªê“ªÞ“ª»“ªó“¡£)

=begin original

If the delimiter chosen is a single quote, no interpolation is
done on either the PATTERN or the REPLACEMENT.  Otherwise, if the
PATTERN contains a $ that looks like a variable rather than an
end-of-string test, the variable will be interpolated into the pattern
at run-time.  If you want the pattern compiled only once the first time
the variable is interpolated, use the C</o> option.  If the pattern
evaluates to the empty string, the last successfully executed regular
expression is used instead.  See L<perlre> for further explanation on these.
See L<perllocale> for discussion of additional considerations that apply
when C<use locale> is in effect.

=end original

“ª¢“ªÈ“ªÇ“âû“ªÙ“ªÞ“ª¹“ª¬“¡¢‘Çø“ï·“ªê“Ùþ“í®“ªÏ“«¹“«é“«Ã“«·“«å“ªÈ“ªÏ“ùÚ“ªê“ªÞ“ª»“ªó“¡£
“«·“«ó“«°“«ë“«¯“«©’¡¼“«È“ªò‘Çø“ï·“ªê“Ùþ“í®“ªÈ“ª·“ªÆ“ÞÅ“ªÃ“ª¿“íÞ“ùê“ªË“ªÏ“¡¢
PATTERN “ªË“ªâ REPLACEMENT “ªË“ªâ’ÊÑ‘Êý“ªÎ“î÷“ËÒ“ªò“ú¼“ªÊ“ª¤“ªÞ“ª»“ªó“¡£
“ª½“ªì“ì¤“èâ“ªÎ“íÞ“ùê“¡¢“Ùþ“í®“Öª“ªÎ“õÌ“ý­“ªò“øú“ªï“ª¹“ªâ“ªÎ“ªË“ªÏ“Ì¸“ª¨“ªÊ“ª¤ $ “ª¬
PATTERN “ªË“ùß“ªÞ“ªì“ªë“ªÈ“¡¢’¼Â“ú¼“ãÁ“ªË’ÊÑ‘Êý“ª¬“«Ñ“«¿’¡¼“«ó‘ÄÚ“ªË“î÷“ËÒ“ªµ“ªì“ªÞ“ª¹“¡£
“õÌ“ôø“ªË’ÊÑ‘Êý“ª¬“î÷“ËÒ“ªµ“ªì“ªë“ªÈ“ª­“ªË“ªÀ“ª±“«Ñ“«¿’¡¼“«ó“ªÎ“«³“«ó“«Ñ“«¤“«ë“ªò“ú¼“ªÊ“ª¤“ª¿“ª¤“ªÈ“ª­“ªË“ªÏ“¡¢
C</o> “«ª“«×“«·“«ç“«ó“ªò“ÞÅ“ªÃ“ªÆ“ª¯“ªÀ“ªµ“ª¤“¡£
“«Ñ“«¿’¡¼“«ó“ªÎ“øÄ’²Á“Ì¿“Íý“ª¬“Íö“Ùþ“í®“Öª“ªË“ªÊ“ªÃ“ª¿“íÞ“ùê“ªË“ªÏ“¡¢“õÌ“ý­“ªË“à÷“Íí“ª·“ª¿“ïá“Ð®“øú“úÞ“ª¬
“ÓÛ“ªï“ªê“ªË“ÞÅ“ªï“ªì“ªÞ“ª¹“¡£
“ª³“ªì“ªË“ªÄ“ª¤“ªÆ“ªµ“ªé“ªË“ßÙ“ª·“ª¯“ªÏ“¡¢L<perlre> “ªò‘²Î“ðÎ“ª·“ªÆ“ª¯“ªÀ“ªµ“ª¤“¡£
C<use locale> “ª¬“êó’¸ú“ªÎ“íÞ“ùê“ªÎ“ì¡“Öå“ªË“ªÄ“ª¤“ªÆ“ªÏ L<perllocale> “ªò‘²Î“ðÎ“ª·“ªÆ“ù»“ªµ“ª¤“¡£

=begin original

Options are as with m// with the addition of the following replacement
specific options:

=end original

Options are as with m// with the addition of the following replacement
specific options:
(TBT)

=begin original

    e	Evaluate the right side as an expression.
    ee  Evaluate the right side as a string then eval the result

=end original

    e   “ãÒ“ªÎ“éÓ“ö°“ªÎ“øÄ’²Á“ªò“ú¼“ªÊ“ª¦
    ee  “éÓ“ö°“ªò“Ùþ“í®“Öª“ªÈ“ª·“ªÆ“øÄ’²Á“ª·“ªÆ“¡¢“ª½“ªÎ“Ì¿“Íý“ªò“øÄ’²Á“ª¹“ªë

=begin original

Any non-alphanumeric, non-whitespace delimiter may replace the
slashes.  If single quotes are used, no interpretation is done on the
replacement string (the C</e> modifier overrides this, however).  Unlike
Perl 4, Perl 5 treats backticks as normal delimiters; the replacement
text is not evaluated as a command.  If the
PATTERN is delimited by bracketing quotes, the REPLACEMENT has its own
pair of quotes, which may or may not be bracketing quotes, e.g.,
C<s(foo)(bar)> or C<< s<foo>/bar/ >>.  A C</e> will cause the
replacement portion to be treated as a full-fledged Perl expression
and evaluated right then and there.  It is, however, syntax checked at
compile-time. A second C<e> modifier will cause the replacement portion
to be C<eval>ed before being run as a Perl expression.

=end original

“çÈ‘Êý“í®“¡¢“Íö“ÛÜ“ªÇ“ªÏ“ªÊ“ª¤“ìò“ëò“ªÎ‘Çø“ï·“ªê“Ùþ“í®“ªÇ“¡¢“«¹“«é“«Ã“«·“«å“ªò
“öÇ“ª­“üµ“ª¨“ªë“ª³“ªÈ“ª¬“ªÇ“ª­“ªÞ“ª¹“¡£
“à»“ªË“âû“ªÙ“ª¿“ªè“ª¦“ªË“¡¢“«·“«ó“«°“«ë“«¯“«©’¡¼“«È“ªò“ÞÅ“ª¦“ªÈ
“öÇ“üµ“Ùþ“í®“Öª“ªÇ“ªÎ“î÷“ËÒ“ªÏ“ªµ“ªì“ªÞ“ª»“ªó (C</e>“áó“ãÞ“í­“ªò“ÞÅ“ª¨“ªÐ“Ê¦“Òö“ªÇ“ª¹)“¡£
Perl 4 “ªÈ“êÞ“ªÃ“ªÆ“¡¢ Perl 5 “ªÏ“«Ð“«Ã“«¯“«¯“«©’¡¼“«È“ªò“÷×“ßÈ“ªÎ“«Ç“«ê“«ß“«¿“ªÈ“ª·“ªÆ“Ðâ“ª¤“ªÞ“ª¹“¡£
“öÇ“üµ“«Æ“«­“«¹“«È“ªÏ“«³“«Þ“«ó“«É“ªÈ“ª·“ªÆ“øÄ’²Á“ªµ“ªì“ªÞ“ª»“ªó“¡£
PATTERN “ªò“ÎÀ“ûÁ“×¾“ªÇ“ÎÀ“ªÃ“ª¿“íÞ“ùê“ªË“ªÏ“¡¢
REPLACEMENT “éÄ“ªË“ªâ“ª¦“ìé“ðÚ“ªÎ‘Çø“ï·“ªê“Ùþ“í®“ªò“éÄ“ëò“ª·“ªÞ“ª¹“¡£
“ª³“ªì“ªÏ“¡¢“ÎÀ“ûÁ“×¾“ªÇ“ª¢“ªÃ“ªÆ“ªâ“¡¢“ªÊ“ª¯“ªÆ“ªâ“ª«“ªÞ“ª¤“ªÞ“ª»“ªó“¡£
“ÖÇ: C<s(foo)(bar)> “ªä C<< s<foo>/bar/ >>“¡£
C</e> “ªÏ“öÇ“üµ“Ùþ“í®“Öª“ªò“èÇ“îï“ªÊ Perl “ªÎ“ãÒ“ªÈ“ª·“ªÆ“Ðâ“ª¤“¡¢“ª½“ªÎ“íÞ“á¶“ªÇ“òÁ“ªÁ“ªË“ú°’¼á“ª·“ªÞ“ª¹“¡£
“ª·“ª«“ª·“¡¢“ª³“ªì“ªÏ“«³“«ó“«Ñ“«¤“«ë“ãÁ“ªË“Ï°“Ùþ“«Á“«§“«Ã“«¯“ªµ“ªì“ªÞ“ª¹“¡£
“ì£“Ûã“ÙÍ“ªÎ C<e> “áó“ãÞ“í­“ªò“ò¦“ïÒ“ª¹“ªë“ªÈ“¡¢“öÇ“üµ“Ý»“ÝÂ“ª¬“ªÞ“ªº Perl “ªÎ“ãÒ“ªÈ“ª·“ªÆ
C<eval> “ªµ“ªì“ªÞ“ª¹“¡£

=begin original

Examples:

=end original

“ÖÇ:

    s/\bgreen\b/mauve/g;		# don't change wintergreen

    $path =~ s|/usr/bin|/usr/local/bin|;

    s/Login: $foo/Login: $bar/; # run-time pattern

    ($foo = $bar) =~ s/this/that/;	# copy first, then change

    $count = ($paragraph =~ s/Mister\b/Mr./g);  # get change-count

    $_ = 'abc123xyz';
    s/\d+/$&*2/e;		# yields 'abc246xyz'
    s/\d+/sprintf("%5d",$&)/e;	# yields 'abc  246xyz'
    s/\w/$& x 2/eg;		# yields 'aabbcc  224466xxyyzz'

    s/%(.)/$percent{$1}/g;	# change percent escapes; no /e
    s/%(.)/$percent{$1} || $&/ge;	# expr now, so /e
    s/^=(\w+)/pod($1)/ge;	# use function call

    # expand variables in $_, but dynamics only, using
    # symbolic dereferencing
    s/\$(\w+)/${$1}/g;

    # Add one to the value of any numbers in the string
    s/(\d+)/1 + $1/eg;

    # This will expand any embedded scalar variable
    # (including lexicals) in $_ : First $1 is interpolated
    # to the variable name, and then evaluated
    s/(\$\w+)/$1/eeg;

    # Delete (most) C comments.
    $program =~ s {
	/\*	# Match the opening delimiter.
	.*?	# Match a minimal number of characters.
	\*/	# Match the closing delimiter.
    } []gsx;

    s/^\s*(.*?)\s*$/$1/;	# trim whitespace in $_, expensively

    for ($variable) {		# trim whitespace in $variable, cheap
	s/^\s+//;
	s/\s+$//;
    }

    s/([^ ]*) *([^ ]*)/$2 $1/;	# reverse 1st two fields

=begin original

Note the use of $ instead of \ in the last example.  Unlike
B<sed>, we use the \<I<digit>> form in only the left hand side.
Anywhere else it's $<I<digit>>.

=end original

“õÌ“ý­“ªÎ“ÖÇ“ªÇ \ “ªÎ“ÓÛ“ªï“ªê“ªË $ “ªò“ÞÅ“ªÃ“ªÆ“ª¤“ªë“ªÎ“ªË“ñ¼“ëò“ª·“ªÆ“ª¯“ªÀ“ªµ“ª¤“¡£
B<sed> “ªÈ“êÞ“ªÃ“ªÆ“¡¢\<I<‘Êý“í®>> “ªÎ“û¡“ãÒ“ªÏ“«Ñ“«¿’¡¼“«ó“ªÎ“Û°“ªÇ“ªÎ“ªß“ÞÅ“éÄ“ªÇ“ª­“ªÞ“ª¹“¡£
“ª½“ªÎ“öâ“ªÎ“íÞ“á¶“ªÇ“ªÏ“¡¢$<I<‘Êý“í®>> “ªò“ÞÅ“ª¤“ªÞ“ª¹“¡£

=begin original

Occasionally, you can't use just a C</g> to get all the changes
to occur that you might want.  Here are two common cases:

=end original

“ªÈ“ª­“ªË“ªÏ“¡¢C</g> “ªò“Üõ“ª±“ªë“ªÀ“ª±“ªÇ“ªÏ“¡¢“ª¢“ªÊ“ª¿“ª¬“ØÐ“ªó“ªÇ“ª¤“ªë“ªè“ª¦“ªÊ“û¡“ªÇ
“ª¹“ªÙ“ªÆ“ªò’ÊÑ“ÌÚ“ª¹“ªë“ª³“ªÈ“ª¬“ªÇ“ª­“ªÊ“ª¤“ª³“ªÈ“ª¬“ª¢“ªê“ªÞ“ª¹“¡£
2 “ªÄ“ÖÇ“ªò“ãÆ“ª·“ªÞ“ª¹:

    # put commas in the right places in an integer
    1 while s/(\d)(\d\d\d)(?!\d)/$1,$2/g;

    # expand tabs to 8-column spacing
    1 while s/\t+/' ' x (length($&)*8 - length($`)%8)/e;

=back

=head2 Quote-Like Operators
X<operator, quote-like>

(“«¯“«©’¡¼“«È“ù¦“æÑ“ß©“í­)

=over 4

=item q/STRING/
X<q> X<quote, single> X<'> X<''>

=item 'STRING'

=begin original

A single-quoted, literal string.  A backslash represents a backslash
unless followed by the delimiter or another backslash, in which case
the delimiter or backslash is interpolated.

=end original

“«·“«ó“«°“«ë“«¯“«©’¡¼“«È“ªµ“ªì“ª¿“¡¢“«ê“«Æ“«é“«ë“Ùþ“í®“Öª“ªÇ“ª¹“¡£
“«Ð“«Ã“«¯“«¹“«é“«Ã“«·“«å“ªÏ“¡¢“ý­“ªí“ªË’Â³“ª¯“ªâ“ªÎ“ª¬‘Çø“ï·“Ùþ“í®“ª«“¡¢“Ü¬“ªÎ“«Ð“«Ã“«¯“«¹“«é“«Ã“«·“«å“ªÇ
“ª¢“ªë“íÞ“ùê“ªò“ð¶“ª¤“ªÆ’Ã±“ªÊ“ªë“«Ð“«Ã“«¯“«¹“«é“«Ã“«·“«å“ªÇ“ª¹“¡£
‘Çø“ï·“Ùþ“í®“ªä“«Ð“«Ã“«¯“«¹“«é“«Ã“«·“«å“ª¬’Â³“ª¯“íÞ“ùê“ªË“ªÏ“¡¢“ª½“ªÎ‘Çø“ï·“Ùþ“í®“í»“ãó“ªâ“ª·“ª¯“ªÏ
“«Ð“«Ã“«¯“«¹“«é“«Ã“«·“«å“ª½“ªÎ“ªâ“ªÎ“ª¬“î÷“ËÒ“ªµ“ªì“ªÞ“ª¹“¡£

    $foo = q!I said, "You said, 'She said it.'"!;
    $bar = q('This is it.');
    $baz = '\n';		# a two-character string

=item qq/STRING/
X<qq> X<quote, double> X<"> X<"">

=item "STRING"

=begin original

A double-quoted, interpolated string.

=end original

“«À“«Ö“«ë“«¯“«©’¡¼“«È“ªµ“ªì“ª¿“¡¢“«ê“«Æ“«é“«ë“Ùþ“í®“Öª“ªÇ“ª¹“¡£

    $_ .= qq
     (*** The previous line contains the naughty word "$1".\n)
		if /\b(tcl|java|python)\b/i;      # :-)
    $baz = "\n";		# a one-character string

=item qx/STRING/
X<qx> X<`> X<``> X<backtick>

=item `STRING`

=begin original

A string which is (possibly) interpolated and then executed as a
system command with C</bin/sh> or its equivalent.  Shell wildcards,
pipes, and redirections will be honored.  The collected standard
output of the command is returned; standard error is unaffected.  In
scalar context, it comes back as a single (potentially multi-line)
string, or undef if the command failed.  In list context, returns a
list of lines (however you've defined lines with $/ or
$INPUT_RECORD_SEPARATOR), or an empty list if the command failed.

=end original

“î÷“ËÒ“ªµ“ªì“¡¢C</bin/sh> “ªÞ“ª¿“ªÏ“ª½“ªì“ªÈ“Ôõ’²Á“ªÊ“ªâ“ªÎ“ªÇ“«·“«¹“«Æ“«à“ªÎ“«³“«Þ“«ó“«É“ªÈ“ª·“ªÆ
’¼Â“ú¼“ªµ“ªì“ªë(“ªÇ“ª¢“ªí“ª¦)“Ùþ“í®“Öª“ªÇ“ª¹“¡£
“«·“«§“«ë“ªÎ“«ï“«¤“«ë“«É“««’¡¼“«É“¡¢“«Ñ“«¤“«×“¡¢“«ê“«À“«¤“«ì“«¯“«È“ª¬“êó’¸ú“ªÇ“ª¹“¡£
“ª½“ªÎ“«³“«Þ“«ó“«É“ªÎ“¡¢“øö“ñÞ“õó“Õô“ªò“ó¢“ªá“ª¿“ªâ“ªÎ“ª¬“Ú÷“ªµ“ªì“ªÞ“ª¹“¡£
“øö“ñÞ“«¨“«é’¡¼“ªÏ“ç¯“úÂ“ªò‘Óë“ª¨“ªÞ“ª»“ªó“¡£
“«¹“««“«é“«³“«ó“«Æ“«­“«¹“«È“ªÇ“ªÏ“¡¢(“ÜÜ‘Êý“ú¼“ªò“ùß“ªà“ª«“ªâ“ª·“ªì“ªÊ“ª¤)
1 “ªÄ“ªÎ“Ùþ“í®“Öª“ª¬’Ìá“ªÃ“ªÆ“ª­“ªÞ“ª¹“¡£
“«³“«Þ“«ó“«É“ª¬“ã÷“ø¨“ª·“ª¿“ªÈ“ª­“ªÏ“Ú±“ïÒ“ëù“ö·“ªò“Ú÷“ª·“ªÞ“ª¹“¡£
“«ê“«¹“«È“«³“«ó“«Æ“«­“«¹“«È“ªÇ“ªÏ“¡¢($/ “ªâ“ª·“ª¯“ªÏ $INPUT_RECORD_SEPARATOR “ªò
“ªÉ“ªÎ“ªè“ª¦“ªË“àâ“ïÒ“ª·“ªÆ“ª¤“ªÆ“ªâ) “ú¼“ªÎ“«ê“«¹“«È“ªò“Ú÷“ª·“ªÞ“ª¹“¡£
“«³“«Þ“«ó“«É“ª¬“ã÷“ø¨“ª·“ª¿“ªÈ“ª­“ªÏ“Íö“«ê“«¹“«È“ªò“Ú÷“ª·“ªÞ“ª¹“¡£

=begin original

Because backticks do not affect standard error, use shell file descriptor
syntax (assuming the shell supports this) if you care to address this.
To capture a command's STDERR and STDOUT together:

=end original

“«Ð“«Ã“«¯“«¯“«©’¡¼“«È“ªÏ“øö“ñÞ“«¨“«é’¡¼“ªË“ªÏ“ç¯“úÂ“ªò‘Óë“ª¨“ªÊ“ª¤“ªÎ“ªÇ“¡¢
“øö“ñÞ“«¨“«é’¡¼“ªò“ÞÅ“ª¤“ª¿“ª¤“íÞ“ùê“ªÏ(“«·“«§“«ë“ª¬’ÂÐ’±þ“ª·“ªÆ“ª¤“ªë“ªâ“ªÎ“ªÈ“ª·“ªÆ)
“«·“«§“«ë“ªÎ“«Õ“«¡“«¤“«ë“ÑÀ“âû“í­“ªÎ“Ùþ“Ûö“ªò“ÞÅ“ªÃ“ªÆ“ª¯“ªÀ“ªµ“ª¤“¡£
“«³“«Þ“«ó“«É“ªÎ STDERR “ªÈ STDOUT “ªò“Íì“ªË“ö¢“Ôð“ª·“ª¿“ª¤“íÞ“ùê“ªÏ:

    $output = `cmd 2>&1`;

=begin original

To capture a command's STDOUT but discard its STDERR:

=end original

“«³“«Þ“«ó“«É“ªÎ STDOUT “ªÏ“ö¢“Ôð“ª¹“ªë“ª¬ STDERR “ªÏ“Þ×“ªÆ“ªë“íÞ“ùê“ªÏ:

    $output = `cmd 2>/dev/null`;

=begin original

To capture a command's STDERR but discard its STDOUT (ordering is
important here):

=end original

“«³“«Þ“«ó“«É“ªÎ STDERR “ªÏ“ö¢“Ôð“ª¹“ªë“ª¬ STDOUT “ªÏ“Þ×“ªÆ“ªë“íÞ“ùê“ªÏ
(“ª³“ª³“ªÇ“ªÏ“â÷“ßí“ª¬“ñì“é©“ªÇ“ª¹):

    $output = `cmd 2>&1 1>/dev/null`;

=begin original

To exchange a command's STDOUT and STDERR in order to capture the STDERR
but leave its STDOUT to come out the old STDERR:

=end original

STDERR “ªò“ö¢“Ôð“ª¹“ªë“ª¬“¡¢STDOUT “ªÏ“Í¯“ª¤ STDERR “ªÎ“ª¿“ªá“ªË‘²Ð“ª·“ªÆ“ªª“ª¯“ª¿“ªá“ªË
STDOUT “ªÈ STDERR “ªò“Îß“üµ“ª¹“ªë“ªË“ªÏ:

    $output = `cmd 3>&1 1>&2 2>&3 3>&-`;

=begin original

To read both a command's STDOUT and its STDERR separately, it's easiest
to redirect them separately to files, and then read from those files
when the program is done:

=end original

“«³“«Þ“«ó“«É“ªÎ STDOUT “ªÈ STDERR “ªÎ’Î¾“Û°“ªò“Ü¬‘¡©“ªË’ÆÉ“ªß’¹þ“ªß“ª¿“ª¤“íÞ“ùê“¡¢
“ìé“Ûã“ÊÛ’Ã±“ªÊ“Û°“Ûö“ªÏ“Ü¬‘¡©“ªÎ“«Õ“«¡“«¤“«ë“ªË“«ê“«À“«¤“«ì“«¯“«È“ª·“¡¢
“«×“«í“«°“«é“«à“ª¬“ðû“Öõ“ª·“ªÆ“ª«“ªé“ª½“ªÎ“«Õ“«¡“«¤“«ë“ªò’ÆÉ“ªà“ª³“ªÈ“ªÇ“ª¹:

    system("program args 1>program.stdout 2>program.stderr");

=begin original

The STDIN filehandle used by the command is inherited from Perl's STDIN.
For example:

=end original

“«³“«Þ“«ó“«É“ªË“ªè“ªÃ“ªÆ“ÞÅ“ªï“ªì“ªë STDIN “«Õ“«¡“«¤“«ë“«Ï“«ó“«É“«ë“ªÏ Perl “ªÎ STDIN “ªò
’·Ñ“ã¯“ª·“ªÞ“ª¹“¡£
“ÖÇ“ª¨“ªÐ:

    open BLAM, "blam" || die "Can't open: $!";
    open STDIN, "<&BLAM";
    print `sort`;

=begin original

will print the sorted contents of the file "blam".

=end original

“ªÏ“«Õ“«¡“«¤“«ë "blam" “ªÎ‘ÄÚ“é»“ªò“«½’¡¼“«È“ª·“ªÆ“øú“ãÆ“ª·“ªÞ“ª¹“¡£

=begin original

Using single-quote as a delimiter protects the command from Perl's
double-quote interpolation, passing it on to the shell instead:

=end original

“«·“«ó“«°“«ë“«¯“«©’¡¼“«È“ªò“«Ç“«ê“«ß“«¿“ªÈ“ª·“ªÆ“ÞÅ“ª¦“ªÈ Perl “ªÎ“«À“«Ö“«ë“«¯“«©’¡¼“«È“î÷“ËÒ“ª«“ªé
“ÜÁ“ûÞ“ªµ“ªì“¡¢“ª½“ªÎ“ªÞ“ªÞ“«·“«§“«ë“ªË“Ô¤“ªµ“ªì“ªÞ“ª¹:

    $perl_info  = qx(ps $$);            # that's Perl's $$
    $shell_info = qx'ps $$';            # that's the new shell's $$

=begin original

How that string gets evaluated is entirely subject to the command
interpreter on your system.  On most platforms, you will have to protect
shell metacharacters if you want them treated literally.  This is in
practice difficult to do, as it's unclear how to escape which characters.
See L<perlsec> for a clean and safe example of a manual fork() and exec()
to emulate backticks safely.

=end original

“ª³“ªÎ“Ùþ“í®“Öª“ª¬“ªÉ“ªÎ“ªè“ª¦“ªË“øÄ’²Á“ªµ“ªì“ªë“ª«“ªÏ“èÇ“îï“ªË“«·“«¹“«Æ“«à“ªÎ
“«³“«Þ“«ó“«É“«¤“«ó“«¿“«×“«ê“«¿“ªË“ëî“ðí“ª·“ªÞ“ª¹“¡£
“ªÛ“ªÈ“ªó“ªÉ“ªÎ“«×“«é“«Ã“«È“«Õ“«©’¡¼“«à“ªÇ“ªÏ“¡¢“«·“«§“«ë“ªÎ“«á“«¿“«­“«ã“«é“«¯“«¿“ªò
“«ê“«Æ“«é“«ë“ªË“Ðâ“ªÃ“ªÆ“ªÛ“ª·“ª¤“íÞ“ùê“ªÏ“ª½“ªì“ªò“áú“ªë“ù±“é©“ª¬“ª¢“ªê“ªÞ“ª¹“¡£
“Ùþ“í®“ªò“«¨“«¹“«±’¡¼“«×“ª¹“ªë“Û°“Ûö“ª¬“Ù¥“ü¬“ªÇ“ªÏ“ªÊ“ª¤“ªÎ“ªÇ“¡¢“ª³“ªì“ªÏ“×â“Öå“îÜ“ªË“ªÏ“Ññ“ª·“ª¤“ª³“ªÈ“ªÇ“ª¹“¡£
“æ½“«¯“«©’¡¼“«È“ªò“äÌ“îï“ªË“«¨“«ß“«å“«ì’¡¼“«È“ª¹“ªë“ª¿“ªá“ªË“â¢“ÔÑ“ªÇ fork() “ªÈ exec() “ªò
“ú¼“ª¦“ª¿“ªá“ªÎ“ª­“ªì“ª¤“ªÇ“äÌ“îï“ªÊ“ÖÇ“ªË“ªÄ“ª¤“ªÆ“ªÏ L<perlsec> “ªò‘²Î“ðÎ“ª·“ªÆ“ª¯“ªÀ“ªµ“ª¤“¡£

=begin original

On some platforms (notably DOS-like ones), the shell may not be
capable of dealing with multiline commands, so putting newlines in
the string may not get you what you want.  You may be able to evaluate
multiple commands in a single line by separating them with the command
separator character, if your shell supports that (e.g. C<;> on many Unix
shells; C<&> on the Windows NT C<cmd> shell).

=end original

(“÷å“ªË DOS “ù¦“ªÎ)“«×“«é“«Ã“«È“«Õ“«©’¡¼“«à“ªË“ªÏ“¡¢“«·“«§“«ë“ª¬“ÜÜ‘Êý“ú¼“ªÎ“«³“«Þ“«ó“«É“ªò
“Ðâ“ª¦“ª³“ªÈ“ª¬“ªÇ“ª­“ªÊ“ª¤“ªâ“ªÎ“ª¬“ª¢“ªë“ªÎ“ªÇ“¡¢“Ùþ“í®“Öª“ªË“ËÇ“ú¼“ªò“ìý“ªì“ªë“ªÈ
“ª¢“ªÊ“ª¿“ªÎ“ØÐ“ªÞ“ªÊ“ª¤“Ì¿“Íý“ªË“ªÊ“ªë“íÞ“ùê“ª¬“ª¢“ªê“ªÞ“ª¹“¡£
“«·“«§“«ë“ª¬’ÂÐ’±þ“ª·“ªÆ“ª¤“ªì“ªÐ“¡¢“«³“«Þ“«ó“«É“ÝÂ“ùÜ“Ùþ“í®“ªÇ“ÝÂ“ùÜ“ª¹“ªë“ª³“ªÈ“ªÇ
1 “ú¼“ªË“ÜÜ‘Êý“ªÎ“«³“«Þ“«ó“«É“ªò“ìý“ªì“ªÆ“ú°’¼á“ªµ“ª»“ªë“ª³“ªÈ“ª¬“ªÇ“ª­“ªÞ“ª¹
(“ª³“ªÎ“Ùþ“í®“ªÏ“¡¢“Òý“ª¯“ªÎ Unix “«·“«§“«ë“ªÇ“ªÏ C<;>“¡¢Windows NT C<cmd> “«·“«§“«ë“ªÇ“ªÏ
C<&> “ªÇ“ª¹)“¡£

=begin original

Beginning with v5.6.0, Perl will attempt to flush all files opened for
output before starting the child process, but this may not be supported
on some platforms (see L<perlport>).  To be safe, you may need to set
C<$|> ($AUTOFLUSH in English) or call the C<autoflush()> method of
C<IO::Handle> on any open handles.

=end original

v5.6.0 “ì¤“Ë½“¡¢Perl “ªÏ“í­“«×“«í“«»“«¹“ªÎ’¼Â“ú¼“îñ“ªË“ßö“ª­’¹þ“ªß“éÄ“ªË“ËÒ“ª¤“ªÆ“ª¤“ªë“îï“ªÆ“ªÎ
“«Õ“«¡“«¤“«ë“ªò“«Õ“«é“«Ã“«·“«å“ª·“ªè“ª¦“ªÈ“ª·“ªÞ“ª¹“ª¬“¡¢“ª³“ªì“ªË’ÂÐ’±þ“ª·“ªÆ“ª¤“ªÊ“ª¤
“«×“«é“«Ã“«È“«Õ“«©’¡¼“«à“ªâ“ª¢“ªê“ªÞ“ª¹(L<perlport> “ªò‘²Î“ðÎ“ª·“ªÆ“ª¯“ªÀ“ªµ“ª¤)“¡£
“äÌ“îï“ªÎ“ª¿“ªá“ªË“ªÏ“¡¢C<$|> (English “«â“«¸“«å’¡¼“«ë“ªÇ“ªÏ $AUTOFLUSH)“ªò“«»“«Ã“«È“ª¹“ªë“ª«“¡¢
“ËÒ“ª¤“ªÆ“ª¤“ªë“îï“ªÆ“ªÎ“«Ï“«ó“«É“«ë“ªË’ÂÐ“ª·“ªÆ C<IO::Handle> “ªÎ C<autoflush()> “«á“«½“«Ã“«É“ªò
“û¼“ªÓ“õó“ª¹“ù±“é©“ª¬“ª¢“ªê“ªÞ“ª¹“¡£

=begin original

Beware that some command shells may place restrictions on the length
of the command line.  You must ensure your strings don't exceed this
limit after any necessary interpolations.  See the platform-specific
release notes for more details about your particular environment.

=end original

“«³“«Þ“«ó“«É“ú¼“ªÎ“íþ“ªµ“ªË“ð¤“ùÚ“ª¬“ª¢“ªë“«³“«Þ“«ó“«É“«·“«§“«ë“ª¬“ª¢“ªë“ª³“ªÈ“ªË“ñ¼“ëò“ª·“ªÆ“ª¯“ªÀ“ªµ“ª¤“¡£
“îï“ªÆ“ªÎ“ù±“é©“ªÊ’ÊÑ“üµ“ª¬“ú¼“ªï“ªì“ª¿“ý­“¡¢“«³“«Þ“«ó“«É“Ùþ“í®“Öª“ª¬“ª³“ªÎ“ð¤“ùÚ“ªò“êÆ“ª¨“ªÊ“ª¤“ª³“ªÈ“ªò
“ÜÁ“î¡“ª¹“ªë“ù±“é©“ª¬“ª¢“ªê“ªÞ“ª¹“¡£
“÷å“ïÒ“ªÎ“ü»“ÌÑ“ªË’´Ø“ª¹“ªë“ªµ“ªé“ªÊ“ªë“ßÙ“á¬“ªË“ªÄ“ª¤“ªÆ“ªÏ“«×“«é“«Ã“«È“«Õ“«©’¡¼“«à“Í³“êó“ªÎ
“«ê“«ê’¡¼“«¹“«Î’¡¼“«È“ªò‘²Î“ðÎ“ª·“ªÆ“ª¯“ªÀ“ªµ“ª¤“¡£

=begin original

Using this operator can lead to programs that are difficult to port,
because the shell commands called vary between systems, and may in
fact not be present at all.  As one example, the C<type> command under
the POSIX shell is very different from the C<type> command under DOS.
That doesn't mean you should go out of your way to avoid backticks
when they're the right way to get something done.  Perl was made to be
a glue language, and one of the things it glues together is commands.
Just understand what you're getting yourself into.

=end original

“ª³“ªÎ“æÑ“ß©“í­“ªò“ÞÅ“ª¦“ªÈ“¡¢“«×“«í“«°“«é“«à“ªÎ“ì¹“ãÖ“ª¬“ÍÝ“Ññ“ªË“ªÊ“ªê“ªÞ“ª¹“¡£
“û¼“ªÓ“õó“ªµ“ªì“ªë“«·“«§“«ë“«³“«Þ“«ó“«É“ªÏ“«·“«¹“«Æ“«à“ªË“ªè“ªÃ“ªÆ“ì¶“ªÊ“ªê“¡¢
’¼Â“ð·“îï“ª¯“ðí“î¤“ª·“ªÊ“ª¤“ª³“ªÈ“ªâ“ª¢“ªë“ª«“ªé“ªÇ“ª¹“¡£
“ìé“ªÄ“ªÎ“ÖÇ“ªÈ“ª·“ªÆ“ªÏ“¡¢POSIX “«·“«§“«ë“ªÎ C<type> “«³“«Þ“«ó“«É“ªÏ
DOS “ªÎ C<type> “«³“«Þ“«ó“«É“ªÈ“ÓÞ“ª­“ª¯“ì¶“ªÊ“ªÃ“ªÆ“ª¤“ªÞ“ª¹“¡£
“ª³“ªì“ªÏ“¡¢“ù¼“ª«“ªò˜´´“ª¹“ª¿“ªá“ªË“ïá“ª·“ª¤“Û°“Ûö“ªÈ“ª·“ªÆ“æ½“«¯“«©’¡¼“«È“ªò“ÞÅ“ª¦“ª³“ªÈ“ªò
“ù­“ª±“ªë“ªÙ“ª­“ªÇ“ª¢“ªë“ª³“ªÈ“ªò“ëò“Ú«“ª·“ªÞ“ª»“ªó“¡£
Perl “ªÏ“ïÈ“ó·’ºÞ“ªÎ“ªè“ª¦“ªÊ“åë“åÞ“ªÈ“ª·“ªÆ“íÂ“ªé“ªì“¡¢“ïÈ“ó·“ªµ“ªì“ªë“ªÙ“ª­“ªâ“ªÎ“ªÎ“ìé“ªÄ“ªÏ
“«³“«Þ“«ó“«É“ªÇ“ª¹“¡£
’Ã±“ªË“ª¢“ªÊ“ª¿“ª¬“ù¼“ªò“ª·“ªè“ª¦“ªÈ“ª·“ªÆ“ª¤“ªë“ª«“ªò“×â“ú°“ª·“ªÆ“ªª“ª¤“ªÆ“ª¯“ªÀ“ªµ“ª¤“¡£

=begin original

See L</"I/O Operators"> for more discussion.

=end original

“ªµ“ªé“ªÊ“ªë“ì¡“Öå“ªË“ªÄ“ª¤“ªÆ“ªÏ L</"I/O Operators"> “ªò‘²Î“ðÎ“ª·“ªÆ“ù»“ªµ“ª¤“¡£

=item qw/STRING/
X<qw> X<quote, list> X<quote, words>

=begin original

Evaluates to a list of the words extracted out of STRING, using embedded
whitespace as the word delimiters.  It can be understood as being roughly
equivalent to:

=end original

“ØØ“ªá’¹þ“ªÞ“ªì“ª¿“Íö“ÛÜ“ªò‘Çø“ï·“Ùþ“í®“ªÈ“ª·“ªÆ“¡¢STRING “ª«“ªé’È´“ª­“õó“ª·“ª¿
’Ã±“åÞ“ªÎ“«ê“«¹“«È“ªò“øÄ’²Á“ª·“ªÞ“ª¹“¡£
“ª³“ªì“ªÏ“¡¢“ì¤“ù»“ªÎ“ãÒ“ªÈ“ÓÞ‘Ìå“ÔÒ“ª¸“ªÈ“ÍÅ“ª¨“ªé“ªì“ªÞ“ª¹:

    split(' ', q/STRING/);

=begin original

the differences being that it generates a real list at compile time, and
in scalar context it returns the last element in the list.  So
this expression:

=end original

“êÞ“ª¤“ªÏ“¡¢’¼Â“ð·“ªÎ“«ê“«¹“«È“ªò“«³“«ó“«Ñ“«¤“«ë“ãÁ“ªË“ßæ“à÷“ª·“¡¢“«¹“««“«é“«³“«ó“«Æ“«­“«¹“«È“ªÇ“ªÏ“«ê“«¹“«È“ªÎ
“õÌ“ý­“ªÎ“é©“áÈ“ªò“Ú÷“ª¹“ª³“ªÈ“ªÇ“ª¹“¡£
’½¾“ªÃ“ªÆ“¡¢“ì¤“ù»“ªÎ“øú“úÞ“ªÏ:

    qw(foo bar baz)

=begin original

is semantically equivalent to the list:

=end original

“ì¤“ù»“ªÎ“«ê“«¹“«È“ªÈ“Ùþ“Ûö“îÜ“ªË“Ôõ’²Á“ªÇ“ª¹“¡£

    'foo', 'bar', 'baz'

=begin original

Some frequently seen examples:

=end original

“ªè“ª¯“ú¼“ªÊ“ªï“ªì“ªë“ÖÇ“ªÈ“ª·“ªÆ“ªÏ“ì¤“ù»“ªÎ“ªâ“ªÎ“ªÇ“ª¹:

    use POSIX qw( setlocale localeconv )
    @EXPORT = qw( foo bar baz );

=begin original

A common mistake is to try to separate the words with comma or to
put comments into a multi-line C<qw>-string.  For this reason, the
C<use warnings> pragma and the B<-w> switch (that is, the C<$^W> variable)
produces warnings if the STRING contains the "," or the "#" character.

=end original

“ªè“ª¯“ª¢“ªë“Êà“êÞ“ª¤“ªÏ“¡¢’Ã±“åÞ“ªò“««“«ó“«Þ“ªÇ‘Çø“ï·“ªÃ“ª¿“ªê“¡¢“ÜÜ‘Êý“ú¼“ªÎ C<qw> “Ùþ“í®“Öª“ªÎ“ñé“ªË
“«³“«á“«ó“«È“ªò“ßö“ª¤“ª¿“ªê“ª¹“ªë“ª³“ªÈ“ªÇ“ª¹“¡£
“ª³“ªÎ“ª¿“ªá“ªË“¡¢C<usr warnings> “«×“«é“«°“«Þ“ªÈ B<-w> “«¹“«¤“«Ã“«Á
(“ªÄ“ªÞ“ªê“¡¢C<$^W> ’ÊÑ‘Êý) “ªÏ STRING “ªË "," “ªä "#" “ªÎ“Ùþ“í®“ª¬“ìý“ªÃ“ªÆ“ª¤“ªë“ªÈ
“Ìí“Í±“ªò“õó“ª·“ªÞ“ª¹“¡£


=item tr/SEARCHLIST/REPLACEMENTLIST/cds
X<tr> X<y> X<transliterate> X</c> X</d> X</s>

=item y/SEARCHLIST/REPLACEMENTLIST/cds

=begin original

Transliterates all occurrences of the characters found in the search list
with the corresponding character in the replacement list.  It returns
the number of characters replaced or deleted.  If no string is
specified via the =~ or !~ operator, the $_ string is transliterated.  (The
string specified with =~ must be a scalar variable, an array element, a
hash element, or an assignment to one of those, i.e., an lvalue.)

=end original

’¸¡“ßã“«ê“«¹“«È (SEARCHLIST) “ªË“ùß“ªÞ“ªì“ªë“Ùþ“í®“ªò“¡¢’ÂÐ’±þ“ª¹“ªë“öÇ“üµ“«ê“«¹“«È
(REPLACEMENTLIST) “ªÎ“Ùþ“í®“ªË’ÊÑ“üµ“ª·“ªÞ“ª¹“¡£
“öÇ“üµ“ªÞ“ª¿“ªÏ“Þû“ð¶“ª¬“ú¼“ªÊ“ªï“ªì“ª¿“¡¢“Ùþ“í®‘Êý“ªò“Ú÷“ª·“ªÞ“ª¹“¡£
=~ “æÑ“ß©“í­“ªä =! “æÑ“ß©“í­“ªÇ“Ùþ“í®“Öª“ª¬“ò¦“ïÒ“ªµ“ªì“ªÆ“ª¤“ªÊ“ª±“ªì“ªÐ“¡¢$_ “ªÎ“Ùþ“í®“Öª“ª¬’ÊÑ“üµ“ªµ“ªì“ªÞ“ª¹“¡£
(=~ “ªÇ“ò¦“ïÒ“ªµ“ªì“ªë“Ùþ“í®“Öª“ªÏ“¡¢“«¹“««“«é’ÊÑ‘Êý“¡¢“ÛÕ“Öª“é©“áÈ“¡¢“«Ï“«Ã“«·“«å“é©“áÈ“¡¢
“ª¢“ªë“ª¤“ªÏ“ª³“ªì“ªé“ªØ“ªÎ“ÓÛ“ìý“ãÒ“ªÈ“ª¤“ªÃ“ª¿“ñ§’ÊÕ“ö·“ªÇ“ªÊ“ª±“ªì“ªÐ“ªÊ“ªê“ªÞ“ª»“ªó“¡£)

=begin original

A character range may be specified with a hyphen, so C<tr/A-J/0-9/>
does the same replacement as C<tr/ACEGIBDFHJ/0246813579/>.
For B<sed> devotees, C<y> is provided as a synonym for C<tr>.  If the
SEARCHLIST is delimited by bracketing quotes, the REPLACEMENTLIST has
its own pair of quotes, which may or may not be bracketing quotes,
e.g., C<tr[A-Z][a-z]> or C<tr(+\-*/)/ABCD/>.

=end original

“Ùþ“í®“ªÎ“Ûô’°Ï“ªÏ“«Ï“«¤“«Õ“«ó“ªò“ÞÅ“ªÃ“ªÆ“ò¦“ïÒ“ªÇ“ª­“ªÞ“ª¹“¡£
C<tr/A-J/0-9/> “ªÏ C<tr/ACEGIBDFHJ/0246813579/> “ªÈ“ÔÒ“ª¸“öÇ“üµ“ªò“ú¼“ª¤“ªÞ“ª¹“¡£
B<sed> “ªÎ“ãá“äæ“íº“ªÎ“ª¿“ªá“ªË C<y> “ª¬ C<tr> “ªÎ“ÔÒ“ëù“åÞ“ªÈ“ª·“ªÆ“ð«“Íê“ªµ“ªì“ªÆ“ª¤“ªÞ“ª¹“¡£
SEARCHLIST “ªò“ÎÀ“ûÁ“×¾“ªÇ“ÎÀ“ªÃ“ª¿“íÞ“ùê“ªË“ªÏ“¡¢
REPLACEMENTLIST “éÄ“ªË“¡¢“ªâ“ª¦“ìé“ðÚ“ªÎ‘Çø“ï·“ªê“Ùþ“í®“ªò“éÄ“ëò“ª·“ªÞ“ª¹“¡£
“ª³“ªì“ªÏ“¡¢“ÎÀ“ûÁ“×¾“ªÇ“ª¢“ªÃ“ªÆ“ªâ“¡¢“ªÊ“ª¯“ªÆ“ªâ“ª«“ªÞ“ª¤“ªÞ“ª»“ªó“¡£
“ÖÇ: C<tr[A-Z][a-z]> “ªä C<tr(+\-*/)/ABCD/>“¡£

=begin original

Note that C<tr> does B<not> do regular expression character classes
such as C<\d> or C<[:lower:]>.  The C<tr> operator is not equivalent to
the tr(1) utility.  If you want to map strings between lower/upper
cases, see L<perlfunc/lc> and L<perlfunc/uc>, and in general consider
using the C<s> operator if you need regular expressions.

=end original

C<tr> “ªÏ C<\d> “ªä C<[:lower:]> “ªÈ“ª¤“ªÃ“ª¿“ïá“Ð®“øú“úÞ“Ùþ“í®“«¯“«é“«¹“ªò
B<“ÞÅ“ªï“ªÊ“ª¤> “ª³“ªÈ“ªË“ñ¼“ëò“ª·“ªÆ“ª¯“ªÀ“ªµ“ª¤“¡£
C<tr> “æÑ“ß©“í­“ªÏ tr(1) “«æ’¡¼“«Æ“«£“«ê“«Æ“«£“ªÈ“Ôõ’²Á“ªÇ“ªÏ“ª¢“ªê“ªÞ“ª»“ªó“¡£
“Ùþ“í®“Öª“ªÎ“ÓÞ“Ùþ“í®“á³“Ùþ“í®“ªò“«Þ“«Ã“«×“ª·“ª¿“ª¤“íÞ“ùê“ªÏ“¡¢
L<perlfunc/lc> “ªÈ L<perlfunc/uc> “ªò‘²Î“ðÎ“ª·“ªÆ“ù»“ªµ“ª¤“¡£
“ªÞ“ª¿“ïá“Ð®“øú“úÞ“ª¬“ù±“é©“ªÊ“íÞ“ùê“ªË“ªÏ“ìé“Úõ“îÜ“ªË C<s> “æÑ“ß©“í­“ªò“ÞÅ“ª¦“ª³“ªÈ“ªò
“ÍÅ“Õç“ª·“ªÆ“ªß“ªÆ“ª¯“ªÀ“ªµ“ª¤“¡£

=begin original

Note also that the whole range idea is rather unportable between
character sets--and even within character sets they may cause results
you probably didn't expect.  A sound principle is to use only ranges
that begin from and end at either alphabets of equal case (a-e, A-E),
or digits (0-4).  Anything else is unsafe.  If in doubt, spell out the
character sets in full.

=end original

“Ûô’°Ï“ò¦“ïÒ“ªÈ“ª¤“ª¦“ÍÅ“ª¨“Û°“ªÏ“Ùþ“í®“«»“«Ã“«È“ª¬“ì¶“ªÊ“ªë“íÞ“ùê“ªÏ“ªä“ªä“ì¹“ãÕ“àõ“ªË“ýâ“ª±“ªë“ª³“ªÈ“ªË“ªâ
“ñ¼“ëò“ª·“ªÆ“ª¯“ªÀ“ªµ“ª¤ -- “ª½“ª·“ªÆ“ÔÒ“ª¸“Ùþ“í®“«»“«Ã“«È“ªÇ“ªâ“Íð“ªé“ª¯“Ñ¢“Óâ“ª·“ªÆ“ª¤“ªë“ªÎ“ªÈ“ªÏ“êÞ“ª¦
“Ì¿“Íý“ªò“ìÚ“ª­“ÑÃ“ª³“ª¹“ª³“ªÈ“ªâ“ª¢“ªê“ªÞ“ª¹“¡£
“Ëí“îï“ªÊ“ê«“öÎ“ªÈ“ª·“ªÆ“ªÏ“¡¢“Ûô’°Ï“ªÎ“õÌ“ôø“ªÈ“õÌ“ý­“ªò“ªÉ“ªÁ“ªé“ªâ“«¢“«ë“«Õ“«¡“«Ù“«Ã“«È
(“ÓÞ“Ùþ“í®“á³“Ùþ“í®“ªâ“ÔÒ“ª¸)(a-e, A-E)“ªË“ª¹“ªë“ª«“¡¢“ªÉ“ªÁ“ªé“ªâ‘Êý“í®“ªË“ª¹“ªë(0-4)“ª³“ªÈ“ªÇ“ª¹“¡£
“ª½“ªì“ì¤“èâ“ªÏ“îï“ªÆ“äÌ“îï“ªÇ“ªÏ“ª¢“ªê“ªÞ“ª»“ªó“¡£
“ë÷“ªï“ª·“ª¤“ªÈ“ª­“ªÏ“¡¢“Ùþ“í®“«»“«Ã“«È“ªò“èÇ“îï“ªË“ßö“ª­“õó“ª·“ªÆ“ª¯“ªÀ“ªµ“ª¤“¡£

=begin original

Options:

=end original

“«ª“«×“«·“«ç“«ó“ªÏ“ì¤“ù»“ªÎ“÷×“ªê“ªÇ“ª¹:

=begin original

    c	Complement the SEARCHLIST.
    d	Delete found but unreplaced characters.
    s	Squash duplicate replaced characters.

=end original

    c   SEARCHLIST “ªò“ÜÍ“ó¢“ùê“ªË“ª¹“ªë
    d   “Ì¸“ªÄ“ª«“ªÃ“ª¿“ª¬“öÇ“üµ“ªµ“ªì“ªÊ“ª«“ªÃ“ª¿“Ùþ“í®“ªò“Þû“ð¶“ª¹“ªë
    s   “öÇ“üµ“ªµ“ªì“ª¿“Ùþ“í®“ª¬“ñì“ªÊ“ªÃ“ª¿“ªÈ“ª­“ªË’°µ“õê“ª¹“ªë

=begin original

If the C</c> modifier is specified, the SEARCHLIST character set
is complemented.  If the C</d> modifier is specified, any characters
specified by SEARCHLIST not found in REPLACEMENTLIST are deleted.
(Note that this is slightly more flexible than the behavior of some
B<tr> programs, which delete anything they find in the SEARCHLIST,
period.) If the C</s> modifier is specified, sequences of characters
that were transliterated to the same character are squashed down
to a single instance of the character.

=end original

C</c> “áó“ãÞ“í­“ª¬“ò¦“ïÒ“ªµ“ªì“ªë“ªÈ“¡¢SEARCHLIST “ªË“ªÏ“ÜÍ“ó¢“ùê“ª¬“ò¦“ïÒ“ªµ“ªì“ª¿“ªâ“ªÎ“ªÈ
“ú°’¼á“ªµ“ªì“ªÞ“ª¹“¡£
C</d> “áó“ãÞ“í­“ª¬“ò¦“ïÒ“ªµ“ªì“ªë“ªÈ“¡¢SEARCHLIST “ªË“ò¦“ïÒ“ªµ“ªì“ªÆ“¡¢
REPLACEMENTLIST “ªË’ÂÐ’±þ“ª¹“ªë“ªâ“ªÎ“ª¬“ªÊ“ª¤“Ùþ“í®“ª¬“Þû“ð¶“ªµ“ªì“ªÞ“ª¹“¡£
(“ª³“ªì“ªÏ“¡¢SEARCHLIST “ªÇ“Ì¸“ªÄ“ª«“ªÃ“ª¿“ªâ“ªÎ“ªò“Þû“ð¶“ª¹“ªë“¡¢“ª¿“ªÀ“ª½“ªì“ªÀ“ª±“ªÎ“¡¢“ª¢“ªë“ðú“ªÎ
B<tr> “«×“«í“«°“«é“«à“ªÎ“ÔÑ“íÂ“ªè“ªê“ªÈ“Ýï“ªÙ“ªì“ªÐ“¡¢“ª¤“ª¯“ÝÂ“êõ“æã“ªÊ“ªâ“ªÎ“ªË“ªÊ“ªÃ“ªÆ“ª¤“ªÞ“ª¹“¡£)
C</s> “áó“ãÞ“í­“ª¬“ò¦“ïÒ“ªµ“ªì“ªë“ªÈ“¡¢“ÔÒ“ª¸“Ùþ“í®“ªË“Ùþ“í®’ÊÑ“üµ“ªµ“ªì“ª¿“Ùþ“í®“ªÎ˜­å“ªÓ“ªò“¡¢
“ª½“ªÎ“Ùþ“í® 1 “Ùþ“í®“ªÀ“ª±“ªË’°µ“õê“ª·“ªÞ“ª¹“¡£“¡¡

=begin original

If the C</d> modifier is used, the REPLACEMENTLIST is always interpreted
exactly as specified.  Otherwise, if the REPLACEMENTLIST is shorter
than the SEARCHLIST, the final character is replicated till it is long
enough.  If the REPLACEMENTLIST is empty, the SEARCHLIST is replicated.
This latter is useful for counting characters in a class or for
squashing character sequences in a class.

=end original

C</d> “áó“ãÞ“í­“ª¬“ÞÅ“ªï“ªì“ªë“ªÈ“¡¢REPLACEMENTLIST “ªÏ“¡¢“ßÈ“ªË“ò¦“ïÒ“ªµ“ªì“ª¿“÷×“ªê“ªË
“ú°’¼á“ªµ“ªì“ªÞ“ª¹“¡£
C</d> “ª¬“ò¦“ïÒ“ªµ“ªì“ªÊ“ª¤“íÞ“ùê“ªÇ“¡¢REPLACEMENTLIST “ª¬ SEARCHLIST “ªè“ªê“ªâ“Ó­“ª¤“ªÈ“¡¢
“ÔÒ“ª¸“íþ“ªµ“ªË“ªÊ“ªë“ªÞ“ªÇ“¡¢REPLACEMENTLIST “ªÎ“õÌ“ý­“ªÎ“Ùþ“í®“ª¬
“ðÛ“ªê“Ú÷“ªµ“ªì“ªÆ“ª¤“ªë“ªâ“ªÎ“ªÈ“ª·“ªÆ“Ðâ“ªï“ªì“ªÞ“ª¹“¡£
REPLACEMENTLIST “ª¬“Íö“Ùþ“í®“Öª“ªÇ“ªÎ“ªÈ“ª­“ªË“ªÏ“¡¢SEARCHLIST “ªÈ“ÔÒ“ª¸“ªË“ªÊ“ªê“ªÞ“ª¹“¡£
“ý­“íº“ªÏ“¡¢“ª¢“ªë“Ùþ“í®“«¯“«é“«¹“ªË“ùß“ªÞ“ªì“ªë“Ùþ“í®‘Êý“ªò‘Êý“ª¨“ªë“ªÈ“ª­“ªä“¡¢
“ª¢“ªë“Ùþ“í®“«¯“«é“«¹“ªÎ“Ùþ“í®“ªÎ˜­å“ªÓ“ªò’°µ“õê“ª¹“ªë“ªè“ª¦“ªÊ“ªÈ“ª­“ªË“øµ“××“ªÇ“ª¹“¡£

=begin original

Examples:

=end original

“ÖÇ:

    $ARGV[1] =~ tr/A-Z/a-z/;	# canonicalize to lower case

    $cnt = tr/*/*/;		# count the stars in $_

    $cnt = $sky =~ tr/*/*/;	# count the stars in $sky

    $cnt = tr/0-9//;		# count the digits in $_

    tr/a-zA-Z//s;		# bookkeeper -> bokeper

    ($HOST = $host) =~ tr/a-z/A-Z/;

    tr/a-zA-Z/ /cs;		# change non-alphas to single space

    tr [\200-\377]
       [\000-\177];		# delete 8th bit

=begin original

If multiple transliterations are given for a character, only the
first one is used:

=end original

“ÜÜ‘Êý“ªÎ“Ùþ“í®’ÊÑ“üµ“ª¬“ìé“ªÄ“ªÎ“Ùþ“í®“ªË“ªÄ“ª¤“ªÆ“ò¦“ïÒ“ªµ“ªì“ªë“ªÈ“¡¢“õÌ“ôø“ªÎ“ªâ“ªÎ“ªÀ“ª±“ª¬“ÞÅ“ªï“ªì“ªÞ“ª¹“¡£

    tr/AAA/XYZ/

=begin original

will transliterate any A to X.

=end original

“ªÏ A “ªò X “ªË’ÊÑ“üµ“ª·“ªÞ“ª¹“¡£

=begin original

Because the transliteration table is built at compile time, neither
the SEARCHLIST nor the REPLACEMENTLIST are subjected to double quote
interpolation.  That means that if you want to use variables, you
must use an eval():

=end original

’ÊÑ“üµ“«Æ’¡¼“«Ö“«ë“ªÏ“«³“«ó“«Ñ“«¤“«ë“ãÁ“ªË“íÂ“ªé“ªì“ªë“ªÎ“ªÇ“¡¢SEARCHLIST “ªâ
REPLACEMENTLIST “ªâ“«À“«Ö“«ë“«¯“«©’¡¼“«È“î÷“ËÒ“ªÎ’ÂÐ“ßÚ“ªÈ“ªÏ“ªÊ“ªê“ªÞ“ª»“ªó“¡£
’ÊÑ‘Êý“ªò“ÞÅ“ª¤“ª¿“ª¤“íÞ“ùê“ªË“ªÏ“¡¢eval() “ªò“ÞÅ“ªï“ªÊ“ª±“ªì“ªÐ“ªÊ“ªé“ªÊ“ª¤“ªÈ“ª¤“ª¦“ª³“ªÈ“ªÇ“ª¹:

    eval "tr/$oldlist/$newlist/";
    die $@ if $@;

    eval "tr/$oldlist/$newlist/, 1" or die $@;

=item <<EOF
X<here-doc> X<heredoc> X<here-document> X<<< << >>>

=begin original

A line-oriented form of quoting is based on the shell "here-document"
syntax.  Following a C<< << >> you specify a string to terminate
the quoted material, and all lines following the current line down to
the terminating string are the value of the item.

=end original

“«¯“«©’¡¼“«È“ªÎ“ú¼“ò¦“ú¾“û¡“ãÒ“ªÏ“¡¢“«·“«§“«ë“ªÎ“¡¸“«Ò“«¢“«É“«­“«å“«á“«ó“«È“¡¹“Ï°“Ùþ“ªò“Ðñ“ªË“ª·“ªÆ“ª¤“ªÞ“ª¹“¡£
C<< << >> “ªË“ìÚ“ª­’Â³“ª¤“ªÆ“¡¢“«¯“«©’¡¼“«È“ªµ“ªì“ªë“«Æ“«­“«¹“«È“ªò“ðû“Öõ“ªµ“ª»“ªë“Ùþ“í®“Öª“ªò“ò¦“ïÒ“ªÇ“ª­“¡¢
“úÞ“î¤“ªÎ“ú¼“ªÎ“ó­“ªÎ“ú¼“ª«“ªé“ðû“Ó®“Ùþ“í®“Öª“ªÞ“ªÇ“ªÎ“îï“ªÆ“ªÎ“ú¼“ª¬“ª½“ªÎ“ú£“ÙÍ“ªÎ“ö·“ªÈ“ªÊ“ªê“ªÞ“ª¹“¡£

=begin original

The terminating string may be either an identifier (a word), or some
quoted text.  An unquoted identifier works like double quotes.
There may not be a space between the C<< << >> and the identifier,
unless the identifier is explicitly quoted.  (If you put a space it
will be treated as a null identifier, which is valid, and matches the
first empty line.)  The terminating string must appear by itself
(unquoted and with no surrounding whitespace) on the terminating line.

=end original

“ðû“Ó®“Ùþ“í®“Öª“ªË“ªÏ“¡¢“ãÛ“Ü¬“í­(’Ã±“åÞ) “ª«“«¯“«©’¡¼“«È“ªµ“ªì“ª¿“«Æ“«­“«¹“«È“ª¬“ÞÅ“ª¨“ªÞ“ª¹“¡£
“«¯“«©’¡¼“«È“ªµ“ªì“ªÆ“ª¤“ªÊ“ª¤“ãÛ“Ü¬“í­“ªÏ“¡¢“«À“«Ö“«ë“«¯“«©’¡¼“«È“ªÎ“ªè“ª¦“ªË“Ðâ“ªï“ªì“ªÞ“ª¹“¡£
“ãÛ“Ü¬“í­“ª¬“«¯“«©’¡¼“«È“ªµ“ªì“ªÆ“ª¤“ªÊ“ª¤“íÞ“ùê“ªÏ“¡¢C<< << >> “ªÈ“ãÛ“Ü¬“í­“ªÎ“Êà“ªË
“Íö“ÛÜ“ªò“ìý“ªì“ªÆ“ªÏ“ª¤“ª±“ªÞ“ª»“ªó“¡£
(“ªâ“ª·“Íö“ÛÜ“ªò“ìý“ªì“ªë“ªÈ“¡¢“Íö“ãÛ“Ü¬“í­“ªÈ“ª·“ªÆ“Ðâ“ªï“ªì“ªÞ“ª¹; “ª³“ªì“ªÏ“êó’¸ú“ªÇ“¡¢
“õÌ“ôø“ªÎ“Íö“ú¼“ªË“«Þ“«Ã“«Á“ª¹“ªë“ªè“ª¦“ªË“ªÊ“ªê“ªÞ“ª¹“¡£)
“ðû“Ó®“Ùþ“í®“Öª“ªÏ“ðû“Ó®“ú¼“ªË’Ã±‘Ìå“ªÇ(“«¯“«©’¡¼“«È“ªµ“ªì“ªº“¡¢“îñ“ý­“ªË“ªâ“Íö“ÛÜ“ªÊ“ª·“ªÇ)
“úÞ“ªì“ªÊ“ª±“ªì“ªÐ“ªÊ“ªê“ªÞ“ª»“ªó“¡£

=begin original

If the terminating string is quoted, the type of quotes used determine
the treatment of the text.

=end original

“ðû“Ó®“Ùþ“í®“Öª“ª¬“«¯“«©’¡¼“«È“ªµ“ªì“ªÆ“ª¤“ªë“íÞ“ùê“ªË“ªÏ“¡¢“ª½“ªÎ“«¯“«©’¡¼“«È“ªÎ“ðú“×¾“ªË“ªè“ªÃ“ªÆ“¡¢
“«¯“«©’¡¼“«È“ªµ“ªì“ªë“«Æ“«­“«¹“«È“ªÎ“Ðâ“ª¤“Ì½“ªá“ªé“ªì“ªÞ“ª¹“¡£

=over 4

=item Double Quotes

=begin original

Double quotes indicate that the text will be interpolated using exactly
the same rules as normal double quoted strings.

=end original

Double quotes indicate that the text will be interpolated using exactly
the same rules as normal double quoted strings.
(TBT)

       print <<EOF;
    The price is $Price.
    EOF

       print << "EOF"; # same as above
    The price is $Price.
    EOF

=item Single Quotes

=begin original

Single quotes indicate the text is to be treated literally with no
interpolation of its content. This is similar to single quoted
strings except that backslashes have no special meaning, with C<\\>
being treated as two backslashes and not one as they would in every
other quoting construct.

=end original

Single quotes indicate the text is to be treated literally with no
interpolation of its content. This is similar to single quoted
strings except that backslashes have no special meaning, with C<\\>
being treated as two backslashes and not one as they would in every
other quoting construct.
(TBT)

=begin original

This is the only form of quoting in perl where there is no need
to worry about escaping content, something that code generators
can and do make good use of.

=end original

This is the only form of quoting in perl where there is no need
to worry about escaping content, something that code generators
can and do make good use of.
(TBT)

=item Backticks

=begin original

The content of the here doc is treated just as it would be if the
string were embedded in backticks. Thus the content is interpolated
as though it were double quoted and then executed via the shell, with
the results of the execution returned.

=end original

The content of the here doc is treated just as it would be if the
string were embedded in backticks. Thus the content is interpolated
as though it were double quoted and then executed via the shell, with
the results of the execution returned.
(TBT)

       print << `EOC`; # execute command and get results
    echo hi there
    EOC

=back

=begin original

It is possible to stack multiple here-docs in a row:

=end original

“ÜÜ‘Êý“ªÎ“«Ò“«ä“«É“«­“«å“«á“«ó“«È“ªò“Ö§’Â³“ª·“ªÆ“«¹“«¿“«Ã“«¯“ª¹“ªë“ª³“ªÈ“ªâ“Ê¦“Òö“ªÇ“ª¹:

       print <<"foo", <<"bar"; # you can stack them
    I said foo.
    foo
    I said bar.
    bar

       myfunc(<< "THIS", 23, <<'THAT');
    Here's a line
    or two.
    THIS
    and here's another.
    THAT

=begin original

Just don't forget that you have to put a semicolon on the end
to finish the statement, as Perl doesn't know you're not going to
try to do this:

=end original

“ì¤“ù»“ªÎ“ªè“ª¦“ªÊ“ª³“ªÈ“ªò“ª·“ª¿“ª¤“ªÎ“ªÇ“ªÏ“ªÊ“ª¤“ªÈ“ª¤“ª¦“ª³“ªÈ“ª¬ Perl “ªË“ªÏ“ªï“ª«“ªé“ªÊ“ª¤“ªÎ“ªÇ“¡¢
“Ùþ“ªò“ðû“ªï“ªé“ª»“ªë“ª¿“ªá“ªË“ªÏ“ØÇ“Ú­“ªË“«»“«ß“«³“«í“«ó“ªò“ªÄ“ª±“ªÊ“ª±“ªì“ªÐ“ªÊ“ªé“ªÊ“ª¤“ª³“ªÈ“ªò
“ØÎ“ªì“ªÊ“ª¤“ªÇ“ù»“ªµ“ª¤:

       print <<ABC
    179231
    ABC
       + 20;

=begin original

If you want to remove the line terminator from your here-docs,
use C<chomp()>.

=end original

“«Ò“«ä“«É“«­“«å“«á“«ó“«È“ª«“ªé“ú¼“ðû“Ó®“í­“ªò“ð¶“ËÛ“ª·“ª¿“ª¤“íÞ“ùê“ªÏ“¡¢C<chomp()> “ªò“ÞÅ“ªÃ“ªÆ“ª¯“ªÀ“ªµ“ª¤“¡£

    chomp($string = <<'END');
    This is a string.
    END

=begin original

If you want your here-docs to be indented with the rest of the code,
you'll need to remove leading whitespace from each line manually:

=end original

“«Ò“«¢“«É“«­“«å“«á“«ó“«È“ªò“«½’¡¼“«¹“ªÎ“ªÛ“ª«“ªÎ“Ý»“ÝÂ“ª«“ªé“«¤“«ó“«Ç“«ó“«È“ª·“ª¿“ª¤“íÞ“ùê“¡¢
“ÊÀ“ú¼“ªÎ“à»“Ôé“ªÎ“Íö“ÛÜ“ªÏ“â¢“ÔÑ“ªÇ“ö¢“ªê“ð¶“ª¯“ù±“é©“ª¬“ª¢“ªê“ªÞ“ª¹:

    ($quote = <<'FINIS') =~ s/^\s+//gm;
       The Road goes ever on and on,
       down from the door where it began.
    FINIS

=begin original

If you use a here-doc within a delimited construct, such as in C<s///eg>,
the quoted material must come on the lines following the final delimiter.
So instead of

=end original

C<s///eg> “ªÎ“ªè“ª¦“ªÊ“«Ç“«ê“«ß“«¿“Ï°“ðã“ªÎ“ñé“ªÇ“«Ò“«¢“«É“«­“«å“«á“«ó“«È“ªò“ÞÅ“ª¦“íÞ“ùê“¡¢
“«¯“«©’¡¼“«È“ªµ“ªì“ª¿“ªâ“ªÎ“ªÏ“õÌ“ý­“ªÎ“«Ç“«ê“«ß“«¿“ªË“ìÚ“ª­’Â³“ª¯“ªâ“ªÎ“ªÈ“ª·“ªÆ‘À´“ªÊ“ª±“ªì“ªÐ“ªÊ“ªê“ªÞ“ª»“ªó“¡£
’½¾“ªÃ“ªÆ“¡¢“ì¤“ù»“ªÎ“ªè“ª¦“ªÇ“ªÏ“ªÊ“ª¯:

    s/this/<<E . 'that'
    the other
    E
     . 'more '/eg;

=begin original

you have to write

=end original

“ì¤“ù»“ªÎ“ªè“ª¦“ªË“ßö“ª«“ªÊ“ª±“ªì“ªÐ“ªÊ“ªê“ªÞ“ª»“ªó:

    s/this/<<E . 'that'
     . 'more '/eg;
    the other
    E

=begin original

If the terminating identifier is on the last line of the program, you
must be sure there is a newline after it; otherwise, Perl will give the
warning B<Can't find string terminator "END" anywhere before EOF...>.

=end original

“«×“«í“«°“«é“«à“ªÎ“õÌ“ý­“ªÎ“ú¼“ªË“ðû“Ó®“ãÛ“Ü¬“í­“ª¬“ª¢“ªë“íÞ“ùê“¡¢“ª½“ªÎ“ý­“ªË“ªÏ
“ËÇ“ú¼“ª¬“ªÊ“ª±“ªì“ªÐ“ªÊ“ªê“ªÞ“ª»“ªó; “ªµ“ªâ“ªÊ“ª±“ªì“ªÐ“¡¢Perl “ªÏ
B<Can't find string terminator "END" anywhere before EOF...> “ªÈ“ª¤“ª¦
“Ìí“Í±“ªò“õó“ª·“ªÞ“ª¹“¡£

=begin original

Additionally, the quoting rules for the end of string identifier are not
related to Perl's quoting rules -- C<q()>, C<qq()>, and the like are not
supported in place of C<''> and C<"">, and the only interpolation is for
backslashing the quoting character:

=end original

“ªµ“ªé“ªË“¡¢“Ùþ“í®“Öª“ðû“Ó®“ãÛ“Ü¬“í­“ªË’ÂÐ“ª¹“ªë“«¯“«©’¡¼“«È“«ë’¡¼“«ë“ªÏ Perl “ªÎ“«¯“«©’¡¼“«È“«ë’¡¼“«ë“ªÈ“ªÏ
’´Ø“Ìõ“ª¬“ª¢“ªê“ªÞ“ª»“ªó -- C<q()>, C<qq()> “ªª“ªè“ªÓ“ÔÒ“ðú“ªÎ“ªâ“ªÎ“ªÏ C<''> “ªä C<""> “ªÎ
“ÓÛ“ªï“ªê“ªÎ“ªÊ“ªë“ªâ“ªÎ“ªË“ªÏ’ÂÐ’±þ“ª·“ªÆ“ªª“ªé“ªº“¡¢“Ùþ“í®“ªò“«¯“«©’¡¼“«È“ª¹“ªë“ª¿“ªá“ªÎ
“«Ð“«Ã“«¯“«¹“«é“«Ã“«·“«å“ªÀ“ª±“ª¬“î÷“ËÒ“ªµ“ªì“ªÞ“ª¹:

    print << "abc\"def";
    testing...
    abc"def

=begin original

Finally, quoted strings cannot span multiple lines.  The general rule is
that the identifier must be a string literal.  Stick with that, and you
should be safe.

=end original

“õÌ“ý­“ªË“¡¢“«¯“«©’¡¼“«È“ªµ“ªì“ª¿“Ùþ“í®“Öª“ªÏ“ÜÜ‘Êý“ú¼“ªË“ª«“ª«“ªë“ª³“ªÈ“ªÏ“ª¢“ªê“ªÞ“ª»“ªó“¡£
“ãÛ“Ü¬“í­“ªË’´Ø“ª¹“ªë“ìé“Úõ“îÜ“ªÊ“«ë’¡¼“«ë“ªÏ“¡¢“Ùþ“í®“Öª“«ê“«Æ“«é“«ë“ªÇ“ªÊ“ª±“ªì“ªÐ“ªÊ“ªé“ª¤“ª³“ªÈ“ªÇ“ª¹“¡£
“ª³“ªì“ªË’½¾“ªÃ“ªÆ“ª¤“ªì“ªÐ“¡¢“äÌ“îï“ªÎ“ªÏ“ªº“ªÇ“ª¹“¡£

=back

=head2 Gory details of parsing quoted constructs
X<quote, gory details>

(“«¯“«©’¡¼“«È“ªµ“ªì“ª¿“Ï°“ðã“ªÎ“«Ñ’¡¼“«¹“ªË’´Ø“ª¹“ªë“ßÙ“á¬)

=begin original

When presented with something that might have several different
interpretations, Perl uses the B<DWIM> (that's "Do What I Mean")
principle to pick the most probable interpretation.  This strategy
is so successful that Perl programmers often do not suspect the
ambivalence of what they write.  But from time to time, Perl's
notions differ substantially from what the author honestly meant.

=end original

“ù¼“ª«“ÜÜ‘Êý“ªÎ“ú°’¼á“ª¬“Ê¦“Òö“ªÊ“øú“úÞ“ª¬“ª¢“ªÃ“ª¿“íÞ“ùê“¡¢Perl “ªÏ“õÌ“ªâ“ü¬“ª«“ªé“ª·“ª¤“ú°’¼á“ªò
“àÔ’Âò“ª¹“ªë“ª¿“ªá“ªË B<DWIM> ("Do What I Mean")“ê«“öÎ“ªò“ÞÅ“ª¤“ªÞ“ª¹“¡£
“ª³“ªÎ’Àï“ÕÔ“ªÏ“Þª“ßÈ“ªË“à÷“Íí“ª·“ª¿“ªÎ“ªÇ“¡¢Perl “«×“«í“«°“«é“«Þ“ªÏ“ª·“ªÐ“ª·“ªÐ
“í»“ÝÂ“ª¬“ßö“ª¤“ª¿“ªâ“ªÎ“ªÎ“ÙÃ“âê“ªò“ë÷“ª¤“ªÞ“ª»“ªó“¡£
“ª·“ª«“ª·“ãÁ“Êà“ª¬“ª¿“ªÄ“ªË“ªÄ“ªì“ªÆ“¡¢Perl “ªÎ‘¸Å“Ò·“ªÏ“íÂ“íº“ª¬“Üâ‘µ±“ªË“ëò“Ú«“ª·“ªÆ“ª¤“ª¿“ªâ“ªÎ“ª«“ªé
“ª«“ªÊ“ªê’ÊÑ“ªï“ªê“ªÞ“ª·“ª¿“¡£

=begin original

This section hopes to clarify how Perl handles quoted constructs.
Although the most common reason to learn this is to unravel labyrinthine
regular expressions, because the initial steps of parsing are the
same for all quoting operators, they are all discussed together.

=end original

“ª³“ªÎ“íñ“ªÇ“ªÏ Perl “ª¬“ªÉ“ªÎ“ªè“ª¦“ªË“«¯“«©’¡¼“«È“ªµ“ªì“ª¿“Ï°“ðã“ªò“Ðâ“ª¦“ª«“ªò
“Ù¥“ü¬“ªË“ª·“ªè“ª¦“ªÈ“ÞÖ“ª¤“ªÞ“ª¹“¡£
“ª³“ªì“ªò‘Ñ§“ªÜ“ª¦“ªÈ“ª¹“ªë“õÌ“ªâ“ªè“ª¯“ª¢“ªë“×â“ë¦“ªÏ“ïá“Ð®“øú“úÞ“ªÎ“Ú»“Ïà“ªò“ªÛ“ª°“ª¹“ª¿“ªá“ªÇ“ª¹“ª¬“¡¢
“«Ñ’¡¼“«¹“ªÎ“ôø“Ñ¢“«¹“«Æ“«Ã“«×“ªÏ“îï“ªÆ“ªÎ“«¯“«©’¡¼“«È“æÑ“ß©“í­“ªÇ“ÔÒ“ª¸“ªÊ“ªÎ“ªÇ“¡¢“îï“ªÆ“ÔÒ“ãÁ“ªË“Ðâ“ª¤“ªÞ“ª¹“¡£

=begin original

The most important Perl parsing rule is the first one discussed
below: when processing a quoted construct, Perl first finds the end
of that construct, then interprets its contents.  If you understand
this rule, you may skip the rest of this section on the first
reading.  The other rules are likely to contradict the user's
expectations much less frequently than this first one.

=end original

Perl “ªÎ“«Ñ’¡¼“«¹“ªË’´Ø“ª¹“ªë“«ë’¡¼“«ë“ªÇ“õÌ“ªâ“ñì“é©“ªÊ“ªâ“ªÎ“ªÏ“ì¤“ù»“ªÇ“âû“ªÙ“ªÆ“ª¤“ªë“ª¦“ªÁ
“õÌ“ôø“ªÎ“ªâ“ªÎ“ªÇ“ª¹“¡£
“ªÄ“ªÞ“ªê“¡¢“«¯“«©’¡¼“«È“ªµ“ªì“ª¿“Ï°“ðã“ªò’½è“×â“ª¹“ªë“ªÈ“ª­“ªÏ“¡¢Perl “ªÏ“ªÞ“ªº“ª½“ªÎ“Ï°“ðã“ªÎ
“õÌ“ý­“ªò“÷®“ª·“ªÆ“¡¢“ª½“ªì“ª«“ªé“ñé“ãó“ªò“ú°’¼á“ª·“ªÞ“ª¹“¡£
“ª³“ªÎ“«ë’¡¼“«ë“ª¬“ªï“ª«“ªì“ªÐ“¡¢“ªÈ“ªê“ª¢“ª¨“ªº“ªÏ“ª³“ªÎ“íñ“ªÎ‘²Ð“ªê“ªÏ’ÆÉ“ªß“Þ«“ªÐ“ª·“ªÆ“ªâ“ª«“ªÞ“ª¤“ªÞ“ª»“ªó“¡£
“ª½“ªÎ“öâ“ªÎ“«ë’¡¼“«ë“ªÏ“õÌ“ôø“ªÎ“«ë’¡¼“«ë“ªË“Ýï“ªÙ“ªÆ“«æ’¡¼“«¶’¡¼“ªÎ“åø“ßÌ“ªË“Úã“ª¹“ªë“Þº“Óø“ªÏ
“ªÏ“ªë“ª«“ªË“á´“ªÊ“ª¤“ªÇ“ª¹“¡£

=begin original

Some passes discussed below are performed concurrently, but because
their results are the same, we consider them individually.  For different
quoting constructs, Perl performs different numbers of passes, from
one to four, but these passes are always performed in the same order.

=end original

“ì¤“ù»“ªÇ“ì¡“Öå“ª¹“ªë“«Ñ“«¹“ªË“ªÏ“ÔÒ“ãÁ“ªË’¼Â“ú¼“ªµ“ªì“ªë“ªâ“ªÎ“ªâ“ª¢“ªê“ªÞ“ª¹“ª¬“¡¢
“Ì¿“Íý“ªÏ“ÔÒ“ª¸“ª³“ªÈ“ªÊ“ªÎ“ªÇ“¡¢“Ü¬‘¡©“ªË“ÍÅ“ª¨“ªë“ª³“ªÈ“ªË“ª·“ªÞ“ª¹“¡£
“«¯“«©’¡¼“«È“Ï°“ðã“ªÎ“ðú“×¾“ªË“ªè“ªÃ“ªÆ“¡¢Perl “ª¬’¼Â“ú¼“ª¹“ªë“«Ñ“«¹“ªÎ‘Êý“ªÏ
1 “ª«“ªé 4 “ªÞ“ªÇ“ì¶“ªÊ“ªê“ªÞ“ª¹“ª¬“¡¢“ª³“ªì“ªé“ªÎ“«Ñ“«¹“ªÏ“ßÈ“ªË“ÔÒ“ª¸“â÷“Ûã“ªÇ’¼Â“ú¼“ªµ“ªì“ªÞ“ª¹“¡£

=over 4

=item Finding the end

(“õÌ“ý­“ªò“÷®“ª¹)

=begin original

The first pass is finding the end of the quoted construct, where
the information about the delimiters is used in parsing.
During this search, text between the starting and ending delimiters
is copied to a safe location. The text copied gets delimiter-independent.

=end original

The first pass is finding the end of the quoted construct, where
the information about the delimiters is used in parsing.
During this search, text between the starting and ending delimiters
is copied to a safe location. The text copied gets delimiter-independent.
(TBT)

=begin original

If the construct is a here-doc, the ending delimiter is a line
that has a terminating string as the content. Therefore C<<<EOF> is
terminated by C<EOF> immediately followed by C<"\n"> and starting
from the first column of the terminating line.
When searching for the terminating line of a here-doc, nothing
is skipped. In other words, lines after the here-doc syntax
are compared with the terminating string line by line.

=end original

If the construct is a here-doc, the ending delimiter is a line
that has a terminating string as the content. Therefore C<<<EOF> is
terminated by C<EOF> immediately followed by C<"\n"> and starting
from the first column of the terminating line.
When searching for the terminating line of a here-doc, nothing
is skipped. In other words, lines after the here-doc syntax
are compared with the terminating string line by line.
(TBT)

=begin original

For the constructs except here-docs, single characters are used as starting
and ending delimiters. If the starting delimiter is an opening punctuation
(that is C<(>, C<[>, C<{>, or C<< < >>), the ending delimiter is the
corresponding closing punctuation (that is C<)>, C<]>, C<}>, or C<< > >>).
If the starting delimiter is an unpaired character like C</> or a closing
punctuation, the ending delimiter is same as the starting delimiter.
Therefore a C</> terminates a C<qq//> construct, while a C<]> terminates
C<qq[]> and C<qq]]> constructs.

=end original

For the constructs except here-docs, single characters are used as starting
and ending delimiters. If the starting delimiter is an opening punctuation
(that is C<(>, C<[>, C<{>, or C<< < >>), the ending delimiter is the
corresponding closing punctuation (that is C<)>, C<]>, C<}>, or C<< > >>).
If the starting delimiter is an unpaired character like C</> or a closing
punctuation, the ending delimiter is same as the starting delimiter.
Therefore a C</> terminates a C<qq//> construct, while a C<]> terminates
C<qq[]> and C<qq]]> constructs.
(TBT)

=begin original

When searching for single-character delimiters, escaped delimiters
and C<\\> are skipped. For example, while searching for terminating C</>,
combinations of C<\\> and C<\/> are skipped.  If the delimiters are
bracketing, nested pairs are also skipped.  For example, while searching
for closing C<]> paired with the opening C<[>, combinations of C<\\>, C<\]>,
and C<\[> are all skipped, and nested C<[> and C<]> are skipped as well.
However, when backslashes are used as the delimiters (like C<qq\\> and
C<tr\\\>), nothing is skipped.
During the search for the end, backslashes that escape delimiters
are removed (exactly speaking, they are not copied to the safe location).

=end original

1 “Ùþ“í®“ªÎ“«Ç“«ê“«ß“«¿“ªò“÷®“ª¹“íÞ“ùê“¡¢“«¨“«¹“«±’¡¼“«×“ªµ“ªì“ª¿“«Ç“«ê“«ß“«¿“ªÈ C<\\> “ªÏ
’ÆÉ“ªß“Þ«“ªÐ“ª·“ªÞ“ª¹“¡£
“ÖÇ“ª¨“ªÐ“¡¢C</> “ªò“÷®“ª·“ªÆ“ª¤“ªë“ªÈ“ª­“ªË“ªÏ“¡¢C<\\> “ªÈ C<\/> “ªÎ“ðÚ“ªß“ùê“ªï“ª»“ªò
’ÆÉ“ªß“Þ«“ªÐ“ª·“ªÞ“ª¹“¡£
“«Ç“«ê“«ß“«¿“ª¬“ª«“ªÃ“ª³“ªÇ“ª¯“ª¯“ªé“ªì“ªÆ“ª¤“ªë“íÞ“ùê“ªÏ“¡¢“«Í“«¹“«È“ª·“ª¿“ðÚ“ªâ’ÆÉ“ªß“Þ«“ªÐ“ªµ“ªì“ªÞ“ª¹“¡£
“ÖÇ“ª¨“ªÐ“¡¢“ËÒ“ª­“ªÎ C<[> “ªÈ“ðÚ“ªË“ªÊ“ªë“øÍ“ª¸“ªÎ C<]> “ªò“÷®“ª·“ªÆ“ª¤“ªë“ªÈ“ª­“ªË“ªÏ“¡¢
C<\\>, C<\]>, C<\[> “ªÎ“ðÚ“ªß“ùê“ªï“ª»“ªò“ªÏ“îï“ªÆ’ÆÉ“ªß“Þ«“ªÐ“ª·“¡¢
“ªµ“ªé“ªË“«Í“«¹“«È“ª·“ª¿ C<[>, C<]> “ªâ’ÆÉ“ªß“Þ«“ªÐ“ª·“ªÞ“ª¹“¡£
“ª·“ª«“ª·“¡¢(C<qq\\> “ªä C<tr\\\> “ªÎ“ªè“ª¦“ªË)“«Ð“«Ã“«¯“«¹“«é“«Ã“«·“«å“ª¬“«Ç“«ê“«ß“«¿“ªÈ“ª·“ªÆ
“ÞÅ“ªï“ªì“ª¿“íÞ“ùê“¡¢“ù¼“ªâ’ÆÉ“ªß“Þ«“ªÐ“ª·“ªÞ“ª»“ªó“¡£
“ØÇ“Ú­“ªÎ’¸¡“ßã“ñé“¡¢“«Ç“«ê“«ß“«¿“ªò“«¨“«¹“«±’¡¼“«×“ª¹“ªë“«Ð“«Ã“«¯“«¹“«é“«Ã“«·“«å“ªÏ“ð¶“ËÛ“ªµ“ªì“ªÞ“ª¹
(“âû“ªÙ“ª¿“ªÈ“ªª“ªê“ªË“ïá“ü¬“ªË“¡¢“äÌ“îï“ªÊ“íÞ“á¶“ªË“«³“«Ô’¡¼“ªÏ“ªµ“ªì“ªÞ“ª»“ªó)“¡£

=begin original

For constructs with three-part delimiters (C<s///>, C<y///>, and
C<tr///>), the search is repeated once more.
If the first delimiter is not an opening punctuation, three delimiters must
be same such as C<s!!!> and C<tr)))>, in which case the second delimiter
terminates the left part and starts the right part at once.
If the left part is delimited by bracketing punctuations (that is C<()>,
C<[]>, C<{}>, or C<< <> >>), the right part needs another pair of
delimiters such as C<s(){}> and C<tr[]//>.  In these cases, whitespaces
and comments are allowed between both parts, though the comment must follow
at least one whitespace; otherwise a character expected as the start of
the comment may be regarded as the starting delimiter of the right part.

=end original

3 “ªÄ“ªÎ“«Ç“«ê“«ß“«¿“ª«“ªé“ªÊ“ªë“Ï°“ðã (C<s///>, C<y///>, C<tr///>) “ªÎ“íÞ“ùê“¡¢
’¸¡“ßã“ªÏ“ªâ“ª¦“ìé“Óø“ðÛ“ªê“Ú÷“ªµ“ªì“ªÞ“ª¹“¡£
“õÌ“ôø“ªÎ“«Ç“«ê“«ß“«¿“ª¬“ËÒ“ª­“ª«“ªÃ“ª³“ªÇ“ªÊ“ª¤“íÞ“ùê“¡¢C<s!!!> and C<tr)))> “ªÎ“ªè“ª¦“ªË
3 “ªÄ“ªÎ“«Ç“«ê“«ß“«¿“ªÏ“ÔÒ“ª¸“ªÇ“ªÊ“ª±“ªì“ªÐ“ªÊ“ªê“ªÞ“ª»“ªó;
“ª³“ªÎ“íÞ“ùê“¡¢2 “Ûã“ÙÍ“ªÎ“«Ç“«ê“«ß“«¿“ª¬“ñ§“ö°“ªÎ“ðû“Ó®“ªÈ“éÓ“ö°“ªÎ“ËÒ“ã·“ªò“ÔÒ“ãÁ“ªË“ú¼“ª¤“ªÞ“ª¹“¡£
If the left part is delimited by bracketing punctuations (that is C<()>,
C<[]>, C<{}>, or C<< <> >>), the right part needs another pair of
delimiters such as C<s(){}> and C<tr[]//>.  In these cases, whitespaces
and comments are allowed between both parts, though the comment must follow
at least one whitespace; otherwise a character expected as the start of
the comment may be regarded as the starting delimiter of the right part.
(TBT)

=begin original

During this search no attention is paid to the semantics of the construct.
Thus:

=end original

’¸¡“ßã“ª¹“ªë“Êà“¡¢“Ï°“ðã“ªÎ“Ùþ“Øæ“ªÏ“ÍÅ“Õç“ª·“ªÞ“ª»“ªó“¡£
’½¾“ªÃ“ªÆ:

    "$hash{"$foo/$bar"}"

=begin original

or:

=end original

“ªä:

    m/
      bar	# NOT a comment, this slash / terminated m//!
     /x

=begin original

do not form legal quoted expressions.   The quoted part ends on the
first C<"> and C</>, and the rest happens to be a syntax error.
Because the slash that terminated C<m//> was followed by a C<SPACE>,
the example above is not C<m//x>, but rather C<m//> with no C</x>
modifier.  So the embedded C<#> is interpreted as a literal C<#>.

=end original

“ªÏ“ïá“ª·“ª¤“«¯“«©’¡¼“«È“øú“úÞ“ªÇ“ªÏ“ª¢“ªê“ªÞ“ª»“ªó“¡£
“«¯“«©’¡¼“«È“ªÏ“õÌ“ôø“ªÎ C<"> “ªä C</> “ªÇ“ðû“ªï“ªê“ªÈ“ªÊ“ªê“¡¢
‘²Ð“ªê“ªÎ“Ý»“ÝÂ“ªÏ“Ùþ“Ûö“«¨“«é’¡¼“ªÈ“ªÊ“ªê“ªÞ“ª¹“¡£
C<m//> “ªò“ðû“ªï“ªé“ª»“ªÆ“ª¤“ªë“«¹“«é“«Ã“«·“«å“ªÎ“ó­“ªË‘À´“ªÆ“ª¤“ªë“ªÎ“ª¬ C<“Íö“ÛÜ> “ªÊ“ªÎ“ªÇ“¡¢
“ß¾“ªÎ“ÖÇ“ªÇ“ªÏ C<m//x> “ªÇ“ªÏ“ªÊ“ª¯“¡¢C</x> “ªÊ“ª·“ªÎ C<m//> “ªÈ“ªÊ“ªê“ªÞ“ª¹“¡£
’½¾“ªÃ“ªÆ“¡¢“ñé“ªË“ª¢“ªë C<#> “ªÏ“«ê“«Æ“«é“«ë“ªÊ C<#> “ªÈ“ª·“ªÆ“Ðâ“ªï“ªì“ªÞ“ª¹“¡£

=begin original

Also no attention is paid to C<\c\> (multichar control char syntax) during
this search. Thus the second C<\> in C<qq/\c\/> is interpreted as a part
of C<\/>, and the following C</> is not recognized as a delimiter.
Instead, use C<\034> or C<\x1c> at the end of quoted constructs.

=end original

“ª³“ªÎ’¸¡“ßã“ªÎ“Êà“¡¢C<\c\> (“«Þ“«ë“«Á“«Ð“«¤“«È“Ùþ“í®“ð¤“åÙ“Ùþ“Ûö)“ªË“ñ¼“ëò“ªÏ’Ê§“ªï“ªì“ªÞ“ª»“ªó“¡£
’½¾“ªÃ“ªÆ“¡¢C<qq/\c\/> “ªÎ 2 “Ûã“ÙÍ“ªÎ C<\> “ªÏ C<\/> “ªÎ“ìé“Ý»“ªÈ“ª·“ªÆ“Ðâ“ªï“ªì“¡¢
“ìÚ“ª­’Â³“ª¯ C</> “ªÏ“«Ç“«ê“«ß“«¿“ªÈ“ª·“ªÆ“ìã“ãÛ“ªµ“ªì“ªÞ“ª»“ªó“¡£
“ÓÛ“ªï“ªê“ªË“¡¢“«¯“«©’¡¼“«È“Ï°“ðã“ªÎ“ØÇ“Ú­“ªË C<\034> “ª« C<\x1c> “ªò“ÞÅ“ªÃ“ªÆ“ª¯“ªÀ“ªµ“ª¤“¡£

=item Interpolation
X<interpolation>

(“î÷“ËÒ)

=begin original

The next step is interpolation in the text obtained, which is now
delimiter-independent.  There are multiple cases.

=end original

“ó­“ªÎ“«¹“«Æ“«Ã“«×“ªÏ“¡¢“Ôð“ªé“ªì“ª¿(“«Ç“«ê“«ß“«¿“ªË“ëî“ðí“ª·“ªÊ“ª¤)“«Æ“«­“«¹“«È“ªË’ÂÐ“ª¹“ªë“î÷“ËÒ“ªÇ“ª¹“¡£
“ÜÜ‘Êý“ªÎ“«±’¡¼“«¹“ª¬“ª¢“ªê“ªÞ“ª¹“¡£

=over 4

=item C<<<'EOF'>

=begin original

No interpolation is performed.
Note that the combination C<\\> is left intact, since escaped delimiters
are not available for here-docs.

=end original

“î÷“ËÒ“ªÏ“ú¼“ªï“ªì“ªÞ“ª»“ªó“¡£
C<\\> “ªÎ“ðÚ“ªß“ùê“ªï“ª»“ªÏ“ª½“ªÎ“ªÞ“ªÞ“ªÇ“ª¢“ªë“ª³“ªÈ“ªË“ñ¼“ëò“ª·“ªÆ“ª¯“ªÀ“ªµ“ª¤;
“«Ò“«ä“«É“«­“«å“«á“«ó“«È“ªÇ“ªÏ“«Ç“«ê“«ß“«¿“ªÎ“«¨“«¹“«±’¡¼“«×“ªÏ“ªÇ“ª­“ªÊ“ª¤“ª«“ªé“ªÇ“ª¹“¡£

=item  C<m''>, the pattern of C<s'''>

=begin original

No interpolation is performed at this stage.
Any backslashed sequences including C<\\> are treated at the stage
to L</"parsing regular expressions">.

=end original

No interpolation is performed at this stage.
Any backslashed sequences including C<\\> are treated at the stage
to L</"parsing regular expressions">.
(TBT)

=item C<''>, C<q//>, C<tr'''>, C<y'''>, the replacement of C<s'''>

=begin original

The only interpolation is removal of C<\> from pairs of C<\\>.
Therefore C<-> in C<tr'''> and C<y'''> is treated literally
as a hyphen and no character range is available.
C<\1> in the replacement of C<s'''> does not work as C<$1>.

=end original

C<\\> “ªÎ“ðÚ“ªË“ªª“ª±“ªë C<\> “ªÎ“Þû“ð¶“ªÎ“ªß“ª¬“ú¼“ªï“ªì“ªÞ“ª¹“¡£
’½¾“ªÃ“ªÆ“¡¢C<tr'''> “ªä C<y'''> “ªÎ“ñé“ªË“ª¢“ªë C<-> “ªÏ“Ùþ“í®“÷×“ªê“«Ï“«¤“«Õ“«ó“ªÈ“ª·“ªÆ“Ðâ“ªï“ªì“¡¢
“Ùþ“í®“Ûô’°Ï“ªÏ“ÞÅ“ª¨“ªÞ“ª»“ªó“¡£
C<s'''> “ªÎ“öÇ“üµ“Ùþ“í®“Öª“ªÇ“ªÎ C<\1> “ªÏ C<$1> “ªÈ“ª·“ªÆ“ªÏ“ÔÑ“íÂ“ª·“ªÞ“ª»“ªó“¡£

=item C<tr///>, C<y///>

=begin original

No variable interpolation occurs.  String modifying combinations for
case and quoting such as C<\Q>, C<\U>, and C<\E> are not recognized.
The other escape sequences such as C<\200> and C<\t> and backslashed
characters such as C<\\> and C<\-> are converted to appropriate literals.
The character C<-> is treated specially and therefore C<\-> is treated
as a literal C<->.

=end original

No variable interpolation occurs.  String modifying combinations for
case and quoting such as C<\Q>, C<\U>, and C<\E> are not recognized.
The other escape sequences such as C<\200> and C<\t> and backslashed
characters such as C<\\> and C<\-> are converted to appropriate literals.
The character C<-> is treated specially and therefore C<\-> is treated
as a literal C<->.
(TBT)

=item C<"">, C<``>, C<qq//>, C<qx//>, C<< <file*glob> >>, C<<<"EOF">

=begin original

C<\Q>, C<\U>, C<\u>, C<\L>, C<\l> (possibly paired with C<\E>) are
converted to corresponding Perl constructs.  Thus, C<"$foo\Qbaz$bar">
is converted to C<$foo . (quotemeta("baz" . $bar))> internally.
The other escape sequences such as C<\200> and C<\t> and backslashed
characters such as C<\\> and C<\-> are replaced with appropriate
expansions.

=end original

C<\Q>, C<\U>, C<\u>, C<\L>, C<\l> (“ªª“ª½“ªé“ª¯“ªÏ C<\E> “ªÈ“ªÎ“ðÚ)“ªÏ
’ÂÐ’±þ“ª¹“ªë Perl “Ï°“ðã“ªË’ÊÑ“üµ“ªµ“ªì“ªÞ“ª¹“¡£
’½¾“ªÃ“ªÆ“¡¢C<"$foo\Qbaz$bar"> “ªÏ‘ÄÚ“Ý»“îÜ“ªË
C<$foo . (quotemeta("baz" . $bar))> “ªË’ÊÑ“üµ“ªµ“ªì“ªÞ“ª¹“¡£
C<\200> “ªä C<\t> “ªÎ“ªè“ª¦“ªÊ“¡¢“ª½“ªÎ“öâ“ªÎ“«¨“«¹“«±’¡¼“«×“«·’¡¼“«±“«ó“«¹“ªä“¡¢C<\\> “ªä
C<\-> “ªÎ“ªè“ª¦“ªÊ“¡¢“«Ð“«Ã“«¯“«¹“«é“«Ã“«·“«å“ª¬“ªÄ“ª±“ªé“ªì“ª¿“Ùþ“í®“ªÏ“îê“ï·“ªÊ’³È“íå“ªË
“öÇ“üµ“ªµ“ªì“ªÞ“ª¹“¡£

=begin original

Let it be stressed that I<whatever falls between C<\Q> and C<\E>>
is interpolated in the usual way.  Something like C<"\Q\\E"> has
no C<\E> inside.  instead, it has C<\Q>, C<\\>, and C<E>, so the
result is the same as for C<"\\\\E">.  As a general rule, backslashes
between C<\Q> and C<\E> may lead to counterintuitive results.  So,
C<"\Q\t\E"> is converted to C<quotemeta("\t")>, which is the same
as C<"\\\t"> (since TAB is not alphanumeric).  Note also that:

=end original

I<C<\Q> “ªÈ C<\E> “ªÎ“Êà“ªË“ª¢“ªë“îï“ªÆ“ªÎ“ªâ“ªÎ> “ª¬“÷×“ßÈ“ªÎ“Û°“Ûö“ªÇ“î÷“ËÒ“ªµ“ªì“ªÞ“ª¹“¡£
C<"\Q\\E"> “ªÎ“ªè“ª¦“ªÊ“ªâ“ªÎ“ªÏ‘ÄÚ“Ý»“ªË“ª¢“ªë“ªÎ“ªÏ C<\E> “ªÇ“ªÏ“ªÊ“ª¯“¡¢
C<\Q>, C<\\>, C<E> “ªÇ“ª¢“ªë“ªÎ“ªÇ“¡¢“Ì¿“Íý“ªÏ C<"\\\\E"> “ªÈ“ÔÒ“ª¸“ªË“ªÊ“ªê“ªÞ“ª¹“¡£
“ìé“Úõ“îÜ“ªÊ“«ë’¡¼“«ë“ªÈ“ª·“ªÆ“¡¢C<\Q> “ªÈ C<\E> “ªÎ“Êà“ªË“ª¢“ªë“«Ð“«Ã“«¯“«¹“«é“«Ã“«·“«å“ªÏ
“òÁ“Êï“ªË“Úã“ª·“ª¿“Ì¿“Íý“ªË“ªÊ“ªê“ªÞ“ª¹“¡£
“ª½“ªì“ªÇ“¡¢C<"\Q\t\E"> “ªÏ C<quotemeta("\t")> “ªË’ÊÑ“üµ“ªµ“ªì“¡¢“ª³“ªì“ªÏ(TAB “ªÏ
“çÈ‘Êý“í®“ªÇ“ªÏ“ªÊ“ª¤“ªÎ“ªÇ C<"\\\t"> “ªÈ“ÔÒ“ª¸“ªÇ“ª¹“¡£
“ì¤“ù»“ªÎ“ªè“ª¦“ªÊ“ª³“ªÈ“ªË“ªâ“ñ¼“ëò“ª·“ªÆ“ª¯“ªÀ“ªµ“ª¤:

  $str = '\t';
  return "\Q$str";

=begin original

may be closer to the conjectural I<intention> of the writer of C<"\Q\t\E">.

=end original

“ª³“ªì“ªÏ C<"\Q\t\E"> “ªò“ßö“ª¤“ª¿“ìÑ“ªÎ“åã“ö´“ß¾“ªÎ I<“ëò’¿Þ> “ªË“ªè“ªê“ÐÎ“ª¤“ªÇ“ª¹“¡£

=begin original

Interpolated scalars and arrays are converted internally to the C<join> and
C<.> catenation operations.  Thus, C<"$foo XXX '@arr'"> becomes:

=end original

“î÷“ËÒ“ªµ“ªì“ª¿“«¹“««“«é“ªÈ“ÛÕ“Öª“ªÏ‘ÄÚ“Ý»“ªÇ C<join> “ªÈ C<.> “ªÎ“Ì¿“ùê“ðÃ“íÂ“ªË’ÊÑ“üµ“ªµ“ªì“ªÞ“ª¹“¡£
’½¾“ªÃ“ªÆ“¡¢C<"$foo XXX '@arr'"> “ªÏ“ì¤“ù»“ªÎ“ªè“ª¦“ªË“ªÊ“ªê“ªÞ“ª¹:

  $foo . " XXX '" . (join $", @arr) . "'";

=begin original

All operations above are performed simultaneously, left to right.

=end original

“ß¾“ÑÀ“ªÎ“îï“ªÆ“ªÎ“ðÃ“íÂ“ªÏ“¡¢“ñ§“ª«“ªé“éÓ“ªË“ÔÒ“ãÁ“ªË“ú¼“ªï“ªì“ªÞ“ª¹“¡£

=begin original

Because the result of C<"\Q STRING \E"> has all metacharacters
quoted, there is no way to insert a literal C<$> or C<@> inside a
C<\Q\E> pair.  If protected by C<\>, C<$> will be quoted to became
C<"\\\$">; if not, it is interpreted as the start of an interpolated
scalar.

=end original

C<"\Q STRING \E"> “ªÎ“Ì¿“Íý“ªÏ“îï“ªÆ“ªÎ“«á“«¿“Ùþ“í®“ª¬“«¯“«©’¡¼“«È“ªµ“ªì“ªÆ“ª¤“ªë“ªÎ“ªÇ“¡¢
C<\Q\E> “ªÎ“ðÚ“ªÎ‘ÄÚ“ö°“ªË“«ê“«Æ“«é“«ë“ªÎ C<$> “ªä C<@> “ªò’ÁÞ“ìý“ª¹“ªë“Û°“Ûö“ªÏ“ª¢“ªê“ªÞ“ª»“ªó“¡£
C<\> “ªË“ªè“ªÃ“ªÆ“áú“ªé“ªì“ªÆ“ª¤“ªë“íÞ“ùê“¡¢C<$> “ªÏ“«¯“«©’¡¼“«È“ªµ“ªì“ªÆ C<"\\\$"> “ªÈ
“ªÊ“ªê“ªÞ“ª¹“¡£
“ª½“ª¦“ªÇ“ªÊ“ª¤“íÞ“ùê“¡¢“ª³“ªì“ªÏ“î÷“ËÒ“ªµ“ªì“ªë“«¹“««“«é’ÊÑ‘Êý“ªÎ“ËÒ“ã·“ªÈ“ª·“ªÆ“ú°’¼á“ªµ“ªì“ªÞ“ª¹“¡£

=begin original

Note also that the interpolation code needs to make a decision on
where the interpolated scalar ends.  For instance, whether
C<< "a $b -> {c}" >> really means:

=end original

“î÷“ËÒ“«³’¡¼“«É“ªÏ“¡¢“î÷“ËÒ“ª¹“ªë“«¹“««“«é’ÊÑ‘Êý“ª¬“ªÉ“ª³“ªÇ“ðû“ªï“ªë“ª«“ªò“Ì½“ïÒ“ª¹“ªë“ù±“é©“ª¬
“ª¢“ªë“ª³“ªÈ“ªË“ªâ“ñ¼“ëò“ª·“ªÆ“ª¯“ªÀ“ªµ“ª¤“¡£
“ÖÇ“ª¨“ªÐ“¡¢C<< "a $b -> {c}" >> “ª¬’¼Â“ð·“ªË“ªÏ“ì¤“ù»“ªÎ“ªè“ª¦“ªË“ªÊ“ªë“ª«:

  "a " . $b . " -> {c}";

=begin original

or:

=end original

“ì¤“ù»“ªÎ“ªè“ª¦“ªË“ªÊ“ªë“ª«“ªÇ“ª¹:

  "a " . $b -> {c};

=begin original

Most of the time, the longest possible text that does not include
spaces between components and which contains matching braces or
brackets.  because the outcome may be determined by voting based
on heuristic estimators, the result is not strictly predictable.
Fortunately, it's usually correct for ambiguous cases.

=end original

“ªÛ“ªÈ“ªó“ªÉ“ªÎ“íÞ“ùê“¡¢“é©“áÈ“ªÈ“¡¢“«Þ“«Ã“«Á“ª¹“ªë“ñé“ª«“ªÃ“ª³“ªä“ÓÞ“ª«“ªÃ“ª³“ªÎ“Êà“ªË“Íö“ÛÜ“ªò“ùß“ªÞ“ªÊ“ª¤“¡¢
“õÌ“ªâ“íþ“ª¤“«Æ“«­“«¹“«È“ªË“ªÊ“ªê“ªÞ“ª¹“¡£
“õó“Õô“ªÏ’È¯“Ì¸“îÜ“ªÊ“õÏ“ïÒ“Ðï“ªò“ªè“ªë“÷á“øù“ªË“ªè“ªÃ“ªÆ“Ì½“ïÒ“ªµ“ªì“ªë“ªÎ“ªÇ“¡¢“Ì¿“Íý“ªÏ’¸·“ÚË“ªË“ªÏ
“åø“ö´“ªÇ“ª­“ªÞ“ª»“ªó“¡£
“ú¹“ª¤“¡¢“ÝÑ“ªé“ªï“ª·“ª¤“íÞ“ùê“ªÇ“ªâ“ÜÅ“÷×“ªÏ“ïá“ª·“ª¤“ªÇ“ª¹“¡£

=item the replacement of C<s///>

=begin original

Processing of C<\Q>, C<\U>, C<\u>, C<\L>, C<\l>, and interpolation
happens as with C<qq//> constructs.

=end original

C<\Q>, C<\U>, C<\u>, C<\L>, C<\l> “ªÎ’½è“×â“ªÈ“î÷“ËÒ“ª¬ C<qq//> “Ï°“ðã“ªÈ
“ÔÒ“ª¸“ªè“ª¦“ªË“ÑÃ“ª³“ªê“ªÞ“ª¹“¡£

=begin original

It is at this step that C<\1> is begrudgingly converted to C<$1> in
the replacement text of C<s///>, in order to correct the incorrigible
I<sed> hackers who haven't picked up the saner idiom yet.  A warning
is emitted if the C<use warnings> pragma or the B<-w> command-line flag
(that is, the C<$^W> variable) was set.

=end original

“ª³“ªÎ“«¹“«Æ“«Ã“«×“ªÇ“ªÏ“¡¢“ªè“ªê“Ëí“îï“ªÊ“Ùþ“Ûö“ªò“ªÞ“ªÀ“Óô“ìý“ª·“ªÆ“ª¤“ªÊ“ª¤“¡¢“â¢“ªË“Ý¶“ª¨“ªÊ“ª¤ I<sed>
“«Ï“«Ã“««’¡¼“ªÎ“ª¿“ªá“ªË“¡¢C<s///> “ªÎ“öÇ“üµ“«Æ“«­“«¹“«È“ªÎ“ñé“ªË“ª¢“ªë C<\1> “ªò“¡¢“ª·“ªÖ“ª·“ªÖ“ªÊ“ª¬“ªé
C<$1> “ªË’ÊÑ“üµ“ª·“ªÞ“ª¹“¡£
C<use warnings> “«×“«é“«°“«Þ“ªä“«³“«Þ“«ó“«É“«é“«¤“«ó“«ª“«×“«·“«ç“«ó B<-w> (“ª³“ªì“ªÏ C<$^W>
’ÊÑ‘Êý“ªÇ“ª¹) “ª¬“«»“«Ã“«È“ªµ“ªì“ªÆ“ª¤“ªë“ªÈ“Ìí“Í±“ª¬“ßæ“à÷“ªµ“ªì“ªÞ“ª¹“¡£

=item C<RE> in C<?RE?>, C</RE/>, C<m/RE/>, C<s/RE/foo/>,

=begin original

Processing of C<\Q>, C<\U>, C<\u>, C<\L>, C<\l>, C<\E>,
and interpolation happens (almost) as with C<qq//> constructs.

=end original

C<\Q>, C<\U>, C<\u>, C<\L>, C<\l> C<\E> “ªÎ’½è“×â“ªÈ“î÷“ËÒ“ª¬ C<qq//> “Ï°“ðã“ªÈ
(“ªÛ“ªÈ“ªó“ªÉ)“ÔÒ“ª¸“ªè“ª¦“ªË“ÑÃ“ª³“ªê“ªÞ“ª¹“¡£

=begin original

However any other combinations of C<\> followed by a character
are not substituted but only skipped, in order to parse them
as regular expressions at the following step.
As C<\c> is skipped at this step, C<@> of C<\c@> in RE is possibly
treated as an array symbol (for example C<@foo>),
even though the same text in C<qq//> gives interpolation of C<\c@>.

=end original

However any other combinations of C<\> followed by a character
are not substituted but only skipped, in order to parse them
as regular expressions at the following step.
As C<\c> is skipped at this step, C<@> of C<\c@> in RE is possibly
treated as an array symbol (for example C<@foo>),
even though the same text in C<qq//> gives interpolation of C<\c@>.
(TBT)

=begin original

Moreover, inside C<(?{BLOCK})>, C<(?# comment )>, and
a C<#>-comment in a C<//x>-regular expression, no processing is
performed whatsoever.  This is the first step at which the presence
of the C<//x> modifier is relevant.

=end original

“ªµ“ªé“ªË“¡¢C<(?{BLOCK})>, C<(?# comment )>, C<//x> “ïá“Ð®“øú“úÞ“ªÇ“ªÎ C<#> “ªÎ
“«³“«á“«ó“«È“ªÎ“ñé“ªÇ“ªÏ“¡¢“ªÉ“ªÎ“ªè“ª¦“ªÊ’½è“×â“ªâ“ú¼“ªï“ªì“ªÞ“ª»“ªó“¡£
“ª³“ªì“ªÏ C<//x> “áó“ãÞ“í­“ª¬“ç¯“úÂ“ªò‘Óë“ª¨“ªë“õÌ“ôø“ªÎ“«¹“«Æ“«Ã“«×“ªÇ“ª¹“¡£

=begin original

Interpolation in patterns has several quirks: C<$|>, C<$(>, C<$)>, C<@+>
and C<@-> are not interpolated, and constructs C<$var[SOMETHING]> are
voted (by several different estimators) to be either an array element
or C<$var> followed by an RE alternative.  This is where the notation
C<${arr[$bar]}> comes handy: C</${arr[0-9]}/> is interpreted as
array element C<-9>, not as a regular expression from the variable
C<$arr> followed by a digit, which would be the interpretation of
C</$arr[0-9]/>.  Since voting among different estimators may occur,
the result is not predictable.

=end original

“«Ñ“«¿’¡¼“«ó‘ÄÚ“ªÎ“î÷“ËÒ“ªÇ“ªÏ“ª¤“ª¯“ªÄ“ª«“÷å“â¨“ªÊ“ÔÑ“íÂ“ªò“ª·“ªÞ“ª¹:
C<$|>, C<$(>, C<$)>, C<@+>, C<@-> “ªÏ“î÷“ËÒ“ªµ“ªì“ªº“¡¢
C<$var[SOMETHING]> “ªÏ(“ª¤“ª¯“ªÄ“ª«“ªÎ“ì¶“ªÊ“ªë“õÏ“ïÒ“Ðï“ªË“ªè“ªÃ“ªÆ)“ÛÕ“Öª“ªÎ“é©“áÈ“ª«
C<$var> “ªÎ“ý­“ªË“ïá“Ð®“øú“úÞ“ª¬’Â³“ª¤“ªÆ“ª¤“ªë“ªÎ“ª«“ª¬“÷á“øù“ªµ“ªì“ªÞ“ª¹“¡£
“ª³“ªì“ªÏ C<${arr[$bar]}> “ª¬“øµ“××“ªË“ªÊ“ªë“ªÈ“ª³“ªí“ªÇ“ª¹: C</${arr[0-9]}/> “ªÏ
“ÛÕ“Öª“é©“áÈ C<-9> “ªÈ“ª·“ªÆ“ú°’¼á“ªµ“ªì“¡¢C</$arr[0-9]/> “ªÎ“íÞ“ùê“ªÎ“ªè“ª¦“ªË C<$arr> “ªÎ“ý­“ªË
‘Êý“ö·“ª¬’Â³“ª¤“ªÆ“ª¤“ªë“ªè“ª¦“ªÊ“ïá“Ð®“øú“úÞ“ªÈ“ª·“ªÆ“ªÏ“ú°’¼á“ªµ“ªì“ªÞ“ª»“ªó“¡£
“ì¶“ªÊ“ªÃ“ª¿“õÏ“ïÒ“Ðï“ªË“ªè“ªÃ“ªÆ“÷á“øù“ªµ“ªì“ªë“ª³“ªÈ“ª¬“ª¢“ªë“ªÎ“ªÇ“¡¢“Ì¿“Íý“ªÏ“åø“ö´“ªÇ“ª­“ªÞ“ª»“ªó“¡£

=begin original

The lack of processing of C<\\> creates specific restrictions on
the post-processed text.  If the delimiter is C</>, one cannot get
the combination C<\/> into the result of this step.  C</> will
finish the regular expression, C<\/> will be stripped to C</> on
the previous step, and C<\\/> will be left as is.  Because C</> is
equivalent to C<\/> inside a regular expression, this does not
matter unless the delimiter happens to be character special to the
RE engine, such as in C<s*foo*bar*>, C<m[foo]>, or C<?foo?>; or an
alphanumeric char, as in:

=end original

C<\\> “ªò’½è“×â“ª·“ªÊ“ª¤“ª³“ªÈ“ªË“ªè“ªê“¡¢“ý­’½è“×â“ª·“ª¿“«Æ“«­“«¹“«È“ªË“÷å“ïÒ“ªÎ“ð¤“ùÚ“ª¬“ª¢“ªê“ªÞ“ª¹“¡£
“«Ç“«ê“«ß“«¿“ª¬ C</> “ªÎ“íÞ“ùê“¡¢“ª³“ªÎ“«¹“«Æ“«Ã“«×“ªÎ“Ì¿“Íý“ªÈ“ª·“ªÆ C<\/> “ªò“Ôð“ªë“ª³“ªÈ“ªÏ
“ªÇ“ª­“ªÞ“ª»“ªó“¡£
C</> “ªÏ“ïá“Ð®“øú“úÞ“ªò“ðû“ªï“ªé“ª»“¡¢C<\/> “ªÏ“îñ“ªÎ“«¹“«Æ“«Ã“«×“ªÇ C</> “ªË“î÷“ËÒ“ªµ“ªì“¡¢
C<\\/> “ªÏ“ª½“ªÎ“ªÞ“ªÞ‘²Ð“ªµ“ªì“ªÞ“ª¹“¡£
C</> “ªÏ“ïá“Ð®“øú“úÞ“ªÎ“ñé“ªÇ“ªÏ C<\/> “ªÈ“Ôõ’²Á“ªÊ“ªÎ“ªÇ“¡¢“ª³“ªì“ªÏ“ª¿“ªÞ“ª¿“ªÞ“«Ç“«ê“«ß“«¿“ª¬
“ïá“Ð®’¸¡“ßã“«¨“«ó“«¸“«ó“ªË“ªÈ“ªÃ“ªÆ“÷å“Ü¬“ªÊ“Ùþ“í®“ªÎ“íÞ“ùê“¡¢“ªÄ“ªÞ“ªê C<s*foo*bar*>,
C<m[foo]>, C<?foo?> “ªÎ“ªè“ª¦“ªÊ“íÞ“ùê“¡¢“ª¢“ªë“ª¤“ªÏ“ì¤“ù»“ªÎ“ªè“ª¦“ªË“çÈ‘Êý“í®“ªÇ“ªÊ“ª±“ªì“ªÐ“¡¢
“Ùý“ð¹“ªË“ªÏ“ªÊ“ªê“ªÞ“ª»“ªó:

  m m ^ a \s* b mmx;

=begin original

In the RE above, which is intentionally obfuscated for illustration, the
delimiter is C<m>, the modifier is C<mx>, and after delimiter-removal the
RE is the same as for C<m/ ^ a \s* b /mx>.  There's more than one
reason you're encouraged to restrict your delimiters to non-alphanumeric,
non-whitespace choices.

=end original

“ß¾“ÑÀ“ªÎ“ïá“Ð®“øú“úÞ“ªÇ“ªÏ“¡¢’Àâ“Ù¥“ªÎ“ª¿“ªá“ªË“ëò’¿Þ“îÜ“ªË“ªï“ª«“ªê“ªË“ª¯“ª¯“ª·“ªÆ“ª¤“ªÞ“ª¹“ª¬“¡¢
“«Ç“«ê“«ß“«¿“ªÏ C<m> “ªÇ“¡¢“áó“ãÞ“í­“ªÏ C<mx> “ªÇ“¡¢“«Ç“«ê“«ß“«¿“ªò“ö¢“ªê“ð¶“ª¤“ª¿“ý­“ªÎ
“ïá“Ð®“øú“úÞ“ªÏ C<m/ ^ a \s* b /mx> “ªÈ“ÔÒ“ª¸“ªÇ“ª¹“¡£
“«Ç“«ê“«ß“«¿“ªò“çÈ‘Êý“í®“ªä“Íö“ÛÜ“ªÇ“ªÊ“ª¤“ªâ“ªÎ“ªË“ð¤“ùÚ“ª¹“ªë“ªÙ“ª­“ªÇ“ª¢“ªë“×â“ë¦“ªÏ“ÜÜ‘Êý“ª¢“ªê“ªÞ“ª¹“¡£

=back

=begin original

This step is the last one for all constructs except regular expressions,
which are processed further.

=end original

“ª³“ªì“ªÏ“ïá“Ð®“øú“úÞ“ì¤“èâ“ªÎ“îï“ªÆ“ªÎ“Ï°“ðã“ªË“ªÈ“ªÃ“ªÆ“õÌ“ý­“ªÎ“«¹“«Æ“«Ã“«×“ªÇ“ª¹“¡£
“ïá“Ð®“øú“úÞ“ªÏ“ªµ“ªé“ªË’½è“×â“ª¬’Â³“ª­“ªÞ“ª¹“¡£

=item parsing regular expressions
X<regexp, parse>

(“ïá“Ð®“øú“úÞ“ªÎ“«Ñ’¡¼“«¹)

=begin original

Previous steps were performed during the compilation of Perl code,
but this one happens at run time--although it may be optimized to
be calculated at compile time if appropriate.  After preprocessing
described above, and possibly after evaluation if concatenation,
joining, casing translation, or metaquoting are involved, the
resulting I<string> is passed to the RE engine for compilation.

=end original

“ì¤“îñ“ªÎ“«¹“«Æ“«Ã“«×“ªÏ Perl “«³’¡¼“«É“ªÎ“«³“«ó“«Ñ“«¤“«ë“ñé“ªË’¼Â“ú¼“ªµ“ªì“ªÞ“ª¹“ª¬“¡¢
“ª³“ªì“ªÏ’¼Â“ú¼“ãÁ“ªË“ÑÃ“ª³“ªê“ªÞ“ª¹ -- “ª·“ª«“ª·“¡¢“ªâ“ª·“îê“ï·“ªÊ“ªé“«³“«ó“«Ñ“«¤“«ë“ãÁ“ªË
“Íª“ß©“ªÇ“ª­“ªë“ªè“ª¦“ªË“õÌ“îê“ûù“ªµ“ªì“ªë“ª³“ªÈ“ªâ“ª¢“ªê“ªÞ“ª¹“¡£
“ß¾“ÑÀ“ªÎ“îñ’½è“×â“ªÎ“ý­“¡¢“ª½“ª·“ªÆ“ù±“é©“ªÊ“ªé“Ö§“Ì¿“¡¢“Ì¿“ùê“¡¢“ÓÞ“Ùþ“í®“á³“Ùþ“í®’ÊÑ“üµ“¡¢
“«á“«¿“«¯“«©’¡¼“«È“ûù“ª¬“ú¼“ªï“ªì“ª¿“ý­“¡¢“Ì¿“Íý“ªÎ I<“Ùþ“í®“Öª> “ª¬“«³“«ó“«Ñ“«¤“«ë“ªÎ“ª¿“ªá“ªË
“ïá“Ð®“øú“úÞ“«¨“«ó“«¸“«ó“ªË“Ô¤“ªµ“ªì“ªÞ“ª¹“¡£

=begin original

Whatever happens in the RE engine might be better discussed in L<perlre>,
but for the sake of continuity, we shall do so here.

=end original

“ïá“Ð®“øú“úÞ“«¨“«ó“«¸“«ó“ªÇ“ÑÃ“ª³“ªë“ª³“ªÈ“ªË“ªÄ“ª¤“ªÆ“ªÏ L<perlre> “ªÇ“ì¡“Öå“ª·“ª¿“Û°“ª¬
“ªè“ª¤“ªÇ“ª·“ªç“ª¦“ª¬“¡¢’·Ñ’Â³“àõ“ªÎ“ª¿“ªá“ªË“¡¢“ª³“ª³“ªÇ“ª½“ªì“ªò“ú¼“ª¤“ªÞ“ª¹“¡£

=begin original

This is another step where the presence of the C<//x> modifier is
relevant.  The RE engine scans the string from left to right and
converts it to a finite automaton.

=end original

“ª³“ªì“ªâ C<//x> “áó“ãÞ“í­“ªÎ“ðí“î¤“ª¬’´Ø“Ö§“ª¹“ªë“«¹“«Æ“«Ã“«×“ªÎ“ìé“ªÄ“ªÇ“ª¹“¡£
“ïá“Ð®“øú“úÞ“«¨“«ó“«¸“«ó“ªÏ“Ùþ“í®“Öª“ªò“ñ§“ª«“ªé“éÓ“ªË“«¹“«­“«ã“«ó“ª·“ªÆ“¡¢“êó“ùÚ‘×´“÷¾“«ª’¡¼“«È“«Þ“«È“«ó“ªË
’ÊÑ“üµ“ª·“ªÞ“ª¹“¡£

=begin original

Backslashed characters are either replaced with corresponding
literal strings (as with C<\{>), or else they generate special nodes
in the finite automaton (as with C<\b>).  Characters special to the
RE engine (such as C<|>) generate corresponding nodes or groups of
nodes.  C<(?#...)> comments are ignored.  All the rest is either
converted to literal strings to match, or else is ignored (as is
whitespace and C<#>-style comments if C<//x> is present).

=end original

“«Ð“«Ã“«¯“«¹“«é“«Ã“«·“«å“Üõ“ª­“ªÎ“Ùþ“í®“ªÏ(C<\{> “ªÎ“ªè“ª¦“ªË)’ÂÐ’±þ“ª¹“ªë“«ê“«Æ“«é“«ë“Ùþ“í®“Öª“ªË
“öÇ“üµ“ªµ“ªì“ªë“ª«“¡¢“ª¢“ªë“ª¤“ªÏ(C<\b> “ªÎ“ªè“ª¦“ªË)“êó“ùÚ‘×´“÷¾“«ª’¡¼“«È“«Þ“«È“«ó“ªÎ“÷å“Ü¬“ªÊ
“«Î’¡¼“«É“ªò“ßæ“à÷“ª·“ªÞ“ª¹“¡£
(C<|> “ªÎ“ªè“ª¦“ªÊ)“ïá“Ð®“øú“úÞ“«¨“«ó“«¸“«ó“ªË“ªÈ“ªÃ“ªÆ“÷å“Ü¬“ªÊ“Ùþ“í®“ªÏ’ÂÐ’±þ“ª¹“ªë“«Î’¡¼“«É“ª«
“«Î’¡¼“«É“ªÎ“«°“«ë’¡¼“«×“ªò“ßæ“à÷“ª·“ªÞ“ª¹“¡£
‘²Ð“ªê“ªÎ“îï“ªÆ“ªÏ“«Þ“«Ã“«Á“ª¹“ªë“«ê“«Æ“«é“«ë“Ùþ“í®“Öª“ªË’ÊÑ“üµ“ªµ“ªì“ªë“ª«“¡¢“ª½“ª¦“ªÇ“ªÊ“ª±“ªì“ªÐ
(C<//x> “ª¬“ò¦“ïÒ“ªµ“ªì“ª¿“ãÁ“ªÎ“Íö“ÛÜ“ªÈ C<#> “«¹“«¿“«¤“«ë“ªÎ“«³“«á“«ó“«È“ªÈ“ÔÒ’ÍÍ“ªË)
“Ùí“ãÊ“ªµ“ªì“ªÞ“ª¹“¡£

=begin original

Parsing of the bracketed character class construct, C<[...]>, is
rather different than the rule used for the rest of the pattern.
The terminator of this construct is found using the same rules as
for finding the terminator of a C<{}>-delimited construct, the only
exception being that C<]> immediately following C<[> is treated as
though preceded by a backslash.  Similarly, the terminator of
C<(?{...})> is found using the same rules as for finding the
terminator of a C<{}>-delimited construct.

=end original

“Ùþ“í®“«¯“«é“«¹“Ï°“ðã C<[...]> “ªÎ“«Ñ’¡¼“«¹“ªÏ“öâ“ªÎ“«Ñ“«¿’¡¼“«ó“ªÈ“ªÏ“«ë’¡¼“«ë“ª¬“ì¶“ªÊ“ªê“ªÞ“ª¹“¡£
“ª³“ªÎ“Ï°“ðã“ªÎ“ðû“Ó®“ªÏ C<{}> “ªÇ“«Ç“«ê“«ß“«¿“ªµ“ªì“ª¿“Ï°“ðã“ªÎ“ðû“Ó®“ªò’¸¡“ßã“ª¹“ªë“ªÎ“ªÈ“ÔÒ“ª¸“«ë’¡¼“«ë“ªÇ
’¸¡“ßã“ªµ“ªì“ªÞ“ª¹; “êæ“ìé“ªÎ“ÖÇ“èâ“ªÏ“¡¢C<[> “ªÎ“òÁ“ý­“ªÎ C<]> “ªÏ“«Ð“«Ã“«¯“«¹“«é“«Ã“«·“«å“ª¬
“à»“ú¼“ª·“ªÆ“ª¤“ªë“ªâ“ªÎ“ªÈ“ª·“ªÆ“Ðâ“ªï“ªì“ªÞ“ª¹“¡£
“ÔÒ’ÍÍ“ªË“¡¢C<(?{...})> “ªÎ“ðû“Ó®“ªÏ C<{}> “ªÇ“«Ç“«ê“«ß“«¿“ªµ“ªì“ª¿“Ï°“ðã“ªÎ“ðû“Ó®“ªò
’¸¡“ßã“ªµ“ªì“ªë“ªÎ“ªÈ“ÔÒ“ª¸“«ë’¡¼“«ë“ªÇ’¸¡“ßã“ªµ“ªì“ªÞ“ª¹“¡£

=begin original

It is possible to inspect both the string given to RE engine and the
resulting finite automaton.  See the arguments C<debug>/C<debugcolor>
in the C<use L<re>> pragma, as well as Perl's B<-Dr> command-line
switch documented in L<perlrun/"Command Switches">.

=end original

“ïá“Ð®“øú“úÞ“ªË‘Óë“ª¨“ªé“ªì“ªë“Ùþ“í®“Öª“ªÈ“¡¢“Ì¿“Íý“ªÈ“ª·“ªÆ“ªÎ“êó“ùÚ‘×´“÷¾“«ª’¡¼“«È“«Þ“«È“«ó“ªÎ’Î¾“Û°“ªò
’¸¡“ÞÛ“ªÇ“ª­“ªÞ“ª¹“¡£
C<use L<re>> “«×“«é“«°“«Þ“ªÎ C<debug>/C<debugcolor> “ìÚ‘Êý“ªÈ“¡¢
L<perlrun/"Command Switches"> “ªË“ÑÀ“âû“ªµ“ªì“ªÆ“ª¤“ªë B<-Dr> “«³“«Þ“«ó“«É“«é“«¤“«ó
“«ª“«×“«·“«ç“«ó“ªò‘²Î“ðÎ“ª·“ªÆ“ª¯“ªÀ“ªµ“ª¤“¡£

=item Optimization of regular expressions
X<regexp, optimization>

=begin original

This step is listed for completeness only.  Since it does not change
semantics, details of this step are not documented and are subject
to change without notice.  This step is performed over the finite
automaton that was generated during the previous pass.

=end original

“ª³“ªÎ“«¹“«Æ“«Ã“«×“ªÏ“èÇ“îï“àõ“ªÎ“ª¿“ªá“ªÀ“ª±“ªË“«ê“«¹“«È“ªµ“ªì“ªÆ“ª¤“ªÞ“ª¹“¡£
“ª³“ªì“ªÏ“ëò“Ú«“Öå“îÜ“ªË“ªÏ’ÊÑ“ûù“ª¬“ªÊ“ª¤“ªÎ“ªÇ“¡¢“ª³“ªÎ“«¹“«Æ“«Ã“«×“ªÎ“ßÙ“á¬“ªÏ“Ùþ“ßö“ûù“ªµ“ªì“ªÆ“ªª“ªé“ªº“¡¢
‘½«‘À´“åø“Í±“ªÊ“ª·“ªË’ÊÑ“ÌÚ“ªµ“ªì“ªë“ª³“ªÈ“ª¬“ª¢“ªê“ªÞ“ª¹“¡£
“ª³“ªÎ“«¹“«Æ“«Ã“«×“ªÏ“ª³“ª³“ªÞ“ªÇ“ªÎ’½è“×â“ªÇ“ßæ“à÷“ªµ“ªì“ª¿“êó“ùÚ“«ª’¡¼“«È“«Þ“«È“«ó“ªË’ÂÐ“ª·“ªÆ
“îê“éÄ“ªµ“ªì“ªÞ“ª¹“¡£

=begin original

It is at this stage that C<split()> silently optimizes C</^/> to
mean C</^/m>.

=end original

C<split()> “ªÇ C</^/> “ªò“äÞ’ÌÛ“ªË C</^/m> “ªË“õÌ“îê“ûù“ª¹“ªë“ªÎ“ªâ“ª³“ªÎ“«¹“«Æ“«Ã“«×“ªÇ“ª¹“¡£

=back

=head2 I/O Operators
X<operator, i/o> X<operator, io> X<io> X<while> X<filehandle>
X<< <> >> X<@ARGV>

(I/O “æÑ“ß©“í­)

=begin original

There are several I/O operators you should know about.

=end original

“ò±“ªÃ“ªÆ“ªª“ª¤“ª¿“Û°“ª¬“ªè“ª¤ I/O “æÑ“ß©“í­“ªâ“ª¤“ª¯“ªÄ“ª«“ª¢“ªê“ªÞ“ª¹“¡£

=begin original

A string enclosed by backticks (grave accents) first undergoes
double-quote interpolation.  It is then interpreted as an external
command, and the output of that command is the value of the
backtick string, like in a shell.  In scalar context, a single string
consisting of all output is returned.  In list context, a list of
values is returned, one per line of output.  (You can set C<$/> to use
a different line terminator.)  The command is executed each time the
pseudo-literal is evaluated.  The status value of the command is
returned in C<$?> (see L<perlvar> for the interpretation of C<$?>).
Unlike in B<csh>, no translation is done on the return data--newlines
remain newlines.  Unlike in any of the shells, single quotes do not
hide variable names in the command from interpretation.  To pass a
literal dollar-sign through to the shell you need to hide it with a
backslash.  The generalized form of backticks is C<qx//>.  (Because
backticks always undergo shell expansion as well, see L<perlsec> for
security concerns.)
X<qx> X<`> X<``> X<backtick> X<glob>

=end original

“«Ð“«Ã“«¯“«¯“«©’¡¼“«È“ªÇ“ÎÀ“ªé“ªì“ª¿“Ùþ“í®“Öª“ªÏ“¡¢“ªÞ“ªº“¡¢“«À“«Ö“«ë“«¯“«©’¡¼“«È“ÜÍ“èÇ“ªÎ“ªè“ª¦“ªË
’ÊÑ‘Êý“ªÎ“î÷“ËÒ“ª¬“ú¼“ªÊ“ªï“ªì“ªÞ“ª¹“¡£
“ª½“ªÎ“ý­“¡¢“«·“«§“«ë“ªÇ“ªÎ“íÞ“ùê“ªÈ“ÔÒ“ª¸“ªè“ª¦“ªË“¡¢“èâ“Ý»“«³“«Þ“«ó“«É“ªÈ“ª·“ªÆ“ú°’¼á“ªµ“ªì“¡¢
“ª½“ªÎ“«³“«Þ“«ó“«É“ªÎ“õó“Õô“ª¬“ª³“ªÎ“«Ð“«Ã“«¯“«¯“«©’¡¼“«È“Ùþ“í®“Öª“ªÎ“ö·“ªÈ“ªÊ“ªê“ªÞ“ª¹“¡£
“«¹“««“«é’¡¼“«³“«ó“«Æ“«­“«¹“«È“ªÇ“ªÏ“¡¢“õó“Õô“ª¹“ªÙ“ªÆ“ªò“ùß“ªà“ìé“ËÁ“ªÎ“Ùþ“í®“Öª“ª¬“Ú÷“ªµ“ªì“ªÞ“ª¹“¡£
“«ê“«¹“«È“«³“«ó“«Æ“«­“«¹“«È“ªÇ“ªÏ“¡¢“õó“Õô“ªÎ 1 “ú¼ 1 “ú¼“ª¬“ËÁ‘¡©“ªÎ“é©“áÈ“ªÈ“ªÊ“ªë“«ê“«¹“«È“ª¬“Ú÷“ªµ“ªì“ªÞ“ª¹“¡£
(C<$/> “ªò“àâ“ïÒ“ª¹“ªì“ªÐ“¡¢“ú¼“ªÎ“ðû“ªï“ªê“ªò“ãÆ“ª¹“Ùþ“í®“ªò’ÊÑ“ª¨“ªë“ª³“ªÈ“ª¬“ªÇ“ª­“ªÞ“ª¹“¡£)
“«³“«Þ“«ó“«É“ªÏ“¡¢“ª³“ªÎ“ëô“ÞÄ“«ê“«Æ“«é“«ë“ª¬“øÄ’²Á“ªµ“ªì“ªë“ª´“ªÈ“ªË’¼Â“ú¼“ªµ“ªì“ªÞ“ª¹“¡£
“«³“«Þ“«ó“«É“ªÎ“«¹“«Æ’¡¼“«¿“«¹“ö·“ªÏ C<$?> “ªË“Ú÷“ªµ“ªì“ªÞ“ª¹ (C<$?> “ªÎ“ú°’¼á“ªË“ªÄ“ª¤“ªÆ“ªÏ“¡¢
L<perlvar> “ªò‘²Î“ðÎ“ª·“ªÆ“ª¯“ªÀ“ªµ“ª¤)“¡£
B<csh> “ªÇ“ªÎ“íÞ“ùê“ªÈ“ªÏ“êÞ“ªÃ“ªÆ“¡¢“Ì¿“Íý“ªÎ“«Ç’¡¼“«¿“ªË’ÂÐ“ª¹“ªë’ÊÑ“üµ“ªÏ“ú¼“ªÊ“ªï“ªì“ªº“¡¢
“ËÇ“ú¼“ªÏ“ËÇ“ú¼“ªÎ“ªÞ“ªÞ“ªÇ“ª¹“¡£
“ªÉ“ªÎ“«·“«§“«ë“ªÈ“ªâ“êÞ“ªÃ“ªÆ“¡¢“«·“«ó“«°“«ë“«¯“«©’¡¼“«È“ª¬“«³“«Þ“«ó“«É“ñé“ªÎ’ÊÑ‘Êý“Ù£“ªò
“ú°’¼á“ªµ“ª»“ªÊ“ª¤“ªè“ª¦“ªË“ª¹“ªë“ª³“ªÈ“ªÏ“ª¢“ªê“ªÞ“ª»“ªó“¡£
“«·“«§“«ë“ªË“«ê“«Æ“«é“«ë“ªÊ“«É“«ë“ÑÀ‘ºÅ“ªò“Ô¤“ª¹“ªË“ªÏ“¡¢“«Ð“«Ã“«¯“«¹“«é“«Ã“«·“«å“ªÇ
“«¨“«¹“«±’¡¼“«×“ª·“ªÊ“ª±“ªì“ªÐ“ªÊ“ªê“ªÞ“ª»“ªó“¡£
“«Ð“«Ã“«¯“«¯“«©’¡¼“«È“ªÎ“ìé“Úõ“û¡“ªÏ“¡¢C<qx//> “ªÇ“ª¹“¡£
(“«Ð“«Ã“«¯“«¯“«©’¡¼“«È“ªÏ“ßÈ“ªË“«·“«§“«ë“î÷“ËÒ“ªµ“ªì“ªÞ“ª¹“¡£
“«»“«­“«å“«ê“«Æ“«£“ªË’´Ø“ª·“ªÆ“ªÏ L<perlsec> “ªò‘²Î“ðÎ“ª·“ªÆ“ù»“ªµ“ª¤)

=begin original

In scalar context, evaluating a filehandle in angle brackets yields
the next line from that file (the newline, if any, included), or
C<undef> at end-of-file or on error.  When C<$/> is set to C<undef>
(sometimes known as file-slurp mode) and the file is empty, it
returns C<''> the first time, followed by C<undef> subsequently.

=end original

“«¹“««“«é’¡¼“«³“«ó“«Æ“«­“«¹“«È“ªÇ“ß£“ÎÀ“ûÁ“ªÎ“ñé“ªÎ“«Õ“«¡“«¤“«ë“«Ï“«ó“«É“«ë“ªò“øÄ’²Á“ª¹“ªë“ªÈ“¡¢
“ª½“ªÎ“«Õ“«¡“«¤“«ë“ª«“ªé“¡¢“ó­“ªÎ“ú¼“ªò’ÆÉ“ªß’¹þ“ªà“ª³“ªÈ“ªË“ªÊ“ªê“ªÞ“ª¹
(“ËÇ“ú¼“ª¬“ª¢“ªì“ªÐ“ª½“ªì“ªâ“ùß“ªÞ“ªì“ªÞ“ª¹)“¡£
“«Õ“«¡“«¤“«ë“ªÎ“õÌ“ý­“ªÞ“ª¿“ªÏ“«¨“«é’¡¼“ªÎ“íÞ“ùê“ªÏ C<undef> “ªò“Ú÷“ª·“ªÞ“ª¹“¡£
C<$/> “ª¬ C<undef> “ªË“àâ“ïÒ“ªµ“ªì“ªÆ“ª¤“ªë“íÞ“ùê(“«Õ“«¡“«¤“«ë“ýå“ª¤’¹þ“ªß“«â’¡¼“«É“ªÈ“û¼“ªÐ“ªì“ªÞ“ª¹)
“ªÇ“«Õ“«¡“«¤“«ë“ª¬“Íö“ªÎ“íÞ“ùê“¡¢
“õÌ“ôø“ªÏ C<''> “ªò“Ú÷“ª·“¡¢“ó­“ªÏ C<undef> “ªò“Ú÷“ª·“ªÞ“ª¹“¡£

=begin original

Ordinarily you must assign the returned value to a variable, but
there is one situation where an automatic assignment happens.  If
and only if the input symbol is the only thing inside the conditional
of a C<while> statement (even if disguised as a C<for(;;)> loop),
the value is automatically assigned to the global variable $_,
destroying whatever was there previously.  (This may seem like an
odd thing to you, but you'll use the construct in almost every Perl
script you write.)  The $_ variable is not implicitly localized.
You'll have to put a C<local $_;> before the loop if you want that
to happen.

=end original

“÷×“ßÈ“ªÏ“¡¢“Ú÷“ªµ“ªì“ª¿“ö·“ªò’ÊÑ‘Êý“ªË“ÓÛ“ìý“ª·“ªÊ“ª±“ªì“ªÐ“ªÊ“ªê“ªÞ“ª»“ªó“ª¬“¡¢“í»“ÔÑ“îÜ“ªË
“ÓÛ“ìý“ªµ“ªì“ªë“íÞ“ùê“ª¬ 1 “ªÄ“ªÀ“ª±“ª¢“ªê“ªÞ“ª¹“¡£
“ª³“ªÎ“ìý“Õô“«·“«ó“«Ü“«ë“ª¬“¡¢while “Ùþ(C<for(;;)> “ªÎ“û¡“ªË“ªÊ“ªÃ“ªÆ“ª¤“ª¿“ªÈ“ª·“ªÆ“ªâ)“ªÎ‘Ìõ“Ëì“ãÒ“ñé“ªË
’Ã±‘¶À“ªÇ“úÞ“ªì“ª¿“íÞ“ùê“ªÀ“ª±“ªÏ“¡¢“ª½“ªÎ“ö·“ª¬“í»“ÔÑ“îÜ“ªË“«°“«í’¡¼“«Ð“«ë’ÊÑ‘Êý $_ “ªË“ÓÛ“ìý“ªµ“ªì“ªÞ“ª¹“¡£
“ì¤“îñ“ªÎ“ö·“ªÏ“÷ò’²õ“ªµ“ªì“ªÞ“ª¹“¡£
(“ª³“ªì“ªÏ“¡¢“Ðô“ÙØ“ªË“ÞÖ“ª¨“ªë“ª«“ªâ“ª·“ªì“ªÞ“ª»“ªó“ª¬“¡¢“ªÛ“ªÈ“ªó“ªÉ“ª¹“ªÙ“ªÆ“ªÎ Perl “«¹“«¯“«ê“«×“«È“ªÇ
“ª³“ªì“ª¬“ù±“é©“ªË“ªÊ“ªë“ª³“ªÈ“ªÇ“ª·“ªç“ª¦“¡£)
$_ ’ÊÑ‘Êý“ªÏ“äÞ’ÌÛ“ªË“ªÏ“«í’¡¼“««“«ë“ûù“ªµ“ªì“ªÞ“ª»“ªó“¡£
“ª½“ª¦“ª·“ª¿“ª¤“íÞ“ùê“ªÏ“«ë’¡¼“«×“ªÎ“îñ“ªË C<local $_;> “ªÈ“ßö“ª¯“ù±“é©“ª¬“ª¢“ªê“ªÞ“ª¹“¡£

=begin original

The following lines are equivalent:

=end original

“ì¤“ù»“ªÎ“ªâ“ªÎ“ªÏ“¡¢“ªª“û»“ª¤“ªË“ÔÒ“ö·“ªÊ“ªâ“ªÎ“ªÇ“ª¹:

    while (defined($_ = <STDIN>)) { print; }
    while ($_ = <STDIN>) { print; }
    while (<STDIN>) { print; }
    for (;<STDIN>;) { print; }
    print while defined($_ = <STDIN>);
    print while ($_ = <STDIN>);
    print while <STDIN>;

=begin original

This also behaves similarly, but avoids $_ :

=end original

“ì¤“ù»“ªÏ“ÔÒ’ÍÍ“ªÎ“òÉ“ªë“Ùñ“ª¤“ªò“ª·“ªÞ“ª¹“ª¬“¡¢$_ “ªò“ÞÅ“ª¤“ªÞ“ª»“ªó:

    while (my $line = <STDIN>) { print $line }

=begin original

In these loop constructs, the assigned value (whether assignment
is automatic or explicit) is then tested to see whether it is
defined.  The defined test avoids problems where line has a string
value that would be treated as false by Perl, for example a "" or
a "0" with no trailing newline.  If you really mean for such values
to terminate the loop, they should be tested for explicitly:

=end original

“ª³“ªì“ªé“ªÎ“«ë’¡¼“«×“Ï°“ðã“ªÎ“ñé“ªÇ“¡¢“ÓÛ“ìý“ªµ“ªì“ª¿“ö·“ªÏ (“ÓÛ“ìý“ª¬“í»“ÔÑ“ª«“Ù¥“ãÆ“îÜ“ª«“ªË’´Ø“ªï“ªê“ªÊ“ª¯)
“ïÒ“ëù“ªµ“ªì“ªÆ“ª¤“ªë“ª«“ªÉ“ª¦“ª«“ªò“Ì¸“ªë“ª¿“ªá“ªË“«Æ“«¹“«È“ªµ“ªì“ªÞ“ª¹“¡£
“ïÒ“ëù“«Æ“«¹“«È“ªÏ“¡¢“ú¼“ª¬ Perl “ªË“ªÈ“ªÃ“ªÆ˜ºô“ªÈ“ªÊ“ªë“Ùþ“í®“Öª“ö·“ªò“ò¥“ªÃ“ªÆ“ª¤“ªë“ª«“ªÉ“ª¦“ª«“ªÎ
“Ùý“ð¹“ªò“ù­“ª±“ªÞ“ª¹“¡£“ÖÇ“ª¨“ªÐ newline “ªÎ“ªÄ“ª¤“ªÆ“ª¤“ªÊ“ª¤  "" “ªä "0" “ªÇ“ª¹“¡£
“ªâ“ª·“Üâ‘µ±“ªË“ª³“ªÎ“ªè“ª¦“ªÊ“ö·“ªÇ“«ë’¡¼“«×“ªò“ðû“Öõ“ªµ“ª»“ª¿“ª¤“ªÈ“ª­“ªÏ“¡¢
“ì¤“ù»“ªÎ“ªè“ª¦“ªË“Ù¥“ãÆ“îÜ“ªË“«Æ“«¹“«È“ª¹“ªë“ªÙ“ª­“ªÇ“ª¹:

    while (($_ = <STDIN>) ne '0') { ... }
    while (<STDIN>) { last unless $_; ... }

=begin original

In other boolean contexts, C<< <I<filehandle>> >> without an
explicit C<defined> test or comparison elicit a warning if the
C<use warnings> pragma or the B<-w>
command-line switch (the C<$^W> variable) is in effect.

=end original

“ª½“ªÎ“öâ“ªÎ“«Ö’¡¼“«ë“ö·“«³“«ó“«Æ“«­“«¹“«È“ªÇ“ªÏ“¡¢“Ù¥“ãÆ“îÜ“ªÊ C<defined> “ªä“Ýï“Îò“ªÊ“ª·“ªË
C<< <I<filehandle>> >> “ªò“ÞÅ“ª¦“ªÈ“¡¢C<use warnings> “«×“«é“«°“«Þ“ªä
B<-w> “«³“«Þ“«ó“«É“«é“«¤“«ó“«¹“«¤“«Ã“«Á (C<$^W> ’ÊÑ‘Êý) “ª¬“êó’¸ú“ªÊ“ªÈ“ª­“ªË“ªÏ“¡¢
“Ìí“Í±“ªò’È¯“ßæ“ªµ“ª»“ªÞ“ª¹“¡£

=begin original

The filehandles STDIN, STDOUT, and STDERR are predefined.  (The
filehandles C<stdin>, C<stdout>, and C<stderr> will also work except
in packages, where they would be interpreted as local identifiers
rather than global.)  Additional filehandles may be created with
the open() function, amongst others.  See L<perlopentut> and
L<perlfunc/open> for details on this.
X<stdin> X<stdout> X<sterr>

=end original

STDIN“¡¢STDOUT“¡¢STDERR “ªÈ“ª¤“ª¦“«Õ“«¡“«¤“«ë“«Ï“«ó“«É“«ë“ªÏ“¡¢“ª¢“ªé“ª«“ª¸“ªá“ïÒ“ëù“ªµ“ªì“ªÆ“ª¤“ªÞ“ª¹“¡£
(C<stdin>“¡¢C<stdout>“¡¢C<stderr> “ªÈ“ª¤“ª¦“«Õ“«¡“«¤“«ë“«Ï“«ó“«É“«ë“ªâ“¡¢
“«í’¡¼“««“«ë“ªÊ“Ù£“îñ“ªÇ“ª³“ªì“ªé“ªÎ“«°“«í’¡¼“«Ð“«ë“ªÊ“Ù£“îñ“ª¬“Ì¸“ª¨“ªÊ“ª¯“ªÊ“ªÃ“ªÆ“ª¤“ªë
“«Ñ“«Ã“«±’¡¼“«¸“ªò“ð¶“ª±“ªÐ“¡¢“ÞÅ“éÄ“ª¹“ªë“ª³“ªÈ“ª¬“ªÇ“ª­“ªÞ“ª¹“¡£)
“ª½“ªÎ“öâ“ªÎ“«Õ“«¡“«¤“«ë“«Ï“«ó“«É“«ë“ªÏ“¡¢open() ’´Ø‘Êý“ªÊ“ªÉ“ªÇ“íÂ“ªë“ª³“ªÈ“ª¬“ªÇ“ª­“ªÞ“ª¹“¡£
“ª³“ªì“ªË’´Ø“ª¹“ªë“ßÙ“á¬“ªË“ªÄ“ª¤“ªÆ“ªÏ L<perlopentut> “ªÈ L<perlfunc/open> “ªò
‘²Î“ðÎ“ª·“ªÆ“ù»“ªµ“ª¤“¡£
X<stdin> X<stdout> X<sterr>

=begin original

If a <FILEHANDLE> is used in a context that is looking for
a list, a list comprising all input lines is returned, one line per
list element.  It's easy to grow to a rather large data space this
way, so use with care.

=end original

<FILEHANDLE> “ª¬“«ê“«¹“«È“ªò“ù±“é©“ªÈ“ª¹“ªë“«³“«ó“«Æ“«­“«¹“«È“ªÇ“éÄ“ª¤“ªé“ªì“ªë“ªÈ“¡¢
1 “é©“áÈ“ªË 1 “ú¼“ªÎ“ìý“Õô“ú¼“ª¹“ªÙ“ªÆ“ª«“ªé“ªÊ“ªë“«ê“«¹“«È“ª¬“Ú÷“ªµ“ªì“ªÞ“ª¹“¡£
“ª³“ªì“ªò“ÞÅ“ª¦“ªÈ“ÊÛ’Ã±“ªË“ª«“ªÊ“ªê“ÓÞ“ª­“ªÊ“«Ç’¡¼“«¿“ªË“ªÊ“ªÃ“ªÆ“ª·“ªÞ“ª¤“ªÞ“ª¹“ªÎ“ªÇ“¡¢
“ñ¼“ëò“ªò“é©“ª·“ªÞ“ª¹“¡£

=begin original

<FILEHANDLE> may also be spelled C<readline(*FILEHANDLE)>.
See L<perlfunc/readline>.

=end original

<FILEHANDLE> “ªÏ C<readline(*FILEHANDLE)> “ªÈ“ªâ“ßö“ª±“ªÞ“ª¹“¡£
L<perlfunc/readline> “ªò‘²Î“ðÎ“ª·“ªÆ“ù»“ªµ“ª¤“¡£

=begin original

The null filehandle <> is special: it can be used to emulate the
behavior of B<sed> and B<awk>.  Input from <> comes either from
standard input, or from each file listed on the command line.  Here's
how it works: the first time <> is evaluated, the @ARGV array is
checked, and if it is empty, C<$ARGV[0]> is set to "-", which when opened
gives you standard input.  The @ARGV array is then processed as a list
of filenames.  The loop

=end original

“«Ì“«ë“«Õ“«¡“«¤“«ë“«Ï“«ó“«É“«ë <> “ªÏ“÷å“Ü¬“ªÇ“¡¢B<sed> “ªä B<awk> “ªÎ“ÔÑ“íÂ“ªò
“«¨“«ß“«å“«ì’¡¼“«È“ª¹“ªë“ª¿“ªá“ªË“ÞÅ“ªï“ªì“ªÞ“ª¹“¡£
<> “ª«“ªé“ªÎ“ìý“Õô“ªÏ“¡¢“øö“ñÞ“ìý“Õô“ª«“ªé“ª«“¡¢“«³“«Þ“«ó“«É“«é“«¤“«ó“ß¾“ªË˜­å“ªÙ“ªé“ªì“ª¿“ËÁ‘¡©“ªÎ
“«Õ“«¡“«¤“«ë“ª«“ªé“ú¼“ªÊ“ªï“ªì“ªÞ“ª¹“¡£
“ÔÑ“íÂ“ªÎ‘¸Å“é©“ªÏ“¡¢“ì¤“ù»“ªÎ“ªè“ª¦“ªË“ªÊ“ªê“ªÞ“ª¹“¡£
“õÌ“ôø“ªË <> “ª¬“øÄ’²Á“ªµ“ªì“ªë“ªÈ“¡¢“ÛÕ“Öª @ARGV “ª¬“ðà“ªÙ“ªé“ªì“¡¢“Íö“ªÇ“ª¢“ªì“ªÐ“¡¢
C<$ARGV[0]> “ªË "-"“ªò“àâ“ïÒ“ª·“ªÞ“ª¹“¡£
“ª³“ªì“ªÏ“¡¢open “ªµ“ªì“ªë“ªÈ“ª­“øö“ñÞ“ìý“Õô“ªÈ“ªÊ“ªê“ªÞ“ª¹“¡£
“ª½“ªÎ“ý­“¡¢“ÛÕ“Öª @ARGV “ª¬“«Õ“«¡“«¤“«ë“Ù£“ªÎ“«ê“«¹“«È“ªÈ“ª·“ªÆ’½è“×â“ªµ“ªì“ªÞ“ª¹“¡£

    while (<>) {
	...			# code for each line
    }

=begin original

is equivalent to the following Perl-like pseudo code:

=end original

“ªÏ“ì¤“ù»“ªÎ“ªÎ“ªè“ª¦“ªÊ Perl “ªÎ“ëô“ÞÄ“«³’¡¼“«É“ªÈ“Ôõ’²Á“ªÇ“ª¹:

    unshift(@ARGV, '-') unless @ARGV;
    while ($ARGV = shift) {
	open(ARGV, $ARGV);
	while (<ARGV>) {
	    ...		# code for each line
	}
    }

=begin original

except that it isn't so cumbersome to say, and will actually work.
It really does shift the @ARGV array and put the current filename
into the $ARGV variable.  It also uses filehandle I<ARGV>
internally--<> is just a synonym for <ARGV>, which
is magical.  (The pseudo code above doesn't work because it treats
<ARGV> as non-magical.)

=end original

“Ó£“ª·“¡¢“ªï“ªº“ªé“ªï“ª·“ª¯“ßö“ª«“ªÊ“ª¯“ªÆ“ªâ“¡¢“ÔÑ“íÂ“ª·“ªÞ“ª¹“¡£
’¼Â“ð·“ªË @ARGV “ªò shift “ª·“ªÞ“ª¹“ª·“¡¢“ª½“ªÎ“ãÁ“ïÃ“ªÎ“«Õ“«¡“«¤“«ë“Ù£“ªò’ÊÑ‘Êý $ARGV “ªË
“ìý“ªì“ªÆ“ª¤“ªÞ“ª¹“¡£
“ªÞ“ª¿“¡¢‘ÄÚ“Ý»“îÜ“ªË“«Õ“«¡“«¤“«ë“«Ï“«ó“«É“«ë ARGV “ªò“ÞÅ“ªÃ“ªÆ“ª¤“ªÆ“¡¢<> “ªÏ“«Þ“«¸“««“«ë“ªÊ
<ARGV> “ªÎ“ÔÒ“ëù“åÞ“ªÈ“ªÊ“ªÃ“ªÆ“ª¤“ªÞ“ª¹“¡£
(“ß¾“ÑÀ“ªÎ“ëô“ÞÄ“«³’¡¼“«É“ªÏ“¡¢<ARGV> “ªò“÷×“ßÈ“ªÎ“ªâ“ªÎ“ªÈ“ª·“ªÆ“Ðâ“ªÃ“ªÆ“ª¤“ªë“ªÎ“ªÇ“¡¢
“ª¦“ªÞ“ª¯“ÔÑ“íÂ“ª·“ªÞ“ª»“ªó“¡£)

=begin original

You can modify @ARGV before the first <> as long as the array ends up
containing the list of filenames you really want.  Line numbers (C<$.>)
continue as though the input were one big happy file.  See the example
in L<perlfunc/eof> for how to reset line numbers on each file.

=end original

“õÌ“ðû“îÜ“ªË“¡¢@ARGV “ªË“Ðâ“ª¤“ª¿“ª¤“ªÈ“ÞÖ“ªÃ“ªÆ“ª¤“ªë“«Õ“«¡“«¤“«ë“Ù£“ª¬“ùß“ªÞ“ªì“ªë“ªÎ“ªÇ“ª¢“ªì“ªÐ“¡¢
“õÌ“ôø“ªË <> “ªò“øÄ’²Á“ª¹“ªë“îñ“ªË @ARGV “ªò’ÊÑ“ÌÚ“ª¹“ªë“ª³“ªÈ“ªâ“Ê¦“Òö“ªÇ“ª¹“¡£
“ú¼“Ûã‘ºÅ (C<$.>) “ªÏ“¡¢“ìý“Õô“«Õ“«¡“«¤“«ë“ª¬“ª¢“ª¿“ª«“ªâ 1 “ªÄ“ªÎ“ÓÞ“ª­“ªÊ“«Õ“«¡“«¤“«ë“ªÇ
“ª¢“ªë“ª«“ªÎ“ªè“ª¦“ªË“¡¢’Â³“ª±“ªÆ“««“«¦“«ó“«È“ªµ“ªì“ªÞ“ª¹“¡£
“ËÁ‘¡©“ªÎ“«Õ“«¡“«¤“«ë“ª´“ªÈ“ªË“«ê“«»“«Ã“«È“ª¹“ªë“Û°“Ûö“ªÏ“¡¢L<perlfunc/eof> “ªÎ“ÖÇ“ªò
‘²Î“ðÎ“ª·“ªÆ“ª¯“ªÀ“ªµ“ª¤“¡£

=begin original

If you want to set @ARGV to your own list of files, go right ahead.
This sets @ARGV to all plain text files if no @ARGV was given:

=end original

“õÌ“ôø“ª«“ªé @ARGV “ªË“í»“ÝÂ“ªÇ“«Õ“«¡“«¤“«ë“ªÎ“«ê“«¹“«È“ªò“àâ“ïÒ“ª·“ªÆ“ªâ“ª«“ªÞ“ª¤“ªÞ“ª»“ªó“¡£
“ì¤“ù»“ªÏ @ARGV “ª¬‘Óë“ª¨“ªé“ªì“ªÊ“ª«“ªÃ“ª¿“ªÈ“ª­“ªË“îï“ªÆ“ªÎ“«Æ“«­“«¹“«È“«Õ“«¡“«¤“«ë“ªò
@ARGV “ªË“àâ“ïÒ“ª·“ªÞ“ª¹“¡£

    @ARGV = grep { -f && -T } glob('*') unless @ARGV;

=begin original

You can even set them to pipe commands.  For example, this automatically
filters compressed arguments through B<gzip>:

=end original

“ª³“ª³“ªË“«Ñ“«¤“«×“«³“«Þ“«ó“«É“ªò“öÇ“ª¯“ª³“ªÈ“ªâ“õó‘À´“ªÞ“ª¹“¡£
“ÖÇ“ª¨“ªÐ“¡¢“ì¤“ù»“ªÏ’°µ“õê“ªµ“ªì“ª¿“ìÚ‘Êý“ªò“í»“ÔÑ“îÜ“ªË B<gzip> “ªÎ“«Õ“«£“«ë“«¿“ªË“÷×“ª·“ªÞ“ª¹:

    @ARGV = map { /\.(gz|Z)$/ ? "gzip -dc < $_ |" : $_ } @ARGV;

=begin original

If you want to pass switches into your script, you can use one of the
Getopts modules or put a loop on the front like this:

=end original

“«¹“«¯“«ê“«×“«È“ªË“«¹“«¤“«Ã“«Á“ªò“Ô¤“ª·“ª¿“ª¤“ªÎ“ªÇ“ª¢“ªì“ªÐ“¡¢Getopts “«â“«¸“«å’¡¼“«ë“ªò
“ÞÅ“ª¦“ª³“ªÈ“ªâ“ªÇ“ª­“ªÞ“ª¹“ª·“¡¢’¼Â“ð·“ªÎ’½è“×â“ªÎ“îñ“ªË“ªÎ“ªè“ª¦“ªÊ“«ë’¡¼“«×“ªò“öÇ“ª¯“ª³“ªÈ“ªâ“ªÇ“ª­“ªÞ“ª¹“¡£

    while ($_ = $ARGV[0], /^-/) {
	shift;
        last if /^--$/;
	if (/^-D(.*)/) { $debug = $1 }
	if (/^-v/)     { $verbose++  }
	# ...		# other switches
    }

    while (<>) {
	# ...		# code for each line
    }

=begin original

The <> symbol will return C<undef> for end-of-file only once.
If you call it again after this, it will assume you are processing another
@ARGV list, and if you haven't set @ARGV, will read input from STDIN.

=end original

“«·“«ó“«Ü“«ë <> “ª¬“«Õ“«¡“«¤“«ë“ªÎ“õÌ“ý­“ªÇ C<undef> “ªò“Ú÷“ª¹“ªÎ“ªÏ“ìé“Óø“ª­“ªê“ªÇ“ª¹“¡£
“ª½“ªÎ“ª¢“ªÈ“ªÇ“ªâ“ª¦“ìé“Óø“û¼“ªÓ“õó“ª¹“ªÈ“¡¢“ãæ“ª¿“ªË“Ü¬“ªÎ @ARGV “ªò’½è“×â“ª¹“ªë“ªâ“ªÎ“ªÈ“ªß“ªÊ“ªµ“ªì“¡¢
“ª½“ªÎ“ãÁ“ªË @ARGV “ªò“àâ“ïÒ“ª·“ªÊ“ªª“ª·“ªÆ“ª¤“ªÊ“ª¤“ªÈ“¡¢STDIN “ª«“ªé“ªÎ“ìý“Õô“ªò
’ÆÉ“ªß’¹þ“ªà“ª³“ªÈ“ªË“ªÊ“ªê“ªÞ“ª¹“¡£

=begin original

If what the angle brackets contain is a simple scalar variable (e.g.,
<$foo>), then that variable contains the name of the
filehandle to input from, or its typeglob, or a reference to the
same.  For example:

=end original

“ß£“ÎÀ“ûÁ“ªÎ“ñé“ªÎ“Ùþ“í®“Öª“ª¬ (<$foo> “ªÎ“ªè“ª¦“ªÊ) ’Ã±“âí“«¹“««“«é’ÊÑ‘Êý“ªÇ“ª¢“ªì“ªÐ“¡¢
“ª½“ªÎ’ÊÑ‘Êý“ª¬“ìý“Õô“ªò“ú¼“ªÊ“ª¦“«Õ“«¡“«¤“«ë“«Ï“«ó“«É“«ë“ªÎ“Ù£“îñ“ª½“ªÎ“ªâ“ªÎ“¡¢“Ù£“îñ“ªØ“ªÎ“úþ“«°“«í“«Ö“¡¢
“Ù£“îñ“ªØ“ªÎ“«ê“«Õ“«¡“«ì“«ó“«¹“ªÎ“ª¤“ªº“ªì“ª«“ªò“ãÆ“ª·“ªÆ“ª¤“ªë“ªÈ“ªß“ªÊ“ªµ“ªì“ªÞ“ª¹“¡£

    $fh = \*STDIN;
    $line = <$fh>;

=begin original

If what's within the angle brackets is neither a filehandle nor a simple
scalar variable containing a filehandle name, typeglob, or typeglob
reference, it is interpreted as a filename pattern to be globbed, and
either a list of filenames or the next filename in the list is returned,
depending on context.  This distinction is determined on syntactic
grounds alone.  That means C<< <$x> >> is always a readline() from
an indirect handle, but C<< <$hash{key}> >> is always a glob().
That's because $x is a simple scalar variable, but C<$hash{key}> is
not--it's a hash element.  Even C<< <$x > >> (note the extra space)
is treated as C<glob("$x ")>, not C<readline($x)>.

=end original

“ß£“ÎÀ“ûÁ“ªÎ“ñé“ªÎ“Ùþ“í®“Öª“ª¬“«Õ“«¡“«¤“«ë“«Ï“«ó“«É“«ë“ªÇ“ªâ“«Õ“«¡“«¤“«ë“«Ï“«ó“«É“«ë“Ù£“¡¢“úþ“«°“«í“«Ö“¡¢
“úþ“«°“«í“«Ö“«ê“«Õ“«¡“«ì“«ó“«¹“ªÎ“ª¤“ªº“ªì“ª«“ª¬“ìý“ªÃ“ª¿’Ã±“âí“«¹“««“«é’ÊÑ‘Êý“ªÇ“ªâ“ªÊ“ª±“ªì“ªÐ“¡¢
“«°“«í“«Ö“ªò“ú¼“ªÊ“ª¦“«Õ“«¡“«¤“«ë“Ù£“ªÎ“«Ñ“«¿’¡¼“«ó“ªÈ“ú°’¼á“ªµ“ªì“¡¢“«³“«ó“«Æ“«­“«¹“«È“ªË“ªè“ªÃ“ªÆ
“«Õ“«¡“«¤“«ë“Ù£“ªÎ“«ê“«¹“«È“ª«“¡¢“ª½“ªÎ“«ê“«¹“«È“ªÎ“ó­“ªÎ“«Õ“«¡“«¤“«ë“Ù£“ª¬“Ú÷“ªµ“ªì“ªÞ“ª¹“¡£
“ª³“ªÎ‘Çø“Ü¬“ªÏ’Ã±“ªË“Ï°“Ùþ“îÜ“ªË“ú¼“ªï“ªì“ªÞ“ª¹“¡£
C<< <$x> >> “ªÏ“ßÈ“ªË“Êà“ïÈ“«Ï“«ó“«É“«ë“ª«“ªé readline() “ª·“ªÞ“ª¹“ª¬“¡¢
C<< <$hash{key}> >> “ªÏ“ßÈ“ªË glob() “ª·“ªÞ“ª¹“¡£
$x “ªÏ’Ã±“âí“«¹“««“«é’¡¼’ÊÑ‘Êý“ªÇ“ª¹“ª¬“¡¢C<$hash{key}> “ªÏ“êÞ“ª¦(“«Ï“«Ã“«·“«å“é©“áÈ)“ª«“ªé“ªÇ“ª¹“¡£
C<< <$x > >> (“åù“ÝÂ“ªÊ“Íö“ÛÜ“ªË“ñ¼“ëò) “ªÇ“ª¹“ªé C<readline($x)> “ªÇ“ªÏ“ªÊ“ª¯
C<glob("$x ")> “ªÈ“ª·“ªÆ“Ðâ“ªï“ªì“ªÞ“ª¹“¡£

=begin original

One level of double-quote interpretation is done first, but you can't
say C<< <$foo> >> because that's an indirect filehandle as explained
in the previous paragraph.  (In older versions of Perl, programmers
would insert curly brackets to force interpretation as a filename glob:
C<< <${foo}> >>.  These days, it's considered cleaner to call the
internal function directly as C<glob($foo)>, which is probably the right
way to have done it in the first place.)  For example:

=end original

“ªÞ“ªº“¡¢1 “Ó«“Í­“ªÀ“ª±“«À“«Ö“«ë“«¯“«©’¡¼“«È“î÷“ËÒ“ª¬“ú¼“ªÊ“ªï“ªì“ªÞ“ª¹“ª¬“¡¢“îñ“ªÎ“Ó«“Õª“ªË“ßö“ª¤“ª¿
“Êà“ïÈ“«Õ“«¡“«¤“«ë“«Ï“«ó“«É“«ë“ªÈ“ÔÒ“ª¸“ªË“ªÊ“ªë“¡¢C<< <$foo> >> “ªÎ“ªè“ª¦“ªË“ªÏ“ßö“ª±“ªÞ“ª»“ªó“¡£
(Perl “ªÎ“Í¯“ª¤“«Ð’¡¼“«¸“«ç“«ó“ªÇ“ªÏ“¡¢“«Õ“«¡“«¤“«ë“Ù£“«°“«í“«Ö“ªÈ“ú°’¼á“ªµ“ª»“ªë“ª¿“ªá“ªË
C<< <${foo}> >> “ªÎ“ªè“ª¦“ªË“ñé“ÎÀ“ûÁ“ªò“ìý“ªì“ªÆ“ª¤“ªÞ“ª·“ª¿“¡£
“õÌ“ÐÎ“ªÇ“ªÏ“ªè“ªê“Ù¥“ü¬“ªË“ª¹“ªë“ª¿“ªá“ªË“¡¢C<glob($foo)> “ªÈ‘ÄÚ“Ý»’´Ø‘Êý“ªò
“û¼“ªÖ“ª³“ªÈ“ªâ“ªÇ“ª­“ªÞ“ª¹“¡£
“ªª“ª½“ªé“ª¯“¡¢“ªÞ“ªº“¡¢“ª³“ªÁ“ªé“ªÎ“Û°“ªÇ“ãË“ª¹“ªÎ“ª¬“ïá“ú°“ªÇ“ª·“ªç“ª¦“¡£)
“ÖÇ:

    while (<*.c>) {
	chmod 0644, $_;
    }

=begin original

is roughly equivalent to:

=end original

“ªÏ“ªÀ“ª¤“ª¿“ª¤“ì¤“ù»“ªÈ“Ôõ’²Á“ªÇ“ª¹:

    open(FOO, "echo *.c | tr -s ' \t\r\f' '\\012\\012\\012\\012'|");
    while (<FOO>) {
	chomp;
	chmod 0644, $_;
    }

=begin original

except that the globbing is actually done internally using the standard
C<File::Glob> extension.  Of course, the shortest way to do the above is:

=end original

“Ó£“ª·’¼Â“ð·“ªÎ“«°“«í“«Ö“ªÏ‘ÄÚ“Ý»“îÜ“ªË“øö“ñÞ“ªÎ C<File::Glob> “«â“«¸“«å’¡¼“«ë“ªò“ÞÅ“ª¤“ªÞ“ª¹“¡£
“ªâ“ªÁ“ªí“ªó“¡¢“ªâ“ªÃ“ªÈ“ÊÛ’Ã±“ªË“ì¤“ù»“ªÎ“ªè“ª¦“ªË“ßö“ª±“ªÞ“ª¹:

    chmod 0644, <*.c>;

=begin original

A (file)glob evaluates its (embedded) argument only when it is
starting a new list.  All values must be read before it will start
over.  In list context, this isn't important because you automatically
get them all anyway.  However, in scalar context the operator returns
the next value each time it's called, or C<undef> when the list has
run out.  As with filehandle reads, an automatic C<defined> is
generated when the glob occurs in the test part of a C<while>,
because legal glob returns (e.g. a file called F<0>) would otherwise
terminate the loop.  Again, C<undef> is returned only once.  So if
you're expecting a single value from a glob, it is much better to
say

=end original

(“«Õ“«¡“«¤“«ë)“«°“«í“«Ö“ªÏ“ãæ“ª·“ª¤“«ê“«¹“«È“ªò“ËÒ“ã·“ª¹“ªë“ªÈ“ª­“ªË“ªÀ“ª±(“ðÚ“ªß’¹þ“ªß“ªÎ)“ìÚ‘Êý“ªò
“øÄ’²Á“ª·“ªÞ“ª¹“¡£
“îï“ªÆ“ªÎ“ö·“ªÏ“ËÒ“ã·“ª¹“ªë“îñ“ªË’ÆÉ“ªß’¹þ“ªó“ªÇ“ª¤“ªÊ“ª±“ªì“ªÐ“ªÊ“ªê“ªÞ“ª»“ªó“¡£
“ª³“ªì“ªÏ“«ê“«¹“«È“«³“«ó“«Æ“«­“«¹“«È“ªÇ“ªÏ“¡¢“ªÈ“ªË“ª«“ª¯“í»“ÔÑ“îÜ“ªË“îï“ªÆ“ªò“ö¢“ªê’¹þ“ªà“ªÎ“ªÇ
“ñì“é©“ªÇ“ªÏ“ª¢“ªê“ªÞ“ª»“ªó“¡£
“ª·“ª«“ª·“¡¢“«¹“««“«é’¡¼“«³“«ó“«Æ“«­“«¹“«È“ªÇ“ªÏ“ª³“ªÎ“æÑ“ß©“í­“ªÏ“û¼“ªÓ“õó“ªµ“ªì“ª¿“ãÁ“ªÎ
“ó­“ªÎ“ö·“ª«“¡¢“«ê“«¹“«È“ª¬“ªÊ“ª¯“ªÊ“ªÃ“ª¿“ªÈ“ª­“ªË“ªÏ C<undef> “ªò“Ú÷“ª·“ªÞ“ª¹“¡£
“«Õ“«¡“«¤“«ë“«Ï“«ó“«É“«ë“ªò’ÆÉ“ªß’¹þ“ªà“íÞ“ùê“ªÏ“¡¢“«°“«í“«Ö“ª¬ C<while> “ªÎ‘Ìõ“Ëì“Ý»“ªË“ª¢“ªë“íÞ“ùê“ªÏ
“í»“ÔÑ“îÜ“ªÊ C<defined> “ª¬“ßæ“à÷“ªµ“ªì“ªÞ“ª¹“¡£
“ªÊ“ª¼“ªÊ“ªé“ª½“ª¦“ª·“ªÊ“ª¤“ªÈ“¡¢“Üâ‘À´“ªÎ glob “ªÎ“Ú÷“ªê“ö· (F<0> “ªÈ“ª¤“ª¦“«Õ“«¡“«¤“«ë) “ª¬
“«ë’¡¼“«×“ªò“ðû“Öõ“ªµ“ª»“ªë“ª«“ªé“ªÇ“ª¹“¡£
“ª³“ª³“ªÇ“ªâ“¡¢C<undef> “ªÏ“ìé“Óø“ªÀ“ª±“Ú÷“ªµ“ªì“ªÞ“ª¹“¡£
’½¾“ªÃ“ªÆ“¡¢“ªâ“ª·“«°“«í“«Ö“ª«“ªé“ìé“ªÄ“ªÎ“ö·“ªÀ“ª±“ªò“ßÌ“ïÒ“ª·“ªÆ“ª¤“ªë“íÞ“ùê“¡¢
“ì¤“ù»“ªÎ“ªè“ª¦“ªË“ßö“ª¯“ª³“ªÈ“ª¬:

    ($file) = <blurch*>;

=begin original

than

=end original

“ì¤“ù»“ªÎ“ªè“ª¦“ªË“ßö“ª¯“ªè“ªê“ªÏ“ªë“ª«“ªË“ÕÞ“ª¤“ªÇ“ª¹:

    $file = <blurch*>;

=begin original

because the latter will alternate between returning a filename and
returning false.

=end original

“ªÊ“ª¼“ªÊ“ªé“ý­“íº“ªÏ“«Õ“«¡“«¤“«ë“Ù£“ªò“Ú÷“ª¹“íÞ“ùê“ªÈ˜ºô“ªò“Ú÷“ª¹“íÞ“ùê“ª¬“ª¢“ªë“ª«“ªé“ªÇ“ª¹“¡£

=begin original

If you're trying to do variable interpolation, it's definitely better
to use the glob() function, because the older notation can cause people
to become confused with the indirect filehandle notation.

=end original

’ÊÑ‘Êý’ÊÑ“üµ“ªË“Óû’Àï“ª¹“ªë“íÞ“ùê“¡¢“Ù¥“ªé“ª«“ªË glob() ’´Ø‘Êý“ªò“ÞÅ“ª¦“Û°“ª¬“ÕÞ“ª¤“ªÇ“ª¹“¡£
“ªÊ“ª¼“ªÊ“ªé“Í¯“ª¤“øú“ÑÀ“ªÏ“Êà“ïÈ“«Õ“«¡“«¤“«ë“«Ï“«ó“«É“«ë“øú“ÑÀ“ªÈ“ûè‘ÂÒ“ª¹“ªë“ª«“ªâ“ò±“ªì“ªÊ“ª¤“ª«“ªé“ªÇ“ª¹“¡£

    @files = glob("$dir/*.[ch]");
    @files = glob($files[$i]);

=head2 Constant Folding
X<constant folding> X<folding>

(“ïÒ‘Êý“ªÎ’¾ö“ªß’¹þ“ªß)

=begin original

Like C, Perl does a certain amount of expression evaluation at
compile time whenever it determines that all arguments to an
operator are static and have no side effects.  In particular, string
concatenation happens at compile time between literals that don't do
variable substitution.  Backslash interpolation also happens at
compile time.  You can say

=end original

C “ªÈ“ÔÒ“ª¸“ªè“ª¦“ªË Perl “ªÇ“ªâ“¡¢“æÑ“ß©“í­“ªË’ÂÐ“ª¹“ªë“ª¹“ªÙ“ªÆ“ªÎ“ìÚ‘Êý“ª¬“«¹“«¿“«Æ“«£“«Ã“«¯“ªÇ“¡¢
“Üù“íÂ“éÄ“ª¬“ªÊ“ª¤“ªÈ“÷÷‘¶Ï“ªÇ“ª­“ªì“ªÐ“¡¢“«³“«ó“«Ñ“«¤“«ë“ãÁ“ªË“ãÒ“ªÎ“øÄ’²Á“ªò“ú¼“ªÊ“ªÃ“ªÆ“ª·“ªÞ“ª¤“ªÞ“ª¹“¡£
“÷å“ªË“¡¢’ÊÑ‘Êý“öÇ“üµ“ªÎ“Ùí“ª¤“«ê“«Æ“«é“«ë“ªÉ“ª¦“ª·“ªÎ“Ùþ“í®“Öª“Ö§“Ì¿“ªÏ“«³“«ó“«Ñ“«¤“«ë“ãÁ“ªË“ú¼“ªÊ“ªï“ªì“ªÞ“ª¹“¡£
“«Ð“«Ã“«¯“«¹“«é“«Ã“«·“«å“ªÎ“ú°’¼á“ªâ“«³“«ó“«Ñ“«¤“«ë“ãÁ“ªË“ú¼“ªÊ“ªï“ªì“ªÞ“ª¹“¡£

    'Now is the time for all' . "\n" .
	'good men to come to.'

=begin original

and this all reduces to one string internally.  Likewise, if
you say

=end original

“ªÈ“ßö“ª¤“ªÆ“ªâ“¡¢‘ÄÚ“Ý»“îÜ“ªË 1 “ªÄ“ªÎ“Ùþ“í®“Öª“ªË“ªÊ“ªê“ªÞ“ª¹“¡£“ÔÒ’ÍÍ“ªË

    foreach $file (@filenames) {
	if (-s $file > 5 + 100 * 2**16) {  }
    }

=begin original

the compiler will precompute the number which that expression
represents so that the interpreter won't have to.

=end original

“ªÈ“ßö“ª¯“ªÈ“«³“«ó“«Ñ“«¤“«é“ªÏ“¡¢“ãÒ“ª¬“øú“ªï“ª¹‘Êý“ö·“ªò“ª¢“ªé“ª«“ª¸“ªá“Íª“ß©“ª·“ªÞ“ª¹“ªÎ“ªÇ“¡¢
“«¤“«ó“«¿“«×“«ê“«¿“ªÇ“Íª“ß©“ª¹“ªë“ù±“é©“ª¬“ªÊ“ª¯“ªÊ“ªÃ“ªÆ“ª¤“ªÞ“ª¹“¡£

=head2 No-ops
X<no-op> X<nop>

(“Ùí’¼Â“ú¼)

=begin original

Perl doesn't officially have a no-op operator, but the bare constants
C<0> and C<1> are special-cased to not produce a warning in a void
context, so you can for example safely do

=end original

Perl “ªÏ“Íë“ãÒ“ªË“ªÏ“Ùí’¼Â“ú¼“æÑ“ß©“í­“ªÏ“ª¢“ªê“ªÞ“ª»“ªó“ª¬“¡¢“Õ£“ªÎ“ïÒ‘Êý C<0> “ªÈ C<1> “ªÏ
“÷å“Ü¬“ªË“Ùí’¸ú“«³“«ó“«Æ“«­“«¹“«È“ªÇ“ªâ“Ìí“Í±“ªò“õó“ªµ“ªÊ“ª¤“ª³“ªÈ“ªË“ªÊ“ªÃ“ªÆ“ª¤“ªë“ªÎ“ªÇ“¡¢
“ÖÇ“ª¨“ªÐ“äÌ“îï“ªË“ì¤“ù»“ªÎ“ªè“ª¦“ªË“ßö“ª±“ªÞ“ª¹:

    1 while foo();

=head2 Bitwise String Operators
X<operator, bitwise, string>

(“«Ó“«Ã“«È“Öª“æÑ“ß©“í­)

=begin original

Bitstrings of any size may be manipulated by the bitwise operators
(C<~ | & ^>).

=end original

“ìò“ëò“ªÎ“«µ“«¤“«º“ªÎ“«Ó“«Ã“«È“Öª“ªÏ“«Ó“«Ã“«È’Ã±“êÈ“æÑ“ß©“í­(C<~ | & ^>)“ªÇ“ðÃ“íÂ“ªÇ“ª­“ªÞ“ª¹“¡£

=begin original

If the operands to a binary bitwise op are strings of different
sizes, B<|> and B<^> ops act as though the shorter operand had
additional zero bits on the right, while the B<&> op acts as though
the longer operand were truncated to the length of the shorter.
The granularity for such extension or truncation is one or more
bytes.

=end original

“ì£“ú£“«Ó“«Ã“«È’Ã±“êÈ“æÑ“ß©“í­“ªÎ“«ª“«Ú“«é“«ó“«É“ª¬“ì¶“ªÊ“ªÃ“ª¿“íþ“ªµ“ªÎ“Ùþ“í®“Öª“ªÀ“ªÃ“ª¿“íÞ“ùê“¡¢
B<|> “ªÈ B<^> “ªÎ“æÑ“ß©“í­“ªÏ“Ó­“ª¤“ö°“ªÎ“«ª“«Ú“«é“«ó“«É“ªÎ“éÓ“ö°“ªË“õÚ“Ê¥“ªÎ“«¼“«í“ª¬
“ªÄ“ª¤“ªÆ“ª¤“ªë“ªÈ“ªß“ªÊ“ª·“ªÞ“ª¹“¡£
“ìé“Û° B<&> “æÑ“ß©“í­“ªÏ“íþ“ª¤“Û°“ªÎ“«ª“«Ú“«é“«ó“«É“ª¬“Ó­“ª¤“Û°“ªË“ï·“ªê“ýþ“ªá“ªé“ªì“ªÞ“ª¹“¡£
“ª³“ªÎ’³È“íå“ªä“Ó­“õê“ªÎ“Ø£“Óø“ªÏ“«Ð“«¤“«È’Ã±“êÈ“ªÇ“ª¹“¡£

    # ASCII-based examples
    print "j p \n" ^ " a h";        	# prints "JAPH\n"
    print "JA" | "  ph\n";          	# prints "japh\n"
    print "japh\nJunk" & '_____';   	# prints "JAPH\n";
    print 'p N$' ^ " E<H\n";		# prints "Perl\n";

=begin original

If you are intending to manipulate bitstrings, be certain that
you're supplying bitstrings: If an operand is a number, that will imply
a B<numeric> bitwise operation.  You may explicitly show which type of
operation you intend by using C<""> or C<0+>, as in the examples below.

=end original

“«Ó“«Ã“«È“Öª“ªò“ðÃ“íÂ“ª·“ª¿“ª¤“íÞ“ùê“ªÏ“¡¢“ü¬’¼Â“ªË“«Ó“«Ã“«È“Öª“ª¬“Ô¤“ªµ“ªì“ªë“ªè“ª¦“ªË“ª·“ªÆ“ª¯“ªÀ“ªµ“ª¤:
“«ª“«Ú“«é“«ó“«É“ª¬‘Êý“í®“ªÎ“íÞ“ùê“¡¢B<‘Êý“ö·> “«Ó“«Ã“«È’Ã±“êÈ“æÑ“ß©“ªò’²¾“ïÒ“ª·“ªÞ“ª¹“¡£
“Ù¥“ãÆ“îÜ“ªË“æÑ“ß©“ªÎ“úþ“ªò“ò¦“ïÒ“ª¹“ªë“ªÈ“ª­“ªË“ªÏ“¡¢“ì¤“ù»“ªÎ“ÖÇ“ªÎ“ªè“ª¦“ªË
C<""> “ª« C<0+> “ªò“ÞÅ“ªÃ“ªÆ“ª¯“ªÀ“ªµ“ª¤“¡£

    $foo =  150  |  105;	# yields 255  (0x96 | 0x69 is 0xFF)
    $foo = '150' |  105;	# yields 255
    $foo =  150  | '105';	# yields 255
    $foo = '150' | '105';	# yields string '155' (under ASCII)

    $baz = 0+$foo & 0+$bar;	# both ops explicitly numeric
    $biz = "$foo" ^ "$bar";	# both ops explicitly stringy

=begin original

See L<perlfunc/vec> for information on how to manipulate individual bits
in a bit vector.

=end original

“«Ó“«Ã“«È“«Ù“«¯“«¿“ªÎ“ËÁ‘¡©“ªÎ“«Ó“«Ã“«È“ªò“ªÉ“ªÎ“ªè“ª¦“ªË“ðÃ“íÂ“ª¹“ªë“ª«“ªÎ“ï×“ÜÃ“ªË“ªÄ“ª¤“ªÆ“ªÏ
L<perlfunc/vec> “ªò‘²Î“ðÎ“ª·“ªÆ“ù»“ªµ“ª¤“¡£

=head2 Integer Arithmetic
X<integer>

(“ïÚ‘Êý“æÑ“ß©)

=begin original

By default, Perl assumes that it must do most of its arithmetic in
floating point.  But by saying

=end original

“«Ç“«Õ“«©“«ë“«È“ªÇ“ªÏ“¡¢Perl “ªÏ“æÑ“ß©“ªò“Ý©“ÔÑ“á³‘Êý“ªÇ“ú¼“ªÊ“ªï“ªÊ“ª±“ªì“ªÐ“ªÊ“ªé“ªÊ“ª¤“ªâ“ªÎ“ªÈ
“ª·“ªÆ“ª¤“ªÞ“ª¹“¡£
“ª·“ª«“ª·“¡¢(“ªâ“ª·“ª½“ª¦“ª·“ª¿“ª¤“ªÊ“ªé)

    use integer;

=begin original

you may tell the compiler that it's okay to use integer operations
(if it feels like it) from here to the end of the enclosing BLOCK.
An inner BLOCK may countermand this by saying

=end original

“ªÈ“ßö“ª±“ªÐ“¡¢“ª½“ªÎ“íÞ“á¶“ª«“ªé“úÞ“î¤“ªÎ BLOCK “ªÎ“ðû“ªï“ªê“ªÞ“ªÇ“ªÏ“¡¢“ïÚ‘Êý“æÑ“ß©“ªò
“ú¼“ªÊ“ªÃ“ªÆ“ªè“ª¤“ªÈ“¡¢“«³“«ó“«Ñ“«¤“«é“ªË“ò¦“ãÆ“ª¹“ªë“ª³“ªÈ“ª¬“ªÇ“ª­“ªÞ“ª¹“¡£
‘ÄÚ“Ý»“ªÎ BLOCK “ªÇ“¡¢

    no integer;

=begin original

which lasts until the end of that BLOCK.  Note that this doesn't
mean everything is only an integer, merely that Perl may use integer
operations if it is so inclined.  For example, even under C<use
integer>, if you take the C<sqrt(2)>, you'll still get C<1.4142135623731>
or so.

=end original

“ªÈ“ßö“ª±“ªÐ“¡¢“ª½“ªÎ BLOCK “ªÎ“ðû“ªï“ªê“ªÞ“ªÇ“ªÏ“¡¢“ò¦“ãÆ“ªò“ö¢“ªê“á¼“ª¹“ª³“ªÈ“ªË“ªÊ“ªê“ªÞ“ª¹“¡£
“ª³“ªì“ªÏ“îï“ªÆ“ªò“ïÚ‘Êý“ªÀ“ª±“ªò“ÞÅ“ªÃ“ªÆ’½è“×â“ª¹“ªë“ª³“ªÈ“ªò“ëò“Ú«“ª¹“ªë“ªï“ª±“ªÇ“ªÏ“ªÊ“ª¤“ª³“ªÈ“ªË
“ñ¼“ëò“ª·“ªÆ“ª¯“ªÀ“ªµ“ª¤“¡£
“ª³“ªì“ªÏ’Ã±“ªË Perl “ª¬“ïÚ‘Êý“ªò“ÞÅ“ª¤“ª¿“ª¤“ªÈ“ÞÖ“ªÃ“ª¿“ªÈ“ª­“ªË“ÞÅ“ª¦“ª«“ªâ“ª·“ªì“ªÊ“ª¤“¡¢
“ªÈ“ª¤“ª¦“ªÀ“ª±“ªÇ“ª¹“¡£
“ÖÇ“ª¨“ªÐ“¡¢C<use integer> “ªÎ“ò¦“ïÒ“ª¬“ª¢“ªÃ“ªÆ“ªâ“¡¢C<sqrt(2)> “ªÈ“ª¹“ªë“ªÈ“¡¢
C<1.4142135623731> “ªÈ“ª¤“ªÃ“ª¿“Ì¿“Íý“ª¬“Ú÷“ªÃ“ªÆ“ª­“ªÞ“ª¹“¡£

=begin original

Used on numbers, the bitwise operators ("&", "|", "^", "~", "<<",
and ">>") always produce integral results.  (But see also
L<Bitwise String Operators>.)  However, C<use integer> still has meaning for
them.  By default, their results are interpreted as unsigned integers, but
if C<use integer> is in effect, their results are interpreted
as signed integers.  For example, C<~0> usually evaluates to a large
integral value.  However, C<use integer; ~0> is C<-1> on two's-complement
machines.

=end original

‘Êý“ö·“ªò“ÞÅ“ª¦“íÞ“ùê“¡¢“«Ó“«Ã“«È’Ã±“êÈ“æÑ“ß©“í­ ("&", "|", "^", "~", "<<", ">>") “ªÏ
“ßÈ“ªË“ïÚ‘Êý“ªÎ“Ì¿“Íý“ªò“ßæ“à÷“ª·“ªÞ“ª¹(“Ó£“ª· L<Bitwise String Operators> “ªâ
‘²Î“ðÎ“ª·“ªÆ“ù»“ªµ“ª¤)“¡£
“ª·“ª«“ª·“¡¢“ª½“ªì“ªÇ“ªâ C<use integer> “ªÏ“ëò“Ú«“ª¬“ª¢“ªê“ªÞ“ª¹“¡£
“«Ç“«Õ“«©“«ë“«È“ªÇ“ªÏ“¡¢“ª³“ªì“ªé“ªÎ“Ì¿“Íý“ªÏ“Ý¬‘ºÅ“ªÊ“ª·“ïÚ‘Êý“ªÈ“ª·“ªÆ“ú°’¼á“ªµ“ªì“ªÞ“ª¹“ª¬“¡¢
C<use integer> “ª¬“êó’¸ú“ªÎ“íÞ“ùê“ªÏ“¡¢“Ý¬‘ºÅ“Üõ“ª­“ïÚ‘Êý“ªÈ“ª·“ªÆ“ú°’¼á“ªµ“ªì“ªÞ“ª¹“¡£
“ÖÇ“ª¨“ªÐ“¡¢C<~0> “ªÏ“÷×“ßÈ“ÓÞ“ª­“ªÊ“ïÚ‘Êý“ªÎ“ö·“ªÈ“ª·“ªÆ“øÄ’²Á“ªµ“ªì“ªÞ“ª¹“¡£
“ª·“ª«“ª·“¡¢C<use integer; ~0> “ªÏ 2 “ªÎ“ÜÍ‘Êý“ªÎ“«Þ“«·“«ó“ªÇ“ªÏ C<-1> “ªË“ªÊ“ªê“ªÞ“ª¹“¡£

=head2 Floating-point Arithmetic
X<floating-point> X<floating point> X<float> X<real>

(“Ý©“ÔÑ“á³‘Êý“ïÃ“æÑ“ß©)

=begin original

While C<use integer> provides integer-only arithmetic, there is no
analogous mechanism to provide automatic rounding or truncation to a
certain number of decimal places.  For rounding to a certain number
of digits, sprintf() or printf() is usually the easiest route.
See L<perlfaq4>.

=end original

C<use integer> “ª¬“ïÚ‘Êý“æÑ“ß©“ªò“ð«“Íê“ª¹“ªë“ìé“Û°“¡¢‘Êý“ªò“÷å“ïÒ“ªÎ“ùù“ªÇ“í»“ÔÑ“îÜ“ªË“ü¯“ªá“ª¿“ªê
“ï·“ªê“Þ×“ªÆ“ª¿“ªê“ª¹“ªë“Ñ¦“Ï°“ªÏ“ª¢“ªê“ªÞ“ª»“ªó“¡£
‘Êý“ªò“ü¯“ªá“ªë“ªË“ªÏ“¡¢sprintf() “ªä printf() “ªò“ÞÅ“ª¦“ªÎ“ª¬“ìé“Ûã“ÊÛ’Ã±“ªÊ“Û°“Ûö“ªÇ“ª¹“¡£
L<perlfaq4> “ªò‘²Î“ðÎ“ª·“ªÆ“ù»“ªµ“ª¤“¡£

=begin original

Floating-point numbers are only approximations to what a mathematician
would call real numbers.  There are infinitely more reals than floats,
so some corners must be cut.  For example:

=end original

“Ý©“ÔÑ“á³‘Êý“ïÃ‘Êý“ªÏ‘Êý‘Ñ§“íº“ª¬’¼Â‘Êý“ªÈ“û¼“ªÖ“ªâ“ªÎ“ªÎ“ÐÎ“ÞÄ“ªÇ“ª·“ª«“ª¢“ªê“ªÞ“ª»“ªó“¡£
’¼Â‘Êý“ªÏ“Ý©“ÔÑ“á³‘Êý“ïÃ“ªè“ªê“Ùí“ùÚ“ªË’Â³“ª¯“ªÎ“ªÇ“¡¢“Òý“á´“ÊÇ“ª¬“ü¯“ªá“ªé“ªì“ªÞ“ª¹“¡£
“ÖÇ:

    printf "%.20g\n", 123456789123456789;
    #        produces 123456789123456784

=begin original

Testing for exact equality of floating-point equality or inequality is
not a good idea.  Here's a (relatively expensive) work-around to compare
whether two floating-point numbers are equal to a particular number of
decimal places.  See Knuth, volume II, for a more robust treatment of
this topic.

=end original

“Ý©“ÔÑ“á³‘Êý“ïÃ‘Êý“ª¬“Ôõ“ª·“ª¤“ª«“ªÉ“ª¦“ª«“ªò“ªÁ“ªç“ª¦“ªÉ“ÔÒ“ª¸“ª«“ªÉ“ª¦“ª«“ªÇ“Ýï“Îò“ª¹“ªë“ªÎ“ªÏ
“ª¤“ª¤“«¢“«¤“«Ç“«¢“ªÇ“ªÏ“ª¢“ªê“ªÞ“ª»“ªó“¡£
“ì¤“ù»“ªË“¡¢“ì£“ªÄ“ªÎ“Ý©“ÔÑ“á³‘Êý“ïÃ‘Êý“ª¬“ò¦“ïÒ“ªµ“ªì“ª¿“ùù“ªÞ“ªÇ“Ôõ“ª·“ª¤“ª«“ªÉ“ª¦“ª«“ªò
“Ýï“Îò“ª¹“ªë(“Ýï“Îò“îÜ“ñì“ª¤)“ó­“à¼“ªÎ“óþ“ªò“ãÆ“ª·“ªÞ“ª¹“¡£
“ª³“ªÎ“Ùý“ð¹“ªË’´Ø“ª¹“ªë“ªè“ªê’¸·“ÚË“ªÊ“Ðâ“ª¤“ªË“ªÄ“ª¤“ªÆ“ªÏ Knuth, volume II “ªò‘²Î“ðÎ“ª·“ªÆ“ù»“ªµ“ª¤“¡£

    sub fp_equal {
	my ($X, $Y, $POINTS) = @_;
	my ($tX, $tY);
	$tX = sprintf("%.${POINTS}g", $X);
	$tY = sprintf("%.${POINTS}g", $Y);
	return $tX eq $tY;
    }

=begin original

The POSIX module (part of the standard perl distribution) implements
ceil(), floor(), and other mathematical and trigonometric functions.
The Math::Complex module (part of the standard perl distribution)
defines mathematical functions that work on both the reals and the
imaginary numbers.  Math::Complex not as efficient as POSIX, but
POSIX can't work with complex numbers.

=end original

POSIX “«â“«¸“«å’¡¼“«ë(Perl “øö“ñÞ“ÛÕ“øÖ“«Ñ“«Ã“«±’¡¼“«¸“ªÎ“ìé“Ý») “ªÏ ceil(), floor() “Ðà“ªÓ
“ª½“ªÎ“öâ“ªÎ‘Êý‘Ñ§’´Ø‘Êý“ªä“ß²“ÊÇ’´Ø‘Êý“ªò’¼Â‘×°“ª·“ªÆ“ª¤“ªÞ“ª¹“¡£
Math::Complex “«â“«¸“«å’¡¼“«ë(Perl “øö“ñÞ“ÛÕ“øÖ“«Ñ“«Ã“«±’¡¼“«¸“ªÎ“ìé“Ý»)“ªÏ
’¼Â‘Êý“ªÈ‘Ðé‘Êý“ªÎ’Î¾“Û°“ªÇ“ÔÑ“íÂ“ª¹“ªë‘Êý‘Ñ§’´Ø‘Êý“ªò“ïÒ“ëù“ª·“ªÆ“ª¤“ªÞ“ª¹“¡£
Math::Complex “ªÏ POSIX “ªÛ“ªÉ’¸ú“áã“îÜ“ªÇ“ªÏ“ª¢“ªê“ªÞ“ª»“ªó“ª¬“¡¢
POSIX “ªÏ“ÜÜ“áÈ‘Êý“ªÏ“Ðâ“ª¨“ªÞ“ª»“ªó“¡£

=begin original

Rounding in financial applications can have serious implications, and
the rounding method used should be specified precisely.  In these
cases, it probably pays not to trust whichever system rounding is
being used by Perl, but to instead implement the rounding function you
need yourself.

=end original

“ÑÑ“ë×“«¢“«×“«ê“«±’¡¼“«·“«ç“«ó“ªË“ªª“ª±“ªë“ü¯“ªá“ªÏ“ä¢“Ê¾“ªÊ“ç¯“úÂ“ªò‘Óë“ª¨“ªë“Ê¦“Òö“àõ“ª¬“ª¢“ªê“¡¢
“ÞÅ“éÄ“ª¹“ªë“ü¯“ªá“«á“«½“«Ã“«É“ªÏ“ò¦“ïÒ“ªµ“ªì“ª¿“ïñ“Óø“ªÇ“ú¼“ªï“ªì“ªë“ªÙ“ª­“ªÇ“ª¹“¡£
“ª³“ªÎ“ªè“ª¦“ªÊ“íÞ“ùê“¡¢Perl “ª¬“ÞÅ“éÄ“ª¹“ªë“«·“«¹“«Æ“«à“ü¯“ªá“ªò“ãá“éÄ“ª»“ªº“¡¢
“ÓÛ“ªï“ªê“ªË“í»“ÝÂ“í»“ãó“ªÇ“ü¯“ªá’´Ø‘Êý“ªò’¼Â‘×°“ª¹“ªë“ªÙ“ª­“ªÇ“ª¹“¡£

=head2 Bigger Numbers
X<number, arbitrary precision>

(“ªè“ªê“ÓÞ“ª­“ªÊ‘Êý)

=begin original

The standard Math::BigInt and Math::BigFloat modules provide
variable-precision arithmetic and overloaded operators, although
they're currently pretty slow. At the cost of some space and
considerable speed, they avoid the normal pitfalls associated with
limited-precision representations.

=end original

“øö“ñÞ“ªÎ Math::BigInt “ªÈ Math::BigFloat “«â“«¸“«å’¡¼“«ë“ªÏ“Òý“ÛÃ“íþ“æÑ“ß©“ªò“ð«“Íê“ª·“¡¢
“æÑ“ß©“í­“ªò“«ª’¡¼“«Ð’¡¼“«í’¡¼“«É“ª·“ªÞ“ª¹“ª¬“¡¢“ª³“ªì“ªé“ªÏ“úÞ“î¤“ªÎ“ªÈ“ª³“ªí“ª«“ªÊ“ªê’ÃÙ“ª¤“ªÇ“ª¹“¡£
“Òý“á´“ªÎ“ÖÅ“æ´“ªÈ“ª«“ªÊ“ªê“ªÎ“áÜ“Óø“ªò’µ¾“ßå“ªË“ª·“ªÆ“¡¢“ùù‘Êý“ª¬“ð¤“ùÚ“ªµ“ªì“ªÆ“ª¤“ªë“ª³“ªÈ“ªË“ªè“ªë
“ª¢“ªê“ª¬“ªÁ“ªÊ“Õª“ªÈ“ª·“úë“ªò“ù­“ª±“ªë“ª³“ªÈ“ª¬“ªÇ“ª­“ªÞ“ª¹“¡£

    use Math::BigInt;
    $x = Math::BigInt->new('123456789123456789');
    print $x * $x;

    # prints +15241578780673678515622620750190521

=begin original

There are several modules that let you calculate with (bound only by
memory and cpu-time) unlimited or fixed precision. There are also
some non-standard modules that provide faster implementations via
external C libraries.

=end original

(“«á“«â“«ê“ªÈ CPU “ãÁ“Êà“ªÎ“ªß“ªË“ëî“ðí“ª¹“ªë)“Ùí“ð¤“ùÚ“ª«“Í³“ïÒ“ªÎ“ïñ“Óø“ªÇ“ªÎ“Íª“ß©“ª¬“ªÇ“ª­“ªë
“«â“«¸“«å’¡¼“«ë“ª¬“ª¤“ª¯“ªÄ“ª«“ª¢“ªê“ªÞ“ª¹“¡£
“ªµ“ªé“ªË“èâ“Ý» C “«é“«¤“«Ö“«é“«ê“ªò“ÞÅ“ªÃ“ªÆ“ªè“ªê“áÜ“ª¤’¼Â‘×°“ªò“ð«“Íê“ª¹“ªë
“Þª“øö“ñÞ“ªÎ“«â“«¸“«å’¡¼“«ë“ªâ“ª¢“ªê“ªÞ“ª¹“¡£

=begin original

Here is a short, but incomplete summary:

=end original

“ì¤“ù»“ªÏ“Ó­“ª¤“ªÇ“ª¹“ª¬“Üô“èÇ“îï“ªÊ“«ê“«¹“«È“ªÇ“ª¹“¡£

=begin original

	Math::Fraction		big, unlimited fractions like 9973 / 12967
	Math::String		treat string sequences like numbers
	Math::FixedPrecision	calculate with a fixed precision
	Math::Currency		for currency calculations
	Bit::Vector		manipulate bit vectors fast (uses C)
	Math::BigIntFast	Bit::Vector wrapper for big numbers
	Math::Pari		provides access to the Pari C library
	Math::BigInteger	uses an external C library
	Math::Cephes		uses external Cephes C library (no big numbers)
	Math::Cephes::Fraction	fractions via the Cephes library
	Math::GMP		another one using an external C library

=end original

	Math::Fraction		9973 / 12967 “ªÎ“ªè“ª¦“ªÊ“¡¢“ÓÞ“ª­“ª¯“ªÆ“Ùí“ð¤“ùÚ“ªÎ“ÝÂ‘Êý
	Math::String		“Ùþ“í®“Öª“ªò‘Êý“ö·“ªÎ“ªè“ª¦“ªË“Ðâ“ª¦
	Math::FixedPrecision	“Í³“ïÒ“ïñ“Óø“ªÇ“Íª“ß©“ª¹“ªë
	Math::Currency		“÷×“ü§“ªÎ“Íª“ß©“éÄ
	Bit::Vector		(C “ªò“ÞÅ“ªÃ“ªÆ)“«Ó“«Ã“«È“«Ù“«¯“«¿“ªò“áÜ“ª¯“ðÃ“íÂ“ª¹“ªë
	Math::BigIntFast	“ÓÞ“ª­“ªÊ‘Êý“ªÎ“ª¿“ªá“ªÎ Bit::Vector “ªÎ“«é“«Ã“«Ñ’¡¼
	Math::Pari		Pari C “«é“«¤“«Ö“«é“«ê“ªØ“ªÎ“«¢“«¯“«»“«¹“ªò“ð«“Íê“ª¹“ªë
	Math::BigInteger	“èâ“Ý» C “«é“«¤“«Ö“«é“«ê“ªò“ÞÅ“ª¦
	Math::Cephes		“èâ“Ý»“ªÎ Cephes C “ªò“ÞÅ“ª¦(“ÓÞ“ª­“ªÊ‘Êý“ªÏ“ªÊ“ª·)
	Math::Cephes::Fraction	Cephes “«é“«¤“«Ö“«é“«ê“ªò“ÞÅ“ªÃ“ª¿“ÝÂ‘Êý
	Math::GMP		“ª³“ªì“ªâ“èâ“Ý» C “«é“«¤“«Ö“«é“«ê“ªò“ÞÅ“ª¦

=begin original

Choose wisely.

=end original

“ª¦“ªÞ“ª¯“àÔ“ªó“ªÇ“ª¯“ªÀ“ªµ“ª¤“¡£

=cut

