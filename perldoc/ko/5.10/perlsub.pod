=head1 NAME
X<subroutine> X<function>

perlsub - Perl 서브루틴

=head1 SYNOPSIS

서브루틴의 정의:
X<subroutine, declaration> X<sub>

    sub NAME;			  # 앞부분의 선언.
    sub NAME(PROTO);		  #  프로토타입과 함께
    sub NAME : ATTRS;		  #  속성과 함께
    sub NAME(PROTO) : ATTRS;	  #  속성, 프로토타입과 함께

    sub NAME BLOCK		  # 선언과 정의를 동시에.
    sub NAME(PROTO) BLOCK	  #  프로토타입과 함께
    sub NAME : ATTRS BLOCK	  #  속성과 함께
    sub NAME(PROTO) : ATTRS BLOCK #  프로토타입, 속성과 함께

실행시간에 익명 서브루틴 정의하기 :
X<subroutine, anonymous>

    $subref = sub BLOCK;		 # no proto
    $subref = sub (PROTO) BLOCK;	 # with proto
    $subref = sub : ATTRS BLOCK;	 # with attributes
    $subref = sub (PROTO) : ATTRS BLOCK; # with proto and attributes

서브루틴 가져오기(import) :
X<import>

    use MODULE qw(NAME1 NAME2 NAME3);

서브루틴 호출하기 :
X<subroutine, call> X<call>

    NAME(LIST);	   # 괄호를 사용할 땐 & 는 옵션이다.
    NAME LIST;	   # 서브루틴이 미리 선언되거나 import되었을때 괄호는 옵션이다.
    &NAME(LIST);   # Circumvent prototypes.
    &NAME;	   # Makes current @_ visible to called subroutine.

=head1 DESCRIPTION

많은 언어에서처럼, 펄은 사용자정의 서브루틴을 제공한다.
Like many languages, Perl provides for user-defined subroutines.
이들은 메인 프로그램의 어디에나 위치할 수 있고,
C<do>, C<require>나 C<use> 키워드를 통해 로드되기도 하고
C<eval>이나 익명 서브루틴에 의해 런타임(실행시간)에 만들어기도 한다.
심지어 코드 레퍼런스나 이름을 가진 변수를 이용해 우회적으로 함수를 호출할 수도 있다

펄의 함수호출과 반환값 모델은 단순하다:
모든 함수는 하나의 플랫한 스칼라 리스트를 인자로 전달받는다.
마찬가지로 모든 함수는 하나의 플랫한 스칼라 리스트를 호출자에게 반환한다
이 리스트의 호출과 반환 과정에서 모든 배열과 해쉬들은 자신의 정체성을 잃고 와해된다.
-- 이것을 피하기 위해 레퍼런스 전달을 사용하면된다.
호출되거나 반환되는 리스트는 원하는 만큼의 요소를 가질 수 있다.
(가끔 명시적인 반환구문이 없는 함수를 서부루틴이라고 부르기도 하지만
펄의 사고방식에서는 함수와 서브루틴은 차이가 없다.)
X<subroutine, parameter> X<parameter>

모든 전달된 인자는 C<@_> 배열에 나타난다(저장된다?).
따라서 2개의 인자와 함께 함수를 호출하면 이 인자들은 C<$_[0]> and C<$_[1]>에 저장된다.
C<@_> 배열은 로컬 배열이지만
배열의 요소들은 실제 스칼라 인자들의 별칭들이다.
자세히 말하자면, C<$_[0]>가 갱신되면, 대응하는 인자도 갱신된다.
(갱신될 수 없는 경우 에러가 발생한다)
만약 인자가 함수가 호출될때 배열이나 해쉬의 아직 존재(exist)하지 않는 요소라면
그 요소가 수정되거나 요소에대한 레퍼런스가 사용될때 그 요소가 만들어진다.
(초기의 펄은 요소가 할당되었는지에 상관없이 요소를 만들었다.)
C<@_> 배열 자체를 다시 지정하면 이러한 요소의 연결관계가 사라지고
더이상 인자가 바뀌는 일도 없어진다.
X<subroutine, argument> X<argument> X<@_>

C<return> 구문은 서브루틴을 종료시킨다.
추가로, 서부루틴의 호출 문맥에 의존해 적절한 문맥(리스트, 스칼라, void)에서 평가될 수 있는
반환값을 지정할 수 있다.
반환값을 명시하지 않으면, 서브루틴은 리스트 문맥에서는 빈 리스트를,
스칼라 문맥에서는 undifined 스칼라를 반환하고 void 문맥에서는 아무것도 만환하지 않는다
배열이나 해쉬의 집합체를 반환하면, 이들은 구별할 수 없는 하나의 리스트로 통홥된다

C<return> 구문이 없고 마지막 구문이 표현식이면, 이 표현식의 값이 반환된다
마지막 구문이 C<foreach>나 C<whie> 같은 루프 구조문이면 반환값이 명시되지 않는다.(?)
빈 서브루틴은 빈 리스트를 반환한다.
X<subroutine, return value> X<return value> X<return>

펄은 명명된 형식인자가 없다.
그러나 실제 적용에 있어서는 인자들을 모두 C<my()>리스트의 변수로 할당한다.
private로 선언되지 않은 변수들은 글로벌 변수이다.
private 변수 생성에 관한 세부사항은 아래의 "Private Variables via my()"와 "Temporary Values via local()"을 보라.
별도의 패키지에서(또는 아마도 별도의 파일에서)
함수 설정을 보호하기 위한 환경을 만들기 위해서는 L<perlmod/"Packages"를 보라.

예:

    sub max {
	my $max = shift(@_);
	foreach $foo (@_) {
	    $max = $foo if $max < $foo;
	}
	return $max;
    }
    $bestday = max($mon,$tue,$wed,$thu,$fri);

Example:

    # get a line, combining continuation lines
    #  that start with whitespace

    sub get_line {
	$thisline = $lookahead;  # global variables!
	LINE: while (defined($lookahead = <STDIN>)) {
	    if ($lookahead =~ /^[ \t]/) {
		$thisline .= $lookahead;
	    }
	    else {
		last LINE;
	    }
	}
	return $thisline;
    }

    $lookahead = <STDIN>;	# get first line
    while (defined($line = get_line())) {
	...
    }

인자들에 이름을 주기 위해서 private 변수 리스트에 할당한다.

    sub maybeset {
	my($key, $value) = @_;
	$Foo{$key} = $value unless $Foo{$key};
    }

할당은 값을 복사하는 것이기 때문에, call-by-reference를 call-by-value로 바꾸는 효과도 있다.
다른 관점에서 함수는  C<@_>의 요소가 수정될때 호출한 인자의 값이 바뀌는 것으로 부터 자유로와 진다.
X<call-by-reference> X<call-by-value>

    upcase_in($v1, $v2);  # this changes $v1 and $v2
    sub upcase_in {
	for (@_) { tr/a-z/A-Z/ }
    }

당연히 이런 방법으로 상수를 수정하는 것은 허용되지 않는다.
인자가 문자열일때 그것을 수정하려 하면 (아마도 치명적인) 예외가 발생할 것이다.
예를 들어 이것은 작동하지 않는다.
X<call-by-reference> X<call-by-value>

    upcase_in("frederick");

C<upcase_in> 함수가 직접 값을 수정하지 않고 다음과 같이 수정된 값의 복사본을
반환하도록 함수를 작성하는 것이 훨씬 안전하다.

    ($v3, $v4) = upcase($v1, $v2);  # $v1과 $v2를 바꾸지 않는다.
    sub upcase {
	return unless defined wantarray;  # void context, do nothing
	my @parms = @_;
	for (@parms) { tr/a-z/A-Z/ }
  	return wantarray ? @parms : $parms[0];
    }

이러한 프로토타입이 없는 함수는 실제로 스칼라나 배열이 전달되었는지를
상관하지 않는다는데 주목하자
펄은 모든 인자를 하나의 크고, 길고, 플랫한 리스트로 간주하고 C<@_>에 담는다.
펄의 단순한 인자 전달 방식이 빛을 발하는 예를 보자.
C<upcase()> 함수는 C<upcase()>의 정의를 수정하지 않아도 다음과 같은 경우에 완벽하게 작동한다

    @newlist   = upcase(@list1, @list2);
    @newlist   = upcase( split /:/, $var );

하지만 이런 유혹은 작동하지 않는다.

    (@a, @b)   = upcase(@list1, @list2);

플랫한 전달 인자 리스트처럼, 반환 리스트도 플랫하게 변환된다.
따라서 모든 것이 C<@a>에 저장되고 C<@b>는 아무것도 없게 된다.
이에대한 대안으로 L<Pass by Reference> 를 보라.

서브루친은 명시적으로 C<&> 접두사와 함께 호출 될 수 있다.
현대 펄에서 C<&>는 선택적이다.
서브루틴이 predeclared되었을 경우 괄호도 생략할 수 있다.
defined()나 undef()의 인자로 쓰일때 처럼 함수자체를 지칭할 때는 C<&>가 필수이다.
또한  C<&$subref()> or C<&{$subref}()> 를 이용하여 서브루틴의 이름이나
레퍼런스를 이용해 호출할때도 C<&>가 필요하다.
(비록 C<< $subref->() >> 표시법을 사용할 수도 있지만. 보다 자세한 것은 L<perlref>를 참조)
X<&>

서브루틴은 재귀적으로 호출될 수 있다.
서부루틴이 C<&> 형식으로 호출되면 인자리스트는 옵션이되고
인자 리스트가 생략된 경우에도 C<@_> 배열이 서브루틴에 적용되지 않는다.
대신에 호출시 @_배열을 서브루틴에 가시적으로 해준다.
이것은 새로운 사용자가 피하고자하는 효율적인 기법이다.
(역자주 : C<&>foo 형식의 함수호출에서 인자를 생략하면 널리스트가
함수내의 @_로 전달되지 않고 호출할때의 @_배열이 호출된 함수로 전달된다.
는 말을 상당히 어렵게 쓴듯하다.)
X<recursion>

    &foo(1,2,3);	# 세개의 인자 전달
    foo(1,2,3);		# 같음

    foo();		# 널리스트 전달
    &foo();		# 같음

    &foo;		# foo() 현재의 인자리스트를 얻는다. foo(@_)와 같다 !!
    foo;		# foo가 predecreare되어있으면 foo() 와 같고 아니면 bareword로 "foo"

C<&> 형식은 인자리스트를 선택적으로 만들뿐 아니라 인자에 대한 프로토타입 체크를 하지않게 한다.
이것은 부분적으로 역사적인 이유에서, 부분적으로 (뭘 하는지 알고 있다면)
속임수를 쓰기 편리한 방법을 제공하기 때문이다.
아래 L<Prototypes> 을 보라.
X<&>

소문자로 이루어진 모듈 이름처럼 대문자 서브루틴 이름은 펄 코어에 예약되어 있다
대문자 이름의 서즈루틴은 일반적으로 트리거된 이벤트에 의해 런타임 시스템에 의해 간접적으로 호출될 것이라는 의미를 가진 느슨한 약속이다
C<AUTOLOAD>, C<CLONE>, C<DESTORY>과  L<perltie> 과 L<PerlIO::via> 에 언급된 모든 함수들은
미리 정의된 특별한 기능을 한다.

서브루틴 C<BEGIN>, C<UNITCHECK>, C<CHECK>, C<INIT>  C<END> 은
하나의 패키지에 하나이상 가질수 있고 명시적으로 호출할 수 없는 이름을 가진 특별한 코드블럭이다
L<perlmod/"BEGIN, UNITCHECK, CHECK, INIT and END"> 을 참고하라.

=head2 Private Variables via my()
X<my> X<variable, lexical> X<lexical> X<lexical variable> X<scope, lexical>
X<lexical scope> X<attributes, my>

Synopsis:

    my $foo;	    	# declare $foo lexically local
    my (@wid, %get); 	# declare list of variables local
    my $foo = "flurp";	# declare $foo lexical, and init it
    my @oof = @bar;	# declare @oof lexical, and init it
    my $x : Foo = $y;	# similar, with an attribute applied

B<경고>: C<my> 선언에서 속성 리스트를 사용하는 것은 아직 개발중이다.
현재 시멘틱과 인터페이스는 바뀔 수 있다
L<attributes> 과 L<Attribute::Handlers> 를 참고하라.

C<my> 연산자는 리스트된 변수들을 둘러싸인  블록과 conditional (C<if/unless/elsif/else>),
loop (C<for/foreach/while/until/continue>), subroutine, C<eval>,
or C<do/require/use>'d file에 국한된 렉시컬 변수로 선언한다.
하나이상의 값이 리스트되면, 리스트는 반드시 괄호안에 있어야 한다.
모든 리스트된 요소는 반드시 lvalue로 적합해야 한다.
단지 영숫자 식별자(indentifier)만이 렉시컬 범위가 될 수 있다.-- C<$/>와 같은 마법의 내장변수들은 "local"로 지역화되어야 한다.

C<local> 연산자로 생성된 동적 변수와는 달리 C<my>로 선언된 렉시컬 변수는
호출된 서브루틴을 포함하여 바깥세상에서는 완전히 보이지 않는다.
이것은 같은 서브루틴이 자신으로부터 혹은 어느곳에서라도 호출되었을때도 만찬가지이다.
-- 모든 호출은 자신의 복사본을 얻는다.
X<local>

이것은 정적으로 둘러싸인  렉시컬 범위내에서 선언된 C<my> 변수가 보이지 않는 다는 것을 의미하지 않든다
Only dynamic scopes are cut off.
예를 들어, 아래 C<bumpx()> 함수는 C<my>와 C<sub> 가 같은 범위안에 있기 때문에 (아마도 파일 범위) 렉시컬 변수 $x를 액세스할 수 있다.

    my $x = 10;
    sub bumpx { $x++ }

그러나 eval()은 eval()안에서 선언에 의해 이름이 숨겨지지 않는 한 수행되는 범위의 렉시컬 변수를 볼 수 있다. perlref를 보라.
X<eval, scope of>

원한다며 my()로의 인자리스트에 할당함으로써 변수를 초기화할 수 있다. (특정 변수를 초기화하지 않는다면 미확정 값으로 생성된다. ) 일반적으로 이것은 인자에 이름을 붙이는데 사용한다. 예를 들면,

    $arg = "fred";	  # "global" variable
    $n = cube_root(27);
    print "$arg thinks the root is $n\n";
 fred thinks the root is 3

    sub cube_root {
	my $arg = shift;  # name doesn't matter
	$arg **= 1/3;
	return $arg;
    }

"my"는 할당하려하는 것에 관한 단순한 수정자이다. 그래서 인자리스트에서 변수에 할당하려 할 때 "my"는 이러한 변수들이 스칼라나 배열로 보이는 것을 바꾸지 않는다. 그래서,
The C<my> is simply a modifier on something you might assign to.  So when
you do assign to variables in its argument list, C<my> doesn't
change whether those variables are viewed as a scalar or an array.  So

    my ($foo) = <STDIN>;		# WRONG?
    my @FOO = <STDIN>;

둘 모두 오른쪽 변수에 리스트 문맥을 제공하며, 반면에
both supply a list context to the right-hand side, while

    my $foo = <STDIN>;

은 스칼라 문맥을 제공한다. 그러나 다음은 오직 단 한 변수만을 선언한다.
supplies a scalar context.  But the following declares only one variable:

    my $foo, $bar = 1;			# WRONG

위의 예는 다음과 같다.
That has the same effect as

    my $foo;
    $bar = 1;

선언된 변수는 현재 선언문까지는 의미가 없다. 따라서
The declared variable is not introduced (is not visible) until after
the current statement.  Thus,

    my $x = $x;

은 새 변수 $x에 옛 변수 $x로 초기화하는데 사용된다. 그리고
can be used to initialize a new $x with the value of the old $x, and
the expression

    my $x = 123 and $x == 123

은 옛 변수 $x의 값이 123이 아니라면 거짓이다.
is false unless the old $x happened to have the value C<123>.

제어문의 렉시컬 범위는 제어문에 의해 제어되는 블럭을 결정하는 중괄호에 의해 한정되지
않고 제어문의 표현식까지 포함된다. 따라서 루프에서

    while (my $line = <>) {
        $line = lc $line;
    } continue {
        print $line;
    }

the scope of $line extends from its declaration throughout the rest of
the loop construct (including the C<continue> clause), but not beyond
it.  Similarly, in the conditional

    if ((my $answer = <STDIN>) =~ /^yes$/i) {
        user_agrees();
    } elsif ($answer =~ /^no$/i) {
        user_disagrees();
    } else {
	chomp $answer;
        die "'$answer' is neither 'yes' nor 'no'";
    }

$answer 의 범위는 선언된 곳으로 부터 모든 C<elsif>과  C<else>을 포함하는 나머지 제어문까지 확장된다.
변환자(?)를 사용하는 구문 안에서 변수의 범위에 대한 정보는  L<perlsyn/"Simple statements">를 보라.
on the scope of variables in statements with modifiers.


C<foreach> 루프는 기본적으로 인덱스 변수로 C<local>  변수를 사용한다.
그러나 인덱스변수 앞에 C<my>를 사용하거나 범위내에서 렉시컬 변수로 선언된 변수의 이름을 사용하면
새로운 렉시컬변수가 만들어진다. 따라서 다음 루프는
X<foreach> X<for>

    for my $i (1, 2, 3) {
        some_function();
    }

$i의 범위는 루프의 끝까지 지속된다. 그러나 C<some_function()>안에서는 $i의 값을 사용할 수 없다.
(역자주:local변수는 호출된 함수에서 사용할 수 있다)
X<foreach> X<for>

어떤 유저들은 렉시컬 범위변수의 사용을 독려하기를 원한다. 암묵적으로 항상 글로벌인 패키지변수를 사용하는 것을 잡아내고자 할때 패키지 변수로의 함축적 참조를 획득하려 할 때, 다음과 같이 쓰면,

    use strict 'vars';

이 문장이 있는 곳부터 포함된 블럭 안에서 모든 변수는 렉시컬 변수이거나 C<our> 나 C<use vars>에서 선언된거나 패키지 이름과 함께 한정된 변수여야 한다. 그렇지 않다면 컴파일 에러가 발생한다. 이거은 블록 안에서 C<no strict 'vars'>로 취소할 수 있다.

my()는 컴파일시와 실행시 모두 효력을 갖는다. 컴파일시에 컴파일러는 이것에 주목하게 된다. 이것의 기본적인 유용함은 C<use strict 'vars'>을 누그러뜨리기 위한 것이다. 또한 L<perlref>에 자세히 나오는 클로져를 만드는 핵심이다. 실제 초기화는 실행시까지 일어나지 않으며 루프를 통해 매번 실행때마다 획득된다.

"my"로 선언된 변수는 패키지의 일부가 아니며 패키지 이름에 한정되지 않는다. 특히, 패키지 변수를 렉시컬 변수로 만드는 것을 허용하지 않는다.


    my $pack::var;	# ERROR!  Illegal syntax

사실은 동적 변수( 패키지 또는 전역 변수로 알고 있는)는  제한 기호인 ::를 사용해서 접근할 수 있다. 심지어 같은 이름의 렉시컬 변수도 보이더라도 말이다.

    package main;
    local $x = 10;
    my    $x = 20;
    print "$x and $::x\n";

"20 and 10"을 출력할 것이다.

대개의 파일 최외곽 범위에서 "my"변수 선언으로 파일 외부로부터 변수의 식별자를 숨길 수 있다.
이것은 C의 파일 수준에서의 정적 변수와 유사한 면이 있다.
서브루틴으로 이를 하기 위해서는 클로져(closure)의 사용이 필요하다.
블록(eval(), 함수 또는 패키지 같이 그 블록 외부에서부터 호출을 가능하지 않기 위해
사적 변수의 생성을 원한다며 무명서브루틴 참조를 포함하는 렉시컬 변수를 선언할 수 있다.

    my $secret_version = '1.001-beta';
    my $secret_sub = sub { print $secret_version };
    &$secret_sub();

참조가 모듈내에서 함수에 의해 반환되지 않는 한 모듈 바깥에서 서브루틴을
볼 수가 없으며 이것은 그것의 이름이 패키지의 심볼테이블에 입력되지 않기 때문이다.
그래서 실제로 C<$some_pack::secret_version>이나 다른 것을 호출하는 것이 아니라
$secret_version일 뿐이며 제한될 수도 제한되지도 않을 것이다.

그러나 이것은 객체 메쏘드와 함께 다뤄지지 않는다.
모든 객체 메쏘드는 패키지의 심볼테이블안에 들어가야만 한다.
L<perlref/"Function Templates"> 을 보시오.

=head2 Persistent Private Variables
X<state> X<state variable> X<static> X<variable, persistent> X<variable, static> X<closure>

Perl 5.10 에는 persistent private 변수를 만드는 두가지 방법이 있다
하나는 간단히 C<state> 구문을 사용하는 것이고
다른 하나는 5.10 보다 낮은 버전을 사용해야 한다면 클로져를 사용할 수 있다.

=head3 state()를 이용한 영속적인 변수(Persistent variables via state())
펄 5.9.4부터 C<my> 위치에 C<state>를 쓸수 있다 .
state()를 사용하기 위해서는 C<feature> 프라그마(pragma)나 C<-E> 온라인 옵션을
이용하여 기능을 활성화해야 한다.
(L<feature>를 보시오)

예를 들어 다음 코드는  gimme_another() 함수가 호출될때마다 증가하는 private 카운터를 관리한다.

    use feature 'state';
    sub gimme_another { state $x; return ++$x }

C<$x>가 렉시컬이기 때문에 함수외부의 어떤 코드로도 직접 접근하거나 수정할 수 없다.

변수선언 구문에서 C<state> 변수에 대한 단순 스칼라 대입(C<state $x = 42> 같은) 처음 한번만 실행된다.
이 구분이 연이어 실행되면 대입은 무시된다.
스칼라가 아닌 state 변수에 대한 선언시 대입은 정의되지 않았다.

=head3 클로져(closures)를 이용한 영속적 변수(Persistent variables with closures)
단지 렉시컬 변수가 변수를 포함한 블록이나 C<eval>, C<do> FILE  안에서
사전적인(lexically) 또는 정적인 범위를 가지기 때문에
C의 static과 같은 역할을 한다는 것은 아니다
이것은 오히려 C의 auto 변수와 비슷하다
(렉시컬 변수는 묵시적인 가비지 콜렉션 기능이 있다는 점은 제외하고).

C나 C++의 지역변수(local variables)와 달리 펄의 렉시컬 변수는
변수의 범위가 끝났다는 이유만으로 페기되지 않는다.
다른 어떤 것이 지속적으로 렉시컬 변수에 대해 알고 있으면 변수는 유지된다.
어떤 것이 렉시컬 변수를 참조하고 있으면 렉시컬 변수는 메로리에서 지워지지 않는다.
(당연히 그래야하듯이)
렉시컬 변수를 다 사용하기 전에 변수가 지워지는 것을 바라지 않을 것이다.
자동 가비지 콜렉션은 이런 부분을 고려하고 있다.

이는 렉시컬 변수의 레퍼런스를 돌려받거나 저장하여 사용할 수 있다는 것을 의미한다.
(C에서는 자동변수의 포인터를 반환하면 에러가 생긴다)
이것은 C의 함수 정적(static) 변수를 흉내낼 수 있는 방법을 제공한다.
여기 렉시컬 범위와 static 라이프타임을 갖는 "함수 private 변수"를 만드는 방법이 있다.
C의 정적 변수와 같은 변수를 생성하고자 하면 단순히 함수 전체를 외부 블록으로 감싸기만 하면 된다.
그리고 정적 변수로 만들고자 하는 것을 함수 외부, 블록 안에 넣으면 된다.

    {
	my $secret_val = 0;
	sub gimme_another {
	    return ++$secret_val;
	}
    }
    # $secret_val 는 이제 여기서 접근할 수 없다.
    # 그러나 gimme_another를 호출하면 $secret_var을 증가시켜 반환한다.

이 함수를 별도의 파일로부터 require나 use를 통해 삽입하는 것도 좋다.
이 모든 것이 메인프로그램에 있다면 일찍이 실행되기 위해 my()로 정렬할 필요가 있을 것이고,
또 메인프로그램 의 앞부분에 전체 블록을 위치하거나
프로그램이 실행되기 전에 실행하도록 확실히 하기위해 BEGIN 을 사용할 필요가 있을 것이다.(?)
(역자 주 : 함수는 위치에 상관없이 실행될 수 있지만 my $secret_var의 선언은 문맥상의 순서에 따라 실행된다. 따라서 my $secret_var이 실행되기전에 gimme_another이 호출되면 에러가 발생할듯, 테스트해볼것)

    BEGIN {
	my $secret_val = 0;
	sub gimme_another {
	    return ++$secret_val;
	}
    }
 C<BEGIN>, C<UNITCHECK>, C<CHECK>,
C<INIT> and C<END> 등의 특수 트리거 코드블럭에 대해서는  L<perlmod/"BEGIN, UNITCHECK, CHECK, INIT and END"> 를 참조할 것.

만약 렉시컬 변수가 최외곽 범위(즉 파일 범위)에서 선언되었다면,
렉시컬 변수는 C의 파일 정적변수 처럼 작동한다.
변수선언 다음에 선언된 동일 파일 내의 모든 함수는 이 변수를 사용할 수 있지만
파일 밖의 함수는 접근할 수 없다.
이 전략은 모듈안에 모듈내의 모든 함수가 접근할 수 있는 private 변수를 만들기 위해 사용된다.

=head2 local과 임시값(Temporary Values via local())
X<local> X<scope, dynamic> X<dynamic scope> X<variable, local>
X<variable, temporary>

B<경고>: C<my>가 C<local>보다 빠르고 안전하기 때문에 보통은 C<my>를
쓰는 것이 좋다. 글로벌 punctuation(?) 변수, 글로벌 파일핸들과 포맷, 펄 심볼테이블 직접 처리 등의 예외가 있다.
C<local>이 가장 많이 쓰이는 건, 호출한 서브루틴에서 현재 범위의 변수를 사용하고 싶을 때이다.

Synopsis:

    # 변수 지역화(localization of values)

    local $foo;			# make $foo dynamically local
    local (@wid, %get);		# make list of variables local
    local $foo = "flurp";	# make $foo dynamic, and init it
    local @oof = @bar;		# make @oof dynamic, and init it

    local $hash{key} = "val";	# sets a local value for this hash entry
    local ($cond ? $v1 : $v2);	# several types of lvalues support
				# localization

    # localization of symbols

    local *FH;			# localize $FH, @FH, %FH, &FH  ...
    local *merlyn = *randal;	# now $merlyn is really $randal, plus
                                #     @merlyn is really @randal, etc
    local *merlyn = 'randal';	# SAME THING: promote 'randal' to *randal
    local *merlyn = \$randal;   # just alias $merlyn, not @merlyn etc


local()은 리스트된 변수를 현재 포함된 블록,C<eval>, C<do FILE>, I<블럭안에서 호출된 모든 서브루틴>으로 지역화하며
그리고 단지 전역 변수에 임시값을 줄 뿐 local 변수를 만들지는 않는다.
이것을 동적 범위라고도 한다.
렉시컬 범위는 "my"로 수행되며 C의 자동 변수 선언과 같다.(갑자기 이말은 왜?)

몇종류의 lvalue는 잘 지역화된다. : 해쉬, 배열 원소들이나 슬라이스, 조건(지역화할 수 있는 결과를 주는?), 심볼릭 레퍼런스. 간단한 변수에 대해서 local은 새로운 동적인 범위의 값을 만든다(?)

하나 이상의 변수나 표현식을 C<local> 에 사용하려면 반드시 괄호를 사용해야 한다.
local 연산자는 변수들의 현재값을 숨겨진 스택에 저장하고 블럭이나 서브루틴,
eval이 끝나면 원래 값을 복원한다.

This means that called subroutines can also reference the local
variable, but not the global one.
원한다면 인자리스트에 할당하여 로컬 변수를초기화할 수 있다. (특정 변수를 초기화하지 않는다면 미확정 값으로 생성된다.

C<local()>은 실행시 명령이기 때문에 루프를 통해 매번 실행된다. 따라서 루프 외부에서 변수를 선언하는 것이 더 효율적이다.

=head3 local의 문법정리(Grammatical note on local())
X<local, context>

C<local>은 단순한 lvalue 표현식에대한 변경자이다.
local 변수에 값을 할당할때 C<local>은 변수 리스트가 스칼라나든 배열로 보이는 것을 바꾸지 않는다.
(주: 즉 그냥 할당문과 같이 문맥에 따라 해석된다.)
따라서

    local($foo) = <STDIN>;
    local @FOO = <STDIN>;

둘다 리스트 문맥이 적용된다. 하지만 다음 경우는

    local $foo = <STDIN>;

스칼라 문맥이다.

=head3 특수변수의 지역화(Localization of special variables)
X<local, special variable>

특수변수(special variable)을 지역화 한다면 그 변수에 새로운 값을 줄 수 있다.
게다가 특수변수의 마술은 사라지지 않는다.
특수변수의 마술과 관련된 모든 부수효과들이 지역화된 특수변수에서도 작동한다는 뜻이다.

이런 특징때문에 다음과 같은 가능하다.


    # 파일의 모든 내용을 $slup에 저장한다.
    { local $/ = undef; $slurp = <FILE>; }

하지만 몇몇 특수변수의 지역화에는 제약이 있다는 사실을 명심하라;
예를 들어, 다음 구문은 perl 5.9.0에서 $1변수가 매직변수이고 읽기전용 변수이기 때문에
I<Modification of a read-only value attempted> 에러와 함께
종료된다.

    local $1 = 2;

비슷하게(하지만 더 어려운 방법으로), 다음 코드도 perl 5.9.0에서 죽는다. :

    sub f { local $_ = "foo"; print }
    for ($1) {
  # $_ 는 $1의 별칭(alias)이기 때문에 매직변수이고 읽기전용이다.
	f();
    }

다음 섹션에서 이 상황에 대한 대안을 알아보자.

B<경고>: 타이된 배열과 해쉬를 지역화하는 것은 현재 작동하지 않는다.
이것은 나중에 수정될 것이다; 그 동안에는 타이된 배열이나 해쉬를 지역화해서 얻는
특수한 동작에 의존하는 코드를 피하라.(각각의 요소를 지역화하는 것은 문제없다.)
보다 자세한 것은 L<perl58delta/"Localising Tied Arrays and Hashes Is Broken">를 보라.
X<local, tie>

=head3 globs의 지역화(Localization of globs)
X<local, glob> X<glob>

The construct

    local *name;

는 현재 패키지에 glob C<name>을 위한 완전히 새로운 심볼테이블을 만든다.
name 의 glob slot($name, @name, %name, &name, and the C<name> filehandle)안의
모든 변수들이 동적으로 리셋된다는 것을 의미한다.

이 변수들에 결과적으로 동반되는 모든 매직이 잠시(locally) 사라진다.
다시 말해  C<local */> 는 내부 입력 레코드 구분자 에는 아무 영향을 미치지 않는다.
(역자주 : $/ 는 입력레코드 구분자이다.)

Notably, if you want to work with a brand new value of the default scalar
$_, and avoid the potential problem listed above about $_ previously
carrying a magic value, you should use C<local *_> instead of C<local $_>.
As of perl 5.9.1, you can also use the lexical form of C<$_> (declaring it
with C<my $_>), which avoids completely this problem.

=head3 Localization of elements of composite types
X<local, composite type element> X<local, array element> X<local, hash element>

It's also worth taking a moment to explain what happens when you
C<local>ize a member of a composite type (i.e. an array or hash element).
In this case, the element is C<local>ized I<by name>. This means that
when the scope of the C<local()> ends, the saved value will be
restored to the hash element whose key was named in the C<local()>, or
the array element whose index was named in the C<local()>.  If that
element was deleted while the C<local()> was in effect (e.g. by a
C<delete()> from a hash or a C<shift()> of an array), it will spring
back into existence, possibly extending an array and filling in the
skipped elements with C<undef>.  For instance, if you say

    %hash = ( 'This' => 'is', 'a' => 'test' );
    @ary  = ( 0..5 );
    {
         local($ary[5]) = 6;
         local($hash{'a'}) = 'drill';
         while (my $e = pop(@ary)) {
             print "$e . . .\n";
             last unless $e > 3;
         }
         if (@ary) {
             $hash{'only a'} = 'test';
             delete $hash{'a'};
         }
    }
    print join(' ', map { "$_ $hash{$_}" } sort keys %hash),".\n";
    print "The array has ",scalar(@ary)," elements: ",
          join(', ', map { defined $_ ? $_ : 'undef' } @ary),"\n";

Perl will print

    6 . . .
    4 . . .
    3 . . .
    This is a test only a test.
    The array has 6 elements: 0, 1, 2, undef, undef, 5

The behavior of local() on non-existent members of composite
types is subject to change in future.

=head2 Lvalue subroutines
X<lvalue> X<subroutine, lvalue>

B<WARNING>: Lvalue subroutines are still experimental and the
implementation may change in future versions of Perl.

It is possible to return a modifiable value from a subroutine.
To do this, you have to declare the subroutine to return an lvalue.

    my $val;
    sub canmod : lvalue {
	# return $val; this doesn't work, don't say "return"
	$val;
    }
    sub nomod {
	$val;
    }

    canmod() = 5;   # assigns to $val
    nomod()  = 5;   # ERROR

The scalar/list context for the subroutine and for the right-hand
side of assignment is determined as if the subroutine call is replaced
by a scalar. For example, consider:

    data(2,3) = get_data(3,4);

Both subroutines here are called in a scalar context, while in:

    (data(2,3)) = get_data(3,4);

and in:

    (data(2),data(3)) = get_data(3,4);

all the subroutines are called in a list context.

=over 4

=item Lvalue subroutines are EXPERIMENTAL

They appear to be convenient, but there are several reasons to be
circumspect.

You can't use the return keyword, you must pass out the value before
falling out of subroutine scope. (see comment in example above).  This
is usually not a problem, but it disallows an explicit return out of a
deeply nested loop, which is sometimes a nice way out.

They violate encapsulation.  A normal mutator can check the supplied
argument before setting the attribute it is protecting, an lvalue
subroutine never gets that chance.  Consider;

    my $some_array_ref = [];	# protected by mutators ??

    sub set_arr { 		# normal mutator
	my $val = shift;
	die("expected array, you supplied ", ref $val)
	   unless ref $val eq 'ARRAY';
	$some_array_ref = $val;
    }
    sub set_arr_lv : lvalue {	# lvalue mutator
	$some_array_ref;
    }

    # set_arr_lv cannot stop this !
    set_arr_lv() = { a => 1 };

=back

=head2 Passing Symbol Table Entries (typeglobs)
X<typeglob> X<*>

B<WARNING>: The mechanism described in this section was originally
the only way to simulate pass-by-reference in older versions of
Perl.  While it still works fine in modern versions, the new reference
mechanism is generally easier to work with.  See below.

Sometimes you don't want to pass the value of an array to a subroutine
but rather the name of it, so that the subroutine can modify the global
copy of it rather than working with a local copy.  In perl you can
refer to all objects of a particular name by prefixing the name
with a star: C<*foo>.  This is often known as a "typeglob", because the
star on the front can be thought of as a wildcard match for all the
funny prefix characters on variables and subroutines and such.

When evaluated, the typeglob produces a scalar value that represents
all the objects of that name, including any filehandle, format, or
subroutine.  When assigned to, it causes the name mentioned to refer to
whatever C<*> value was assigned to it.  Example:

    sub doubleary {
	local(*someary) = @_;
	foreach $elem (@someary) {
	    $elem *= 2;
	}
    }
    doubleary(*foo);
    doubleary(*bar);

Scalars are already passed by reference, so you can modify
scalar arguments without using this mechanism by referring explicitly
to C<$_[0]> etc.  You can modify all the elements of an array by passing
all the elements as scalars, but you have to use the C<*> mechanism (or
the equivalent reference mechanism) to C<push>, C<pop>, or change the size of
an array.  It will certainly be faster to pass the typeglob (or reference).

Even if you don't want to modify an array, this mechanism is useful for
passing multiple arrays in a single LIST, because normally the LIST
mechanism will merge all the array values so that you can't extract out
the individual arrays.  For more on typeglobs, see
L<perldata/"Typeglobs and Filehandles">.

=head2 When to Still Use local()
X<local> X<variable, local>

Despite the existence of C<my>, there are still three places where the
C<local> operator still shines.  In fact, in these three places, you
I<must> use C<local> instead of C<my>.

=over 4

=item 1.

You need to give a global variable a temporary value, especially $_.

The global variables, like C<@ARGV> or the punctuation variables, must be
C<local>ized with C<local()>.  This block reads in F</etc/motd>, and splits
it up into chunks separated by lines of equal signs, which are placed
in C<@Fields>.

    {
	local @ARGV = ("/etc/motd");
        local $/ = undef;
        local $_ = <>;
	@Fields = split /^\s*=+\s*$/;
    }

It particular, it's important to C<local>ize $_ in any routine that assigns
to it.  Look out for implicit assignments in C<while> conditionals.

=item 2.

You need to create a local file or directory handle or a local function.

A function that needs a filehandle of its own must use
C<local()> on a complete typeglob.   This can be used to create new symbol
table entries:

    sub ioqueue {
        local  (*READER, *WRITER);    # not my!
        pipe    (READER,  WRITER)     or die "pipe: $!";
        return (*READER, *WRITER);
    }
    ($head, $tail) = ioqueue();

See the Symbol module for a way to create anonymous symbol table
entries.

Because assignment of a reference to a typeglob creates an alias, this
can be used to create what is effectively a local function, or at least,
a local alias.

    {
        local *grow = \&shrink; # only until this block exists
        grow();                 # really calls shrink()
	move();			# if move() grow()s, it shrink()s too
    }
    grow();			# get the real grow() again

See L<perlref/"Function Templates"> for more about manipulating
functions by name in this way.

=item 3.

You want to temporarily change just one element of an array or hash.

You can C<local>ize just one element of an aggregate.  Usually this
is done on dynamics:

    {
	local $SIG{INT} = 'IGNORE';
	funct();			    # uninterruptible
    }
    # interruptibility automatically restored here

But it also works on lexically declared aggregates.  Prior to 5.005,
this operation could on occasion misbehave.

=back

=head2 Pass by Reference
X<pass by reference> X<pass-by-reference> X<reference>

If you want to pass more than one array or hash into a function--or
return them from it--and have them maintain their integrity, then
you're going to have to use an explicit pass-by-reference.  Before you
do that, you need to understand references as detailed in L<perlref>.
This section may not make much sense to you otherwise.

Here are a few simple examples.  First, let's pass in several arrays
to a function and have it C<pop> all of then, returning a new list
of all their former last elements:

    @tailings = popmany ( \@a, \@b, \@c, \@d );

    sub popmany {
	my $aref;
	my @retlist = ();
	foreach $aref ( @_ ) {
	    push @retlist, pop @$aref;
	}
	return @retlist;
    }

Here's how you might write a function that returns a
list of keys occurring in all the hashes passed to it:

    @common = inter( \%foo, \%bar, \%joe );
    sub inter {
	my ($k, $href, %seen); # locals
	foreach $href (@_) {
	    while ( $k = each %$href ) {
		$seen{$k}++;
	    }
	}
	return grep { $seen{$_} == @_ } keys %seen;
    }

So far, we're using just the normal list return mechanism.
What happens if you want to pass or return a hash?  Well,
if you're using only one of them, or you don't mind them
concatenating, then the normal calling convention is ok, although
a little expensive.

Where people get into trouble is here:

    (@a, @b) = func(@c, @d);
or
    (%a, %b) = func(%c, %d);

That syntax simply won't work.  It sets just C<@a> or C<%a> and
clears the C<@b> or C<%b>.  Plus the function didn't get passed
into two separate arrays or hashes: it got one long list in C<@_>,
as always.

If you can arrange for everyone to deal with this through references, it's
cleaner code, although not so nice to look at.  Here's a function that
takes two array references as arguments, returning the two array elements
in order of how many elements they have in them:

    ($aref, $bref) = func(\@c, \@d);
    print "@$aref has more than @$bref\n";
    sub func {
	my ($cref, $dref) = @_;
	if (@$cref > @$dref) {
	    return ($cref, $dref);
	} else {
	    return ($dref, $cref);
	}
    }

It turns out that you can actually do this also:

    (*a, *b) = func(\@c, \@d);
    print "@a has more than @b\n";
    sub func {
	local (*c, *d) = @_;
	if (@c > @d) {
	    return (\@c, \@d);
	} else {
	    return (\@d, \@c);
	}
    }

Here we're using the typeglobs to do symbol table aliasing.  It's
a tad subtle, though, and also won't work if you're using C<my>
variables, because only globals (even in disguise as C<local>s)
are in the symbol table.

If you're passing around filehandles, you could usually just use the bare
typeglob, like C<*STDOUT>, but typeglobs references work, too.
For example:

    splutter(\*STDOUT);
    sub splutter {
	my $fh = shift;
	print $fh "her um well a hmmm\n";
    }

    $rec = get_rec(\*STDIN);
    sub get_rec {
	my $fh = shift;
	return scalar <$fh>;
    }

If you're planning on generating new filehandles, you could do this.
Notice to pass back just the bare *FH, not its reference.

    sub openit {
	my $path = shift;
	local *FH;
	return open (FH, $path) ? *FH : undef;
    }

=head2 Prototypes
X<prototype> X<subroutine, prototype>

Perl supports a very limited kind of compile-time argument checking
using function prototyping.  If you declare

    sub mypush (\@@)

then C<mypush()> takes arguments exactly like C<push()> does.  The
function declaration must be visible at compile time.  The prototype
affects only interpretation of new-style calls to the function,
where new-style is defined as not using the C<&> character.  In
other words, if you call it like a built-in function, then it behaves
like a built-in function.  If you call it like an old-fashioned
subroutine, then it behaves like an old-fashioned subroutine.  It
naturally falls out from this rule that prototypes have no influence
on subroutine references like C<\&foo> or on indirect subroutine
calls like C<&{$subref}> or C<< $subref->() >>.

Method calls are not influenced by prototypes either, because the
function to be called is indeterminate at compile time, since
the exact code called depends on inheritance.

Because the intent of this feature is primarily to let you define
subroutines that work like built-in functions, here are prototypes
for some other functions that parse almost exactly like the
corresponding built-in.

    Declared as			Called as

    sub mylink ($$)	     mylink $old, $new
    sub myvec ($$$)	     myvec $var, $offset, 1
    sub myindex ($$;$)	     myindex &getstring, "substr"
    sub mysyswrite ($$$;$)   mysyswrite $buf, 0, length($buf) - $off, $off
    sub myreverse (@)	     myreverse $a, $b, $c
    sub myjoin ($@)	     myjoin ":", $a, $b, $c
    sub mypop (\@)	     mypop @array
    sub mysplice (\@$$@)     mysplice @array, @array, 0, @pushme
    sub mykeys (\%)	     mykeys %{$hashref}
    sub myopen (*;$)	     myopen HANDLE, $name
    sub mypipe (**)	     mypipe READHANDLE, WRITEHANDLE
    sub mygrep (&@)	     mygrep { /foo/ } $a, $b, $c
    sub myrand (;$)	     myrand 42
    sub mytime ()	     mytime

Any backslashed prototype character represents an actual argument
that absolutely must start with that character.  The value passed
as part of C<@_> will be a reference to the actual argument given
in the subroutine call, obtained by applying C<\> to that argument.

You can also backslash several argument types simultaneously by using
the C<\[]> notation:

    sub myref (\[$@%&*])

will allow calling myref() as

    myref $var
    myref @array
    myref %hash
    myref &sub
    myref *glob

and the first argument of myref() will be a reference to
a scalar, an array, a hash, a code, or a glob.

Unbackslashed prototype characters have special meanings.  Any
unbackslashed C<@> or C<%> eats all remaining arguments, and forces
list context.  An argument represented by C<$> forces scalar context.  An
C<&> requires an anonymous subroutine, which, if passed as the first
argument, does not require the C<sub> keyword or a subsequent comma.

A C<*> allows the subroutine to accept a bareword, constant, scalar expression,
typeglob, or a reference to a typeglob in that slot.  The value will be
available to the subroutine either as a simple scalar, or (in the latter
two cases) as a reference to the typeglob.  If you wish to always convert
such arguments to a typeglob reference, use Symbol::qualify_to_ref() as
follows:

    use Symbol 'qualify_to_ref';

    sub foo (*) {
	my $fh = qualify_to_ref(shift, caller);
	...
    }

A semicolon (C<;>) separates mandatory arguments from optional arguments.
It is redundant before C<@> or C<%>, which gobble up everything else.

As the last character of a prototype, or just before a semicolon, you can
use C<_> in place of C<$>: if this argument is not provided, C<$_> will be
used instead.

Note how the last three examples in the table above are treated
specially by the parser.  C<mygrep()> is parsed as a true list
operator, C<myrand()> is parsed as a true unary operator with unary
precedence the same as C<rand()>, and C<mytime()> is truly without
arguments, just like C<time()>.  That is, if you say

    mytime +2;

you'll get C<mytime() + 2>, not C<mytime(2)>, which is how it would be parsed
without a prototype.

The interesting thing about C<&> is that you can generate new syntax with it,
provided it's in the initial position:
X<&>

    sub try (&@) {
	my($try,$catch) = @_;
	eval { &$try };
	if ($@) {
	    local $_ = $@;
	    &$catch;
	}
    }
    sub catch (&) { $_[0] }

    try {
	die "phooey";
    } catch {
	/phooey/ and print "unphooey\n";
    };

That prints C<"unphooey">.  (Yes, there are still unresolved
issues having to do with visibility of C<@_>.  I'm ignoring that
question for the moment.  (But note that if we make C<@_> lexically
scoped, those anonymous subroutines can act like closures... (Gee,
is this sounding a little Lispish?  (Never mind.))))

And here's a reimplementation of the Perl C<grep> operator:
X<grep>

    sub mygrep (&@) {
	my $code = shift;
	my @result;
	foreach $_ (@_) {
	    push(@result, $_) if &$code;
	}
	@result;
    }

Some folks would prefer full alphanumeric prototypes.  Alphanumerics have
been intentionally left out of prototypes for the express purpose of
someday in the future adding named, formal parameters.  The current
mechanism's main goal is to let module writers provide better diagnostics
for module users.  Larry feels the notation quite understandable to Perl
programmers, and that it will not intrude greatly upon the meat of the
module, nor make it harder to read.  The line noise is visually
encapsulated into a small pill that's easy to swallow.

If you try to use an alphanumeric sequence in a prototype you will
generate an optional warning - "Illegal character in prototype...".
Unfortunately earlier versions of Perl allowed the prototype to be
used as long as its prefix was a valid prototype.  The warning may be
upgraded to a fatal error in a future version of Perl once the
majority of offending code is fixed.

It's probably best to prototype new functions, not retrofit prototyping
into older ones.  That's because you must be especially careful about
silent impositions of differing list versus scalar contexts.  For example,
if you decide that a function should take just one parameter, like this:

    sub func ($) {
	my $n = shift;
	print "you gave me $n\n";
    }

and someone has been calling it with an array or expression
returning a list:

    func(@foo);
    func( split /:/ );

Then you've just supplied an automatic C<scalar> in front of their
argument, which can be more than a bit surprising.  The old C<@foo>
which used to hold one thing doesn't get passed in.  Instead,
C<func()> now gets passed in a C<1>; that is, the number of elements
in C<@foo>.  And the C<split> gets called in scalar context so it
starts scribbling on your C<@_> parameter list.  Ouch!

This is all very powerful, of course, and should be used only in moderation
to make the world a better place.

=head2 Constant Functions
X<constant>

Functions with a prototype of C<()> are potential candidates for
inlining.  If the result after optimization and constant folding
is either a constant or a lexically-scoped scalar which has no other
references, then it will be used in place of function calls made
without C<&>.  Calls made using C<&> are never inlined.  (See
F<constant.pm> for an easy way to declare most constants.)

The following functions would all be inlined:

    sub pi ()		{ 3.14159 }		# Not exact, but close.
    sub PI ()		{ 4 * atan2 1, 1 }	# As good as it gets,
						# and it's inlined, too!
    sub ST_DEV ()	{ 0 }
    sub ST_INO ()	{ 1 }

    sub FLAG_FOO ()	{ 1 << 8 }
    sub FLAG_BAR ()	{ 1 << 9 }
    sub FLAG_MASK ()	{ FLAG_FOO | FLAG_BAR }

    sub OPT_BAZ ()	{ not (0x1B58 & FLAG_MASK) }

    sub N () { int(OPT_BAZ) / 3 }

    sub FOO_SET () { 1 if FLAG_MASK & FLAG_FOO }

Be aware that these will not be inlined; as they contain inner scopes,
the constant folding doesn't reduce them to a single constant:

    sub foo_set () { if (FLAG_MASK & FLAG_FOO) { 1 } }

    sub baz_val () {
	if (OPT_BAZ) {
	    return 23;
	}
	else {
	    return 42;
	}
    }

If you redefine a subroutine that was eligible for inlining, you'll get
a mandatory warning.  (You can use this warning to tell whether or not a
particular subroutine is considered constant.)  The warning is
considered severe enough not to be optional because previously compiled
invocations of the function will still be using the old value of the
function.  If you need to be able to redefine the subroutine, you need to
ensure that it isn't inlined, either by dropping the C<()> prototype
(which changes calling semantics, so beware) or by thwarting the
inlining mechanism in some other way, such as

    sub not_inlined () {
    	23 if $];
    }

=head2 Overriding Built-in Functions
X<built-in> X<override> X<CORE> X<CORE::GLOBAL>

Many built-in functions may be overridden, though this should be tried
only occasionally and for good reason.  Typically this might be
done by a package attempting to emulate missing built-in functionality
on a non-Unix system.

Overriding may be done only by importing the name from a module at
compile time--ordinary predeclaration isn't good enough.  However, the
C<use subs> pragma lets you, in effect, predeclare subs
via the import syntax, and these names may then override built-in ones:

    use subs 'chdir', 'chroot', 'chmod', 'chown';
    chdir $somewhere;
    sub chdir { ... }

To unambiguously refer to the built-in form, precede the
built-in name with the special package qualifier C<CORE::>.  For example,
saying C<CORE::open()> always refers to the built-in C<open()>, even
if the current package has imported some other subroutine called
C<&open()> from elsewhere.  Even though it looks like a regular
function call, it isn't: you can't take a reference to it, such as
the incorrect C<\&CORE::open> might appear to produce.

Library modules should not in general export built-in names like C<open>
or C<chdir> as part of their default C<@EXPORT> list, because these may
sneak into someone else's namespace and change the semantics unexpectedly.
Instead, if the module adds that name to C<@EXPORT_OK>, then it's
possible for a user to import the name explicitly, but not implicitly.
That is, they could say

    use Module 'open';

and it would import the C<open> override.  But if they said

    use Module;

they would get the default imports without overrides.

The foregoing mechanism for overriding built-in is restricted, quite
deliberately, to the package that requests the import.  There is a second
method that is sometimes applicable when you wish to override a built-in
everywhere, without regard to namespace boundaries.  This is achieved by
importing a sub into the special namespace C<CORE::GLOBAL::>.  Here is an
example that quite brazenly replaces the C<glob> operator with something
that understands regular expressions.

    package REGlob;
    require Exporter;
    @ISA = 'Exporter';
    @EXPORT_OK = 'glob';

    sub import {
	my $pkg = shift;
	return unless @_;
	my $sym = shift;
	my $where = ($sym =~ s/^GLOBAL_// ? 'CORE::GLOBAL' : caller(0));
	$pkg->export($where, $sym, @_);
    }

    sub glob {
	my $pat = shift;
	my @got;
	if (opendir my $d, '.') {
	    @got = grep /$pat/, readdir $d;
	    closedir $d;
	}
	return @got;
    }
    1;

And here's how it could be (ab)used:

    #use REGlob 'GLOBAL_glob';	    # override glob() in ALL namespaces
    package Foo;
    use REGlob 'glob';		    # override glob() in Foo:: only
    print for <^[a-z_]+\.pm\$>;	    # show all pragmatic modules

The initial comment shows a contrived, even dangerous example.
By overriding C<glob> globally, you would be forcing the new (and
subversive) behavior for the C<glob> operator for I<every> namespace,
without the complete cognizance or cooperation of the modules that own
those namespaces.  Naturally, this should be done with extreme caution--if
it must be done at all.

The C<REGlob> example above does not implement all the support needed to
cleanly override perl's C<glob> operator.  The built-in C<glob> has
different behaviors depending on whether it appears in a scalar or list
context, but our C<REGlob> doesn't.  Indeed, many perl built-in have such
context sensitive behaviors, and these must be adequately supported by
a properly written override.  For a fully functional example of overriding
C<glob>, study the implementation of C<File::DosGlob> in the standard
library.

When you override a built-in, your replacement should be consistent (if
possible) with the built-in native syntax.  You can achieve this by using
a suitable prototype.  To get the prototype of an overridable built-in,
use the C<prototype> function with an argument of C<"CORE::builtin_name">
(see L<perlfunc/prototype>).

Note however that some built-ins can't have their syntax expressed by a
prototype (such as C<system> or C<chomp>).  If you override them you won't
be able to fully mimic their original syntax.

The built-ins C<do>, C<require> and C<glob> can also be overridden, but due
to special magic, their original syntax is preserved, and you don't have
to define a prototype for their replacements.  (You can't override the
C<do BLOCK> syntax, though).

C<require> has special additional dark magic: if you invoke your
C<require> replacement as C<require Foo::Bar>, it will actually receive
the argument C<"Foo/Bar.pm"> in @_.  See L<perlfunc/require>.

And, as you'll have noticed from the previous example, if you override
C<glob>, the C<< <*> >> glob operator is overridden as well.

In a similar fashion, overriding the C<readline> function also overrides
the equivalent I/O operator C<< <FILEHANDLE> >>. Also, overriding
C<readpipe> also overrides the operators C<``> and C<qx//>.

Finally, some built-ins (e.g. C<exists> or C<grep>) can't be overridden.

=head2 Autoloading
X<autoloading> X<AUTOLOAD>

If you call a subroutine that is undefined, you would ordinarily
get an immediate, fatal error complaining that the subroutine doesn't
exist.  (Likewise for subroutines being used as methods, when the
method doesn't exist in any base class of the class's package.)
However, if an C<AUTOLOAD> subroutine is defined in the package or
packages used to locate the original subroutine, then that
C<AUTOLOAD> subroutine is called with the arguments that would have
been passed to the original subroutine.  The fully qualified name
of the original subroutine magically appears in the global $AUTOLOAD
variable of the same package as the C<AUTOLOAD> routine.  The name
is not passed as an ordinary argument because, er, well, just
because, that's why.  (As an exception, a method call to a nonexistent
C<import> or C<unimport> method is just skipped instead.)

Many C<AUTOLOAD> routines load in a definition for the requested
subroutine using eval(), then execute that subroutine using a special
form of goto() that erases the stack frame of the C<AUTOLOAD> routine
without a trace.  (See the source to the standard module documented
in L<AutoLoader>, for example.)  But an C<AUTOLOAD> routine can
also just emulate the routine and never define it.   For example,
let's pretend that a function that wasn't defined should just invoke
C<system> with those arguments.  All you'd do is:

    sub AUTOLOAD {
	my $program = $AUTOLOAD;
	$program =~ s/.*:://;
	system($program, @_);
    }
    date();
    who('am', 'i');
    ls('-l');

In fact, if you predeclare functions you want to call that way, you don't
even need parentheses:

    use subs qw(date who ls);
    date;
    who "am", "i";
    ls '-l';

A more complete example of this is the standard Shell module, which
can treat undefined subroutine calls as calls to external programs.

Mechanisms are available to help modules writers split their modules
into autoloadable files.  See the standard AutoLoader module
described in L<AutoLoader> and in L<AutoSplit>, the standard
SelfLoader modules in L<SelfLoader>, and the document on adding C
functions to Perl code in L<perlxs>.

=head2 Subroutine Attributes
X<attribute> X<subroutine, attribute> X<attrs>

A subroutine declaration or definition may have a list of attributes
associated with it.  If such an attribute list is present, it is
broken up at space or colon boundaries and treated as though a
C<use attributes> had been seen.  See L<attributes> for details
about what attributes are currently supported.
Unlike the limitation with the obsolescent C<use attrs>, the
C<sub : ATTRLIST> syntax works to associate the attributes with
a pre-declaration, and not just with a subroutine definition.

The attributes must be valid as simple identifier names (without any
punctuation other than the '_' character).  They may have a parameter
list appended, which is only checked for whether its parentheses ('(',')')
nest properly.

Examples of valid syntax (even though the attributes are unknown):

    sub fnord (&\%) : switch(10,foo(7,3))  :  expensive;
    sub plugh () : Ugly('\(") :Bad;
    sub xyzzy : _5x5 { ... }

Examples of invalid syntax:

    sub fnord : switch(10,foo(); # ()-string not balanced
    sub snoid : Ugly('(');	  # ()-string not balanced
    sub xyzzy : 5x5;		  # "5x5" not a valid identifier
    sub plugh : Y2::north;	  # "Y2::north" not a simple identifier
    sub snurt : foo + bar;	  # "+" not a colon or space

The attribute list is passed as a list of constant strings to the code
which associates them with the subroutine.  In particular, the second example
of valid syntax above currently looks like this in terms of how it's
parsed and invoked:

    use attributes __PACKAGE__, \&plugh, q[Ugly('\(")], 'Bad';

For further details on attribute lists and their manipulation,
see L<attributes> and L<Attribute::Handlers>.

=head1 SEE ALSO

See L<perlref/"Function Templates"> for more about references and closures.
See L<perlxs> if you'd like to learn about calling C subroutines from Perl.
See L<perlembed> if you'd like to learn about calling Perl subroutines from C.
See L<perlmod> to learn about bundling up your functions in separate files.
See L<perlmodlib> to learn what library modules come standard on your system.
See L<perltoot> to learn how to make object method calls.
